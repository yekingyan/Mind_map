<map version="freeplane 1.8.0">
<!--To view this file, download free mind mapping software Freeplane from http://freeplane.sourceforge.net -->
<node TEXT="事务" LOCALIZED_STYLE_REF="AutomaticLayout.level.root" FOLDED="false" ID="ID_1723255651" CREATED="1283093380553" MODIFIED="1616585852166" STYLE="bubble">
<font NAME="Noto Sans S Chinese Light" SIZE="14"/>
<hook NAME="MapStyle" zoom="0.979">
    <properties fit_to_viewport="false" show_icon_for_attributes="true" show_note_icons="true" edgeColorConfiguration="#808080ff,#ff0000ff,#0000ffff,#00ff00ff,#ff00ffff,#00ffffff,#7c0000ff,#00007cff,#007c00ff,#7c007cff,#007c7cff,#7c7c00ff"/>

<map_styles>
<stylenode LOCALIZED_TEXT="styles.root_node" STYLE="oval" UNIFORM_SHAPE="true" VGAP_QUANTITY="24.0 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="24"/>
<stylenode LOCALIZED_TEXT="styles.predefined" POSITION="right" STYLE="bubble" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
<stylenode LOCALIZED_TEXT="default" ICON_SIZE="12.0 pt" COLOR="#000000" STYLE="combined" BORDER_WIDTH="3.0 px" MAX_WIDTH="10.1 cm" MIN_WIDTH="0.0 cm" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="false" ITALIC="false"/>
<edge STYLE="sharp_bezier" WIDTH="7"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.details" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.attributes" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.note" COLOR="#000000" BACKGROUND_COLOR="#ffffff" TEXT_ALIGN="LEFT" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.floating" VGAP_QUANTITY="6.8999999999999995 pt">
<edge STYLE="hide_edge"/>
<cloud COLOR="#f0f0f0" SHAPE="ROUND_RECT"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.user-defined" POSITION="right" STYLE="bubble" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
<stylenode LOCALIZED_TEXT="styles.ok" VGAP_QUANTITY="6.8999999999999995 pt">
<icon BUILTIN="button_ok"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.needs_action" VGAP_QUANTITY="6.8999999999999995 pt">
<icon BUILTIN="messagebox_warning"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.floating_node" VGAP_QUANTITY="6.8999999999999995 pt">
<edge STYLE="hide_edge"/>
<cloud COLOR="#f0f0f0" SHAPE="ROUND_RECT"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.topic" COLOR="#18898b" STYLE="fork" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="true"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.subtopic" COLOR="#cc3300" STYLE="fork" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="true"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.subsubtopic" COLOR="#669900" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="true"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.connection" COLOR="#606060" STYLE="fork" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="false"/>
<cloud COLOR="#f0f0f0" SHAPE="ROUND_RECT"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.important" COLOR="#ff0000" VGAP_QUANTITY="6.8999999999999995 pt">
<icon BUILTIN="yes"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.question" VGAP_QUANTITY="6.8999999999999995 pt">
<icon BUILTIN="help"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.key" COLOR="#996600" VGAP_QUANTITY="6.8999999999999995 pt">
<icon BUILTIN="password"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="false"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.idea" VGAP_QUANTITY="6.8999999999999995 pt">
<icon BUILTIN="idea"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.note" COLOR="#990000" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.date" COLOR="#0033ff" VGAP_QUANTITY="6.8999999999999995 pt">
<icon BUILTIN="calendar"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.website" COLOR="#006633" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.list" COLOR="#cc6600" VGAP_QUANTITY="6.8999999999999995 pt">
<icon BUILTIN="list"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="true"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.quotation" COLOR="#338800" STYLE="fork" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="false" ITALIC="false"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.definition" COLOR="#666600" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="false"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.description" COLOR="#996600" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="false"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.pending" COLOR="#b3b95c" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode TEXT="代码" COLOR="#c0fdce" BACKGROUND_COLOR="#000000" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.AutomaticLayout" POSITION="right" STYLE="bubble" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level.root" COLOR="#000000" STYLE="oval" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
<edge COLOR="#003333"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,1" COLOR="#0033ff" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
<edge COLOR="#808080"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,2" COLOR="#003366" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
<edge COLOR="#808080"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,3" COLOR="#990000" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,4" COLOR="#111111" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,5" COLOR="#006666" VGAP_QUANTITY="6.8999999999999995 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,6" VGAP_QUANTITY="6.8999999999999995 pt">
<font SIZE="12"/>
</stylenode>
</stylenode>
</stylenode>
</map_styles>
</hook>
<hook NAME="AutomaticEdgeColor" COUNTER="128" RULE="ON_BRANCH_CREATION"/>
<hook NAME="accessories/plugins/AutomaticLayout.properties" VALUE="ALL"/>
<node TEXT="概念" POSITION="right" ID="ID_1658301856" CREATED="1619350610888" MODIFIED="1619350614414">
<edge COLOR="#7c007c"/>
<node TEXT=" 一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消" ID="ID_1873113624" CREATED="1619350614853" MODIFIED="1619350628688"/>
<node TEXT=" 一组sql语句组成的数据库逻辑处理单元，在这组的sql操作中，要么全部执行成功，要么全部执行失败" ID="ID_279104145" CREATED="1620894825897" MODIFIED="1620894827433"/>
<node TEXT="ACID特性" ID="ID_1535997936" CREATED="1619352757401" MODIFIED="1619352785923">
<node TEXT=" 原子性、一致性、隔离性、持久性" ID="ID_1509070896" CREATED="1619352776073" MODIFIED="1619352778445"/>
</node>
</node>
<node TEXT="sqlite事务" FOLDED="true" POSITION="right" ID="ID_1735786566" CREATED="1620292865921" MODIFIED="1620292873436">
<edge COLOR="#00ff00"/>
<node TEXT="connect isolation_level" ID="ID_1311616335" CREATED="1620294157644" MODIFIED="1620294239407">
<node TEXT="isolation_level为None" ID="ID_1827999245" CREATED="1620294177916" MODIFIED="1620294283469">
<node TEXT=" 开启自动 autocommit 模式" ID="ID_751797309" CREATED="1620294284619" MODIFIED="1620294546069"/>
<node TEXT=" autocommit 模式意味着修改数据库的操作会立即生效" ID="ID_858897154" CREATED="1620293358565" MODIFIED="1620293359847"/>
<node TEXT=" BEGIN 或 SAVEPOINT 语句会禁用 autocommit 模式，而用于结束外层事务的 COMMIT, ROLLBACK 或 RELEASE 则会恢复 autocommit 模式" ID="ID_156994885" CREATED="1620293350821" MODIFIED="1620293352839"/>
<node TEXT=" 底层的 sqlite3 库默认会以 autocommit 模式运行，但 Python 的 sqlite3 模块默认使用的却是deferred" ID="ID_464264590" CREATED="1620293312950" MODIFIED="1620294517071"/>
</node>
<node TEXT="isolation_level非None" ID="ID_653957748" CREATED="1620294206604" MODIFIED="1620294299794">
<node TEXT=" 设置BEGIN的类型，开启智能commit" ID="ID_373444869" CREATED="1620294295500" MODIFIED="1620294296727"/>
<node TEXT=" 在某些语句自动开启事务，执行某些语句前自动commit" ID="ID_1837315785" CREATED="1620294614867" MODIFIED="1620294616896"/>
<node TEXT="3种参数" ID="ID_362974050" CREATED="1620294168828" MODIFIED="1620294314222">
<node TEXT="&quot;DEFERRED&quot;" ID="ID_709357491" CREATED="1620294314443" MODIFIED="1620294323475"/>
<node TEXT="&quot;IMMEDIATE&quot;" ID="ID_1096887470" CREATED="1620294325435" MODIFIED="1620294335583"/>
<node TEXT="&quot; EXCLUSIVE&quot;" ID="ID_1500326261" CREATED="1620294342715" MODIFIED="1620294347735"/>
</node>
</node>
</node>
<node TEXT="3种事务模式" ID="ID_1546601147" CREATED="1620292874009" MODIFIED="1620292997645">
<node TEXT=" DEFERRED" ID="ID_903127624" CREATED="1620293013838" MODIFIED="1620293034301">
<node TEXT="默认模式的语法" ID="ID_1143441784" CREATED="1620293054159" MODIFIED="1620294016540">
<node ID="ID_532330052" CREATED="1620294020623" MODIFIED="1620294020623"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      BEGIN
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT="BEGIN TRANSACTION" ID="ID_409011573" CREATED="1620294008420" MODIFIED="1620294019433"/>
<node TEXT="BEGIN DEFERRED TRANSACTION" ID="ID_1635228956" CREATED="1620294039989" MODIFIED="1620294049433"/>
<node ID="ID_535027145" CREATED="1620294045702" MODIFIED="1620294045702"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      BEGIN DEFERRED
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT=" sqlite3模块默认模式，connect时指定将 isolation_level 设为 None" ID="ID_654460525" CREATED="1620293093582" MODIFIED="1620293472337"/>
<node TEXT=" 直到commit才真正启动transaction事务" ID="ID_1170198234" CREATED="1620293033272" MODIFIED="1620293038676"/>
<node TEXT=" deferred是获取RESERVED锁" ID="ID_1721305390" CREATED="1620294096285" MODIFIED="1620294097502"/>
</node>
<node ID="ID_1365558115" CREATED="1620293013838" MODIFIED="1620293013838"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      &nbsp;IMMEDIATE
    </p>
  </body>
</html>
</richcontent>
<node TEXT=" 两个客户端如果同时开始 begin immediate 事务，后启动的那个会失败" ID="ID_1027121182" CREATED="1620293705277" MODIFIED="1620293706599"/>
<node TEXT=" 即不能同时有多个write transaction" ID="ID_1559424163" CREATED="1620293713037" MODIFIED="1620293714045"/>
<node TEXT=" 如果一个deferred事务，执行到了insert，这个事务也变成了write transaction，其它客户端再执行 begin immediate | exclusive ，都会失败" ID="ID_1947407514" CREATED="1620293730941" MODIFIED="1620293732731"/>
<node TEXT=" immediate 是begin语句处获得PENDING锁" ID="ID_195953756" CREATED="1620294086172" MODIFIED="1620294088099"/>
</node>
<node TEXT=" EXCLUSIVE" ID="ID_1502879124" CREATED="1620293013840" MODIFIED="1620294341301">
<node TEXT=" exclusive最厉害，这样的transaction一旦开始，其它客户端都不能连接，除非SQLite工作在WAL模式下" ID="ID_489593005" CREATED="1620293749797" MODIFIED="1620293750932"/>
<node TEXT=" exclusive是获取EXCLUSIVE排他锁" ID="ID_961175599" CREATED="1620294114963" MODIFIED="1620294116012"/>
</node>
</node>
<node TEXT="隔离级别" ID="ID_919563475" CREATED="1620297690744" MODIFIED="1620297697915">
<node TEXT=" 串行化" ID="ID_930767073" CREATED="1620297761639" MODIFIED="1620297763064">
<node TEXT=" 串行化在事务开启时上读锁" ID="ID_1994788009" CREATED="1620297792983" MODIFIED="1620297808435"/>
<node TEXT=" 上锁和释放锁同样遵守两阶段锁协议，在事务提交或回滚时才释放锁" ID="ID_1762638420" CREATED="1620297805191" MODIFIED="1620297806429"/>
</node>
<node TEXT=" 读未提交" ID="ID_1928607993" CREATED="1620297763599" MODIFIED="1620297770203">
<node TEXT=" 读未提交，就是读全程不上锁" ID="ID_1414570479" CREATED="1620297774815" MODIFIED="1620297776816"/>
</node>
</node>
<node TEXT="锁" ID="ID_1431157986" CREATED="1620297853401" MODIFIED="1620297855242">
<node ID="ID_898615734" CREATED="1620297878248" MODIFIED="1620297878248"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      共享锁(SHARED_LOCK)
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1652695292" CREATED="1620297878248" MODIFIED="1620297878248"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      保留锁(RESERVED_LOCK)
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_23742529" CREATED="1620297878249" MODIFIED="1620297878249"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      未决锁(PENDING_LOCK)
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1219893153" CREATED="1620297878250" MODIFIED="1620297878250"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      排它锁(EXCLUSIVE_LOCK)
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node TEXT="MySQL事务" POSITION="right" ID="ID_234599085" CREATED="1619597364142" MODIFIED="1619597374779">
<edge COLOR="#0000ff"/>
<node TEXT="并发事务处理" ID="ID_1258126148" CREATED="1619600761412" MODIFIED="1619600777246">
<node TEXT=" 带来的问题" ID="ID_1399346131" CREATED="1619600779906" MODIFIED="1619600781611"/>
<node TEXT="解决办法" ID="ID_1337244854" CREATED="1619600782131" MODIFIED="1619600789823"/>
</node>
<node TEXT=" Mysql默认提交模式" FOLDED="true" ID="ID_1004844917" CREATED="1619608413456" MODIFIED="1620824612697">
<node TEXT=" Mysql默认采用自动提交模式" ID="ID_984942785" CREATED="1620824606632" MODIFIED="1620824608014"/>
<node TEXT=" 隐式提交事务（Implicit Commit）" ID="ID_973573226" CREATED="1620823509429" MODIFIED="1620823510549">
<node TEXT=" 只要执行DML操作的语句,会立即提交" ID="ID_1587144802" CREATED="1620823468213" MODIFIED="1620823516312"/>
</node>
<node TEXT=" 显性事务start transaction或begin" ID="ID_1328613963" CREATED="1620823502221" MODIFIED="1620823503479">
<node TEXT=" 首先数据库会隐式提交之前的还未被提交的操作" ID="ID_1417901086" CREATED="1620824109379" MODIFIED="1620824111123"/>
<node TEXT="然后自动提交将保持禁用状态，直到使用COMMIT或ROLLBACK结束事务" ID="ID_882899884" CREATED="1620823564181" MODIFIED="1620824120448"/>
<node TEXT="最后变回自动提交模式" ID="ID_108201789" CREATED="1620824128099" MODIFIED="1620824139773"/>
</node>
<node TEXT=" 修改当前连接的提交方式" ID="ID_1464613493" CREATED="1619603545484" MODIFIED="1619603546341">
<node TEXT=" SET AUTOCOMMIT = {0 | 1}" ID="ID_600423131" CREATED="1619603553341" MODIFIED="1619603554310"/>
<node TEXT=" 如果设置了 SET AUTOCOMMIT=0，则设置之后的所有事务都需要通过明确的命令进行提交或者回滚" ID="ID_724564864" CREATED="1619603554732" MODIFIED="1619603563934"/>
</node>
</node>
<node TEXT=" 本地事务的语句" FOLDED="true" ID="ID_1594761903" CREATED="1619603422390" MODIFIED="1619603423624">
<node TEXT=" MySQL 事务都是指在 InnoDB 引擎下，MyISAM 引擎是不支持事务的" ID="ID_312001668" CREATED="1620648472165" MODIFIED="1620648473331"/>
<node TEXT=" 开始一项新的事务" ID="ID_1374062462" CREATED="1619603437485" MODIFIED="1619603439705">
<node TEXT=" START TRANSACTION 或 BEGIN 语句" ID="ID_836199695" CREATED="1619603444789" MODIFIED="1619603445946"/>
<node TEXT=" START TRANSACTION | BEGIN [WORK]" ID="ID_18122384" CREATED="1619603452893" MODIFIED="1619603453946"/>
</node>
<node TEXT="提交事务" ID="ID_1711368432" CREATED="1619603461733" MODIFIED="1619603466919">
<node TEXT=" COMMIT语句" ID="ID_1827079152" CREATED="1619603489957" MODIFIED="1619603516734"/>
<node TEXT=" COMMIT [WORK] [AND [NO] CHAIN] [[NO] RELEASE]" ID="ID_1984828150" CREATED="1619603482501" MODIFIED="1619603483707"/>
</node>
<node TEXT="回滚事务" ID="ID_825180064" CREATED="1619603467101" MODIFIED="1619603471808">
<node TEXT=" ROLLBACK语句" ID="ID_173043606" CREATED="1619603508180" MODIFIED="1619603514222"/>
<node TEXT=" ROLLBACK [WORK] [AND [NO] CHAIN] [[NO] RELEASE]" ID="ID_1960944185" CREATED="1619603522444" MODIFIED="1619603523436"/>
</node>
<node TEXT=" 典型的MySQL事务" ID="ID_704281995" CREATED="1619609034701" MODIFIED="1619609035826">
<node TEXT="BEGIN;&#xa;UPDATE accounts SET balance = balance - 100 WHERE id = 1;&#xa;UPDATE accounts SET balance = balance + 100 WHERE id = 2;&#xa;COMMIT;" ID="ID_872129311" CREATED="1619609040662" MODIFIED="1619609945442"/>
<node TEXT=" 如果sql语句执行出现问题，会自动调用rollback" ID="ID_780723361" CREATED="1619609072544" MODIFIED="1619609079104"/>
</node>
</node>
<node TEXT=" SQL4类隔离级别" FOLDED="true" ID="ID_135962062" CREATED="1619601099378" MODIFIED="1620823221779">
<node TEXT=" 读未提交(Read Uncommitted)" ID="ID_1263809245" CREATED="1620700760712" MODIFIED="1620700761892">
<node TEXT="这种事务隔离级别下，select语句不加锁。" ID="ID_2555131" CREATED="1620700774135" MODIFIED="1620700785599"/>
<node TEXT="&quot;读未提交&quot;，意思就是即使一个更新语句没有提交，但是别的事务可以读到这个改变" ID="ID_874126072" CREATED="1620700774136" MODIFIED="1620700783421"/>
<node TEXT="读到一个被修改中的数据，又被回滚了" ID="ID_1832204893" CREATED="1620700774138" MODIFIED="1620700781172"/>
<node TEXT="最低级别的隔离，是读取已提交+新的隔离突破。" ID="ID_1033517492" CREATED="1620700774140" MODIFIED="1620700816116"/>
<node TEXT=" 这是并发最高，一致性最差的隔离级别" ID="ID_333114810" CREATED="1620700816981" MODIFIED="1620700817918"/>
</node>
<node TEXT=" 已提交读(Read Committed)" ID="ID_1564288817" CREATED="1620700849540" MODIFIED="1620700850426">
<node TEXT="概念" ID="ID_1294916457" CREATED="1620800625185" MODIFIED="1620800627149">
<node TEXT="Oracle、SQL Server等多数数据库默认都是该级别。互联网最常用的隔离级别" ID="ID_1452509391" CREATED="1620700887851" MODIFIED="1620726827954"/>
<node ID="ID_554478566" CREATED="1620700887847" MODIFIED="1620700887847"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      &nbsp;一事务执行了 Commit 以后，别的事务就能读到这个改变
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT="隔离级别比可重复读低" ID="ID_216591540" CREATED="1620700887855" MODIFIED="1620801834314"/>
</node>
<node TEXT="innoDB的读" ID="ID_1203653387" CREATED="1620800586802" MODIFIED="1620800595239">
<node TEXT="普通select读是快照读" ID="ID_369334479" CREATED="1620726925362" MODIFIED="1620726952750"/>
<node TEXT=" 加锁的select, update, delete等语句" ID="ID_564893843" CREATED="1620726953121" MODIFIED="1620726960878">
<node TEXT=" 在外键约束检查(foreign-key constraint checking)以及重复键检查(duplicate-key checking)时会封锁区间" ID="ID_1109105383" CREATED="1620726990281" MODIFIED="1620726991414"/>
<node TEXT=" 其他时刻都只使用记录锁" ID="ID_1734823119" CREATED="1620726995444" MODIFIED="1620726996504"/>
</node>
</node>
<node ID="ID_760176306" CREATED="1620700887853" MODIFIED="1620700887853"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      同一个事务中执行完全相同的select语句时可能看到不一样的结果
    </p>
  </body>
</html>
</richcontent>
<node TEXT="可能有不可重复读" ID="ID_1321583743" CREATED="1620800915200" MODIFIED="1620800927236">
<node TEXT="本事务读取时，其它事务仍然可修改" ID="ID_1308162172" CREATED="1620801032145" MODIFIED="1620801089788"/>
<node TEXT="如果其它事务的更新时机在两次查询之前，更改同一条数据，本事务不可重复读" ID="ID_590125968" CREATED="1620800977065" MODIFIED="1620801025075"/>
</node>
<node TEXT="可能幻读" ID="ID_127990061" CREATED="1620800787458" MODIFIED="1620800797932">
<node TEXT=" 本事务读取时，其他事务仍然可以插入或删除" ID="ID_163160534" CREATED="1620727008209" MODIFIED="1620801083854"/>
<node TEXT=" 如果其它事务的插入时机在两次查询之前，插入数据在本事务的查询范围内。就可能导致本事务读取到幻影记录" ID="ID_779867821" CREATED="1620800831577" MODIFIED="1620800911494"/>
</node>
</node>
</node>
<node TEXT=" 可重复读(Repeated Read, RR)" FOLDED="true" ID="ID_848220867" CREATED="1620700931819" MODIFIED="1620700933051">
<node TEXT="概念" ID="ID_1302635896" CREATED="1620802315905" MODIFIED="1620802318596">
<node TEXT=" MySQL默认模式，InnoDB默认的隔离级别" ID="ID_681843459" CREATED="1620718653332" MODIFIED="1620718674045"/>
<node TEXT=" 在同一个事务里面先后执行同一个查询语句的时候，读到的同一批数据是一样的。" ID="ID_263394308" CREATED="1620700978435" MODIFIED="1620700980691"/>
<node TEXT="本事务开始了，别的事务就算有commit才影响不到本事务的select结果" ID="ID_927310921" CREATED="1620801842639" MODIFIED="1620801887254"/>
<node TEXT="这个级别比不可重复读的隔离级别高" ID="ID_559382783" CREATED="1620802253907" MODIFIED="1620802295694"/>
</node>
<node TEXT="快照读与当前读" ID="ID_1521562888" CREATED="1620787832857" MODIFIED="1620787845687">
<node TEXT=" 普通的select" ID="ID_1815283692" CREATED="1620718703733" MODIFIED="1620718737042">
<node TEXT=" 使用快照读(snapshot read)，底层使用MVCC来实现" ID="ID_262179174" CREATED="1620718717406" MODIFIED="1620718745235"/>
<node TEXT=" 这是一种不加锁的一致性读(Consistent Nonlocking Read)" ID="ID_1367473497" CREATED="1620718711148" MODIFIED="1620718712656"/>
</node>
<node TEXT=" 加锁的select" ID="ID_1435673559" CREATED="1620718729460" MODIFIED="1620718730383">
<node TEXT=" select ... in share mode / select ... for update, update, delete等语句" ID="ID_1227128029" CREATED="1620718759411" MODIFIED="1620718767966"/>
<node TEXT=" 在唯一索引上使用唯一的查询条件，会使用记录锁(record lock)" ID="ID_1220886157" CREATED="1620726755322" MODIFIED="1620726756404"/>
<node TEXT=" 范围查询条件，会使用间隙锁与临键锁，以避免产生幻影行记录，尽量避免不可重复的读" ID="ID_350936896" CREATED="1620726766707" MODIFIED="1620726787554"/>
</node>
<node TEXT="" ID="ID_1233068469" CREATED="1620787858595" MODIFIED="1620787863696">
<hook URI="事务_files/png_4586628994292387414.png" SIZE="0.29290166" NAME="ExternalObject"/>
</node>
</node>
<node TEXT="例子" ID="ID_1034223898" CREATED="1620904608476" MODIFIED="1620904611072">
<node TEXT="t1" ID="ID_1233234877" CREATED="1620904611355" MODIFIED="1620904613791">
<node TEXT="t1事务 修改并提交" ID="ID_26262546" CREATED="1620904616315" MODIFIED="1620905082330"/>
<node ID="ID_643357481" CREATED="1620905051825" MODIFIED="1620905051825"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: JetBrains Mono,monospace; font-size: 9.8pt"><span style="color: #6a8759"><font color="#6a8759">// 1. </font></span><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">查看初始值</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">mysql> select * from user;<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">| id   | name |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">|    1 | asd  |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">1 row in set (0.00 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">// 3.</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">修改并提交</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">mysql> update user set name="t1" where id=1;<br/></span><span style="color: #6a8759">Query OK, 1 row affected (0.00 sec)<br/></span><span style="color: #6a8759">Rows matched: 1  Changed: 1  Warnings: 0<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">mysql> commit;<br/></span><span style="color: #6a8759">Query OK, 0 rows affected (0.01 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">// 4.</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">修改成功了</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">mysql> select * from user;<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">| id   | name |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">|    1 | t1   |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">1 row in set (0.00 sec)</span></font></pre>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="t2" ID="ID_1022567853" CREATED="1620904614163" MODIFIED="1620904615326">
<node TEXT="t2事务在t1提交前，分别查询一次。" ID="ID_731942956" CREATED="1620905085058" MODIFIED="1620905119030"/>
<node TEXT="读快照值，没有出现不可重复读" ID="ID_540381131" CREATED="1620905119346" MODIFIED="1620905136653"/>
<node ID="ID_450926047" CREATED="1620905354245" MODIFIED="1620905354245"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: JetBrains Mono,monospace; font-size: 9.8pt"><span style="color: #6a8759"><font color="#6a8759">mysql> begin;<br/></font></span><font color="#6a8759"><span style="color: #6a8759">Query OK, 0 rows affected (0.00 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">// 2. t2</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">是</font></span><span style="color: #6a8759"><font color="#6a8759">t1</font></span><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">并发的事务，查看值</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">mysql> select * from user;<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">| id   | name |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">|    1 | asd  |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">1 row in set (0.00 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">// 5. t1</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">修改提交后，再查看，还是快照值</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">mysql> select * from user;<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">| id   | name |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">|    1 | asd  |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">1 row in set (0.00 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">// 6.</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">用当前读，就可以读到最新的提交值</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">mysql> select * from user for update;<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">| id   | name |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">|    1 | t1   |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">1 row in set (0.00 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">// 7.</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">普通的</font></span><span style="color: #6a8759"><font color="#6a8759">select</font></span><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">只能读快照</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">mysql> select * from user;<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">| id   | name |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">|    1 | asd  |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">1 row in set (0.00 sec)</span></font></pre>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
</node>
<node TEXT=" 串行化(Serializable)" ID="ID_1022786226" CREATED="1620727047450" MODIFIED="1620727052879">
<node TEXT="概念" ID="ID_19118300" CREATED="1620737364258" MODIFIED="1620737366690">
<node TEXT="最高级别的隔离，串行读不允许不一致现象的出现" ID="ID_1331014395" CREATED="1620737377201" MODIFIED="1620737431662"/>
<node ID="ID_691297217" CREATED="1620737377202" MODIFIED="1620737377202"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      &quot;序列化&quot;，意思是说这个事务执行的时候不允许别的事务并发执行
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT="这是一致性最好的，但并发性最差的隔离级别" ID="ID_270403618" CREATED="1620737396065" MODIFIED="1620737410385"/>
</node>
<node TEXT="协议" ID="ID_815147019" CREATED="1620737439600" MODIFIED="1620737444455">
<node TEXT=" 读加共享锁，写加排他锁，读写互斥" ID="ID_1420834708" CREATED="1620737459160" MODIFIED="1620737460500"/>
<node TEXT=" 完全串行化的读" ID="ID_6491000" CREATED="1620737450801" MODIFIED="1620737552521">
<node TEXT=" 每次读都需要获得表级共享锁" ID="ID_317809187" CREATED="1620737553056" MODIFIED="1620737559733">
<node TEXT="select语句被隐式的转化为select ... in share mode" ID="ID_740888682" CREATED="1620737569120" MODIFIED="1620737583646"/>
</node>
<node TEXT=" 读写相互都会阻塞" ID="ID_1727931551" CREATED="1620737559976" MODIFIED="1620737561359">
<node TEXT=" 如果有未提交的事务正在修改某些行，所有读取这些行的select都会被阻塞住" ID="ID_1831047321" CREATED="1620727071225" MODIFIED="1620727072138"/>
</node>
</node>
<node TEXT=" 通过强制事务排序，使之不可能相互冲突，从而解决幻读问题" ID="ID_751145329" CREATED="1620737479176" MODIFIED="1620737480469"/>
</node>
<node TEXT=" 在这个级别，可能导致大量的超时现象和锁竞争" ID="ID_1469367696" CREATED="1620737495576" MODIFIED="1620737496721"/>
</node>
</node>
<node TEXT="事务隔离需要解决的问题" FOLDED="true" ID="ID_1114977381" CREATED="1620822595115" MODIFIED="1620822630823">
<node TEXT=" 脏读” 、 “不可重复读”和“幻读” ，其实都是数据库读一致性问题" ID="ID_463152049" CREATED="1619600924739" MODIFIED="1619600927390"/>
<node TEXT="丢失修改" FOLDED="true" ID="ID_339094253" CREATED="1620736908611" MODIFIED="1620736916943">
<node TEXT=" 丢失修改(Lost Update)" ID="ID_738484127" CREATED="1620737045267" MODIFIED="1620737046696">
<node TEXT="并发 写-写事务，可能丢失修改" ID="ID_905661370" CREATED="1620891863666" MODIFIED="1620891893061"/>
<node TEXT="一事务在最后的更新覆盖了由其他事务所做的更新" ID="ID_190072620" CREATED="1620737063787" MODIFIED="1620891980206"/>
</node>
<node TEXT="第一类" ID="ID_1784551721" CREATED="1620736919586" MODIFIED="1620736922234">
<node ID="ID_11624249" CREATED="1620736949380" MODIFIED="1620736949380"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      当两个事务更新相同的数据源
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT="第一个事务被提交，第二个却被撤销" ID="ID_1346534538" CREATED="1620736949380" MODIFIED="1620736990017"/>
<node TEXT="造成第一个事务做的更新也被撤销" ID="ID_883010637" CREATED="1620736990827" MODIFIED="1620737001135"/>
</node>
<node TEXT=" 第二类" ID="ID_463508996" CREATED="1620736955946" MODIFIED="1620736957251">
<node ID="ID_190904057" CREATED="1620736969132" MODIFIED="1620736969132"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      有两个并发事务同时读取修改同一行数据
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT="其中一个对它进行修改提交，而另一个也进行了修改提交" ID="ID_1064848554" CREATED="1620736969133" MODIFIED="1620737006298"/>
<node TEXT=" 造成第一次写操作失效" ID="ID_1540099861" CREATED="1620737007196" MODIFIED="1620737013468"/>
</node>
<node TEXT="并发事务处理，避免更新丢失" ID="ID_1929975034" CREATED="1619600839459" MODIFIED="1619600889901">
<node TEXT=" “更新丢失”通常是应该完全避免的" ID="ID_311524183" CREATED="1619600851474" MODIFIED="1619600852475"/>
<node TEXT=" 防止更新丢失应该是应用的责任" ID="ID_313063349" CREATED="1619600870443" MODIFIED="1619600871704"/>
<node TEXT=" 防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决" ID="ID_1799532026" CREATED="1619600864170" MODIFIED="1619600865169"/>
</node>
</node>
<node TEXT="脏读（dirtyRead）" FOLDED="true" ID="ID_1750398341" CREATED="1620650070866" MODIFIED="1620650108229">
<node TEXT="概念" ID="ID_165550912" CREATED="1620802612499" MODIFIED="1620802617438">
<node TEXT=" 脏读指的是读到了其他事务未提交的数据" ID="ID_1796816431" CREATED="1620650142235" MODIFIED="1620650143485"/>
<node TEXT="这种数据在其他事务中修改了，但还没有提交到数据库中，是可能随时回滚的" ID="ID_720199117" CREATED="1620650122165" MODIFIED="1620650258605"/>
<node TEXT=" 读到了并一定最终存在的数据，这就是脏读" ID="ID_947372878" CREATED="1620650369897" MODIFIED="1620650371032"/>
<node TEXT=" 读未提交 会造成 脏读" ID="ID_1388042685" CREATED="1620803102787" MODIFIED="1620803111809"/>
</node>
<node TEXT="解决方法" ID="ID_990618806" CREATED="1620802621907" MODIFIED="1620802629031">
<node TEXT="隔离级别由读未提交提高到读提交，只有提交才能读" ID="ID_495175640" CREATED="1620802943686" MODIFIED="1620803142367"/>
<node TEXT=" 读取时加上共享锁" ID="ID_668867418" CREATED="1620802723986" MODIFIED="1620802733883">
<node TEXT=" 不允许其它任何事务修改该数据" ID="ID_1390466969" CREATED="1620802753786" MODIFIED="1620802772839"/>
<node TEXT="如果此时本事务有修改，就升级为排他锁" ID="ID_294156579" CREATED="1620802782146" MODIFIED="1620802798557"/>
</node>
<node TEXT=" 修改时加排他锁" ID="ID_455042487" CREATED="1620802636180" MODIFIED="1620802659406">
<node TEXT=" 直到事务提交后才释放锁" ID="ID_1843561927" CREATED="1620802659778" MODIFIED="1620802999553"/>
<node TEXT="限制其它事务读取与修改" ID="ID_1237488066" CREATED="1620802665171" MODIFIED="1620803066886"/>
</node>
<node TEXT="多个事务获得共享锁可读，其中一事务修改，其它事务就会出现不可重复读" ID="ID_633165259" CREATED="1620802847095" MODIFIED="1620802909250"/>
</node>
<node TEXT="例子" ID="ID_1090603811" CREATED="1620903934325" MODIFIED="1620903936818">
<node TEXT="t1" ID="ID_401545764" CREATED="1620903937278" MODIFIED="1620903939088">
<node ID="ID_1899137759" CREATED="1620903966074" MODIFIED="1620903966074"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: JetBrains Mono,monospace; font-size: 9.8pt"><span style="color: #6a8759"><font color="#6a8759">mysql> begin;<br/></font></span><font color="#6a8759"><span style="color: #6a8759">Query OK, 0 rows affected (0.00 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">mysql> select * from user where id=1;<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">| id   | name |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">|    1 | asd  |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">1 row in set (0.00 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">mysql> update user set name="t1" where id=1;<br/></span><span style="color: #6a8759">Query OK, 1 row affected (0.00 sec)<br/></span><span style="color: #6a8759">Rows matched: 1  Changed: 1  Warnings: 0<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">mysql> select * from user where id=1;<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">| id   | name |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">|    1 | t1   |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">1 row in set (0.00 sec)</span></font></pre>
  </body>
</html>
</richcontent>
</node>
<node TEXT="此时t1 update完, 未commit" ID="ID_765041276" CREATED="1620903972933" MODIFIED="1620904056633"/>
</node>
<node TEXT="t2" ID="ID_570039554" CREATED="1620903939221" MODIFIED="1620903940489">
<node ID="ID_1426432668" CREATED="1620904032841" MODIFIED="1620904032841"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: JetBrains Mono,monospace; font-size: 9.8pt"><span style="color: #6a8759"><font color="#6a8759">mysql> begin;<br/></font></span><font color="#6a8759"><span style="color: #6a8759">Query OK, 0 rows affected (0.00 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">mysql> select * from user;<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">| id   | name |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">|    1 | t1   |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">1 row in set (0.00 sec)</span></font></pre>
  </body>
</html>
</richcontent>
</node>
<node TEXT="t2 读到t1未commit的修改" ID="ID_235589628" CREATED="1620904033925" MODIFIED="1620904048088"/>
</node>
</node>
</node>
<node TEXT="不可重复读" FOLDED="true" ID="ID_1516634992" CREATED="1620650083306" MODIFIED="1620650088447">
<node ID="ID_1870054766" CREATED="1620735464281" MODIFIED="1620735464281"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      在同一事务中，两次读取同一数据（同一主键），得到内容不同（其它事务改了）
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT=" 不可重复读是针对update操作，读取了其他事务更改的数据" ID="ID_61705540" CREATED="1620735906703" MODIFIED="1621058940714"/>
<node TEXT="可提交读的隔离级别会有可能出现不可重复读" ID="ID_1630124478" CREATED="1620734595113" MODIFIED="1620734627940"/>
<node TEXT="解决方法" ID="ID_1447056103" CREATED="1620735959408" MODIFIED="1620735966205">
<node TEXT="不想出现不可重复读的事务，使用行级锁，锁定该行" ID="ID_1455760951" CREATED="1620735966488" MODIFIED="1620804246548"/>
<node TEXT="事务A多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据" ID="ID_1623668587" CREATED="1620804246863" MODIFIED="1620804249898"/>
</node>
<node TEXT="" ID="ID_1967607322" CREATED="1620736401040" MODIFIED="1620736404308">
<hook URI="事务_files/png_475361036512256477.png" SIZE="0.41521907" NAME="ExternalObject"/>
</node>
</node>
<node TEXT="幻读 Phantom" FOLDED="true" ID="ID_879116640" CREATED="1620650075667" MODIFIED="1620734690085">
<node TEXT="概念" ID="ID_1954810941" CREATED="1620650402849" MODIFIED="1620650406634">
<node TEXT=" 幻读是针对数据插入、删除操作来说的，用写来证实读的是鬼影" ID="ID_1093485780" CREATED="1620651197990" MODIFIED="1620735936382"/>
<node TEXT=" 当某个事务在读取某个范围的记录的时候，另外一个事务又在该范围插入了新的记录，当前事务再次读取这个范围的记录，会产生幻行（Phantom Data）" ID="ID_1921500714" CREATED="1620651510747" MODIFIED="1620651515590"/>
<node TEXT=" 幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行" ID="ID_495452486" CREATED="1620734673559" MODIFIED="1620734674869"/>
</node>
<node TEXT="" ID="ID_525988960" CREATED="1620734778195" MODIFIED="1620734781845">
<hook URI="事务_files/png_8758552164755563637.png" SIZE="0.77085847" NAME="ExternalObject"/>
</node>
<node TEXT="解决方法" ID="ID_413536039" CREATED="1620736010889" MODIFIED="1620736014240">
<node TEXT=" 不想出现幻读的事务，使用表级锁，锁定整张表" ID="ID_881832617" CREATED="1620735984736" MODIFIED="1620804287276"/>
<node TEXT="事务A多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。" ID="ID_1997693878" CREATED="1620804287462" MODIFIED="1620804293303"/>
</node>
<node TEXT="InnoDB解决幻读" FOLDED="true" ID="ID_772554212" CREATED="1620803291809" MODIFIED="1620803306509">
<node TEXT="超劲的InnoDB" ID="ID_150250156" CREATED="1620822421017" MODIFIED="1620822467648">
<node TEXT=" ANSI SQL隔离级别标准里可重复读级别是存在幻读问题" ID="ID_632231611" CREATED="1620651461566" MODIFIED="1620651462588"/>
<node TEXT="InnoDB的可重复读是不存在幻读问题的" ID="ID_1050796596" CREATED="1620651435932" MODIFIED="1620651456211"/>
</node>
<node TEXT="快照读的幻读" ID="ID_1900794091" CREATED="1620803313585" MODIFIED="1620803325820">
<node TEXT="可重复读级别通过MVCC机制解决了幻读问题" ID="ID_915041888" CREATED="1620651468827" MODIFIED="1620803407661"/>
<node TEXT=" 事务A启动的时候通过MVCC建立了一个稳定的视图（快照）" ID="ID_1093096219" CREATED="1620651548731" MODIFIED="1620803468451"/>
<node TEXT="事务A过程中，无论数据怎么变更，它读到的数据都是不变的！！所以不存在幻读可能" ID="ID_369899585" CREATED="1620803459327" MODIFIED="1620803473890"/>
</node>
<node TEXT="当前读的幻读" ID="ID_957648102" CREATED="1620803325977" MODIFIED="1620803333516">
<node TEXT="当前读的读取是最新版本的记录" ID="ID_859631638" CREATED="1620803497887" MODIFIED="1621056821844"/>
<node TEXT="  没有快照，因此会有锁，会有阻塞" ID="ID_1393500319" CREATED="1621056926273" MODIFIED="1621056929046"/>
<node TEXT=" next-key锁解决当前读情况下的幻读" ID="ID_750998052" CREATED="1620803371896" MODIFIED="1620803390740"/>
<node TEXT="next-key锁" ID="ID_1474696461" CREATED="1620805072234" MODIFIED="1620805080134">
<node TEXT="next-key lock 由 Record Lock 和 Gap Lock 组合而成" ID="ID_1050382440" CREATED="1620804978642" MODIFIED="1620805016020"/>
<node TEXT=" Record Lock" ID="ID_1442505281" CREATED="1620805016521" MODIFIED="1620805022036">
<node TEXT=" 单个行记录上的锁" ID="ID_1065232866" CREATED="1620805025065" MODIFIED="1620805025830"/>
<node TEXT=" 锁定一个记录上的索引，而不是记录本身" ID="ID_1232735179" CREATED="1620805117584" MODIFIED="1620805119319"/>
<node TEXT=" 如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用" ID="ID_785947377" CREATED="1620805129640" MODIFIED="1620805130671"/>
</node>
<node TEXT=" Gap Lock" ID="ID_1855834388" CREATED="1620805029993" MODIFIED="1620805031640">
<node TEXT=" 间隙锁，锁定一个范围，但不包括记录本身" ID="ID_537657398" CREATED="1620805036515" MODIFIED="1620805037406"/>
<node TEXT=" 锁定索引之间的间隙，但是不包含索引本身" ID="ID_123636078" CREATED="1620805150176" MODIFIED="1620805154427"/>
<node TEXT=" GAP锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况" ID="ID_1919526547" CREATED="1620805042521" MODIFIED="1620805043643"/>
</node>
<node TEXT=" 对于行的查询，锁定一个范围，并且锁定记录本身" ID="ID_1078966103" CREATED="1620804914506" MODIFIED="1620804923355"/>
</node>
</node>
</node>
</node>
<node TEXT="当前最新读带来的问题" ID="ID_243944827" CREATED="1620651801835" MODIFIED="1620651811030">
<node TEXT="例子" ID="ID_1852059662" CREATED="1620650422569" MODIFIED="1620650425252">
<node TEXT="主事务与干扰事务" ID="ID_1849789995" CREATED="1620650767543" MODIFIED="1620650779932">
<node ID="ID_1712106671" CREATED="1620650629054" MODIFIED="1620650629054"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: JetBrains Mono,monospace; font-size: 9.8pt"><span style="color: #6a8759"><font color="#6a8759"># users</font></span><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">：</font></span><span style="color: #6a8759"><font color="#6a8759"> id </font></span><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">主键</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">SELECT * FROM users WHERE id = 1;  # T1</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">事务</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">INSERT INTO `users`(`id`, `name`) VALUES (1, 'big cat');  # T2</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">事务</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">INSERT INTO `users`(`id`, `name`) VALUES (1, 'big cat');  # T1</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">事务<br/></font></span></pre>
  </body>
</html>
</richcontent>
</node>
<node TEXT=" T1 为主事务，检测表中是否有 id 为 1 的记录，没有则插入。这是期望的正常业务逻辑" ID="ID_740623847" CREATED="1620650652791" MODIFIED="1620650722471"/>
<node TEXT=" T2 为干扰事务，目的在于扰乱 T1 的正常的事务执行" ID="ID_1235191078" CREATED="1620650658617" MODIFIED="1620650710702"/>
</node>
<node TEXT="结果" ID="ID_947739915" CREATED="1620650786287" MODIFIED="1620650788244">
<node ID="ID_100740886" CREATED="1620650798304" MODIFIED="1620650798304"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      第1、2行 是会正常执行的，第3行 则会报错主键冲突
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_525243115" CREATED="1620650798304" MODIFIED="1620650798304"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      对于 T1 的业务来说是执行失败的
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_946326256" CREATED="1620650798308" MODIFIED="1620650798308"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      这里 T1 就是发生了幻读，因为T1读取的数据状态并不能支持他的下一步的业务，见鬼了一样。
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node TEXT="避免最新读带来的问题" ID="ID_458908647" CREATED="1620650882118" MODIFIED="1620651989026">
<node TEXT="串行读级别的隔离" ID="ID_1330754961" CREATED="1620650817775" MODIFIED="1620651036641">
<node TEXT=" select 操作并会对当前记录隐式加锁" ID="ID_1639206313" CREATED="1620651029262" MODIFIED="1620651030277"/>
<node TEXT=" 1 执行时是会隐式的添加 gap 共享锁的，从而 2 会被阻塞，3 会正常执行" ID="ID_168508345" CREATED="1620651125261" MODIFIED="1620651126951"/>
<node TEXT=" 对于 T1 来说业务是正确的，成功的扼杀了扰乱业务的T2" ID="ID_1904083847" CREATED="1620651130693" MODIFIED="1620651137653"/>
</node>
<node TEXT=" 手动加锁" ID="ID_1154984438" CREATED="1620651082623" MODIFIED="1620651084221">
<node TEXT="可重复读(mysql默认)通过对 select for update操作手动加锁" ID="ID_260968985" CREATED="1620650931768" MODIFIED="1620651086693"/>
</node>
<node TEXT=" 即便当前记录不存在，比如 id = 1 是不存在的，但当前事务也会获得一把记录锁" ID="ID_1142144952" CREATED="1620651048207" MODIFIED="1620651049505"/>
<node TEXT=" 锁定的是索引，故记录实体存在与否没关系" ID="ID_1888132145" CREATED="1620651057622" MODIFIED="1620651058678"/>
<node TEXT=" 其他事务无法插入此索引的记录，故不会被其它事务抢占主键" ID="ID_1187643707" CREATED="1620651065982" MODIFIED="1620651936143"/>
</node>
</node>
</node>
<node TEXT=" 事务隔离级别 查看与设置" FOLDED="true" ID="ID_310503124" CREATED="1620901866631" MODIFIED="1620901867889">
<node TEXT="级别" ID="ID_1499441853" CREATED="1620901871119" MODIFIED="1620901874786">
<node ID="ID_672971359" CREATED="1620901888809" MODIFIED="1620901888809"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      READ UNCOMMITTED
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1412274706" CREATED="1620901888809" MODIFIED="1620901888809"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      READ COMMITTED
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_85799484" CREATED="1620901888810" MODIFIED="1620901888810"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      REPEATABLE READ
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_13181477" CREATED="1620901888811" MODIFIED="1620901888811"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SERIALIZABLE
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="查看" ID="ID_1524450401" CREATED="1620901892888" MODIFIED="1620901895073">
<node TEXT=" SELECT @@transaction_isolation;" ID="ID_453202754" CREATED="1620901898406" MODIFIED="1620901899616"/>
</node>
<node TEXT="设置" ID="ID_220279714" CREATED="1620901901335" MODIFIED="1620901905489">
<node TEXT=" 设置全局的事务隔离级别" ID="ID_147099149" CREATED="1620901909231" MODIFIED="1620901910247">
<node ID="ID_799711693" CREATED="1620901936592" MODIFIED="1620901936592"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SET GLOBAL tx_isolation='REPEATABLE-READ';
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1054530693" CREATED="1620901936592" MODIFIED="1620901936592"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT=" 设置当前session的事务隔离级别" ID="ID_1546270595" CREATED="1620901944950" MODIFIED="1620901945829">
<node TEXT="SET tx_isolation=&apos;SERIALIZABLE&apos;; // 默认" ID="ID_663595104" CREATED="1620901961440" MODIFIED="1620901973794"/>
<node ID="ID_1656876371" CREATED="1620901961440" MODIFIED="1620901961440"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      SET SESSION tx_isolation='SERIALIZABLE';
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
</node>
<node TEXT="事务隔离的并发控制" FOLDED="true" ID="ID_781160669" CREATED="1619600974682" MODIFIED="1620909184645" VGAP_QUANTITY="6.8999999999999995 pt">
<node TEXT=" 必须由数据库提供一定的事务隔离机制来解决" ID="ID_383247547" CREATED="1619600932642" MODIFIED="1619600933661"/>
<node TEXT="事务隔离下处理并发的手段" ID="ID_1250604168" CREATED="1620726101582" MODIFIED="1620909184644">
<node TEXT="加普通锁，串行执行" ID="ID_1391370616" CREATED="1620726108958" MODIFIED="1620726211875">
<node TEXT=" 锁住一个资源后会禁止其他任何线程访问同一个资源" ID="ID_869344431" CREATED="1620888352261" MODIFIED="1620888353484"/>
<node TEXT="在普遍是读多写少的应用中，读读互斥很没必要" ID="ID_595821790" CREATED="1620888368661" MODIFIED="1620888409265"/>
</node>
<node TEXT=" 加读写锁，读读并发" ID="ID_1233138206" CREATED="1620726219957" MODIFIED="1620726226386">
<node TEXT="普通锁拆分成，读锁、写锁" ID="ID_1785692054" CREATED="1620888422341" MODIFIED="1620888440224"/>
<node TEXT=" 读锁和读锁之间不互斥，很大提升了系统的并发能力" ID="ID_28340016" CREATED="1620888451309" MODIFIED="1620888482215"/>
<node TEXT=" 锁和写锁、读锁都互斥" ID="ID_1950938747" CREATED="1620888455797" MODIFIED="1620888456981"/>
</node>
<node TEXT="多版本数据，读写并发" ID="ID_129181715" CREATED="1620726111126" MODIFIED="1620726234449">
<node TEXT=" 让读写之间也不冲突的方法" ID="ID_799443775" CREATED="1620888503325" MODIFIED="1620888505239"/>
<node TEXT=" 不同的事务session会看到自己特定版本的数据" ID="ID_1530698060" CREATED="1620888526438" MODIFIED="1620888527792"/>
<node TEXT=" 读取数据时通过一种类似快照的方式将数据保存下来，这样读锁就和写锁不冲突了" ID="ID_1547002740" CREATED="1620888516622" MODIFIED="1620888519299"/>
</node>
</node>
</node>
<node TEXT="事务并发的几种可能" FOLDED="true" ID="ID_330728381" CREATED="1620960926148" MODIFIED="1621048361235">
<node TEXT=" 读-读" FOLDED="true" ID="ID_349181889" CREATED="1620960936292" MODIFIED="1620960943459">
<node TEXT=" 事务不存在任何相互影响的问题" ID="ID_124431441" CREATED="1620960949532" MODIFIED="1620960974697"/>
<node TEXT=" 因此也不需要并发控制" ID="ID_258278860" CREATED="1620960974942" MODIFIED="1620960979767"/>
</node>
<node TEXT=" 读-写" ID="ID_696829355" CREATED="1620960982620" MODIFIED="1620960987140">
<node TEXT=" 有隔离性问题" ID="ID_260620630" CREATED="1620960995244" MODIFIED="1620961002329"/>
<node TEXT=" 可能遇到脏读，幻读，不可重复读" ID="ID_1534280245" CREATED="1620961002772" MODIFIED="1620961004135"/>
<node TEXT="数据库提供不同级别的隔离方案" ID="ID_608342273" CREATED="1620961049244" MODIFIED="1620961071126"/>
<node TEXT="MVCC用快照，可以读-写并发" ID="ID_717586150" CREATED="1620962122445" MODIFIED="1620962163361"/>
</node>
<node TEXT=" 写-写" ID="ID_1452639225" CREATED="1620961010157" MODIFIED="1620961011470">
<node TEXT=" 可能存更新丢失问题" ID="ID_574249572" CREATED="1620961016493" MODIFIED="1620961017648"/>
<node TEXT="需要业务层自己保证" ID="ID_248649754" CREATED="1620961018429" MODIFIED="1620961041599"/>
<node TEXT="乐观锁可以写-写并发，但只适合读多写少的场景" ID="ID_726028615" CREATED="1620962149389" MODIFIED="1620962193432"/>
<node TEXT="写多读少的场景，还是悲观锁更好" ID="ID_1329155128" CREATED="1620962219756" MODIFIED="1620962240498"/>
</node>
</node>
<node TEXT=" MVCC数据多版本并发控制" ID="ID_1613454419" CREATED="1619600961675" MODIFIED="1620911162865" VGAP_QUANTITY="6.8999999999999995 pt">
<node TEXT="概念" ID="ID_1717182967" CREATED="1620725866896" MODIFIED="1620725868747">
<node TEXT=" MultiVersion Concurrency Control，简称 MVCC 或 MCC。多版本并发控制技术" ID="ID_1571174728" CREATED="1619601030138" MODIFIED="1620909488655"/>
<node TEXT="MVCC解决读-写不阻塞的问题" ID="ID_364915597" CREATED="1620725809823" MODIFIED="1620912072977"/>
<node TEXT=" 通过一定机制生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取" ID="ID_1093181984" CREATED="1619601061281" MODIFIED="1619601062481"/>
<node TEXT="多版本并发控制（MVCC） 是行级锁的一个变种，一般不加锁，是乐观锁的体现" ID="ID_573946089" CREATED="1620910082464" MODIFIED="1621048546111"/>
<node TEXT=" 读操作只读该事务开始前的数据库的快照" ID="ID_1096449196" CREATED="1620894487489" MODIFIED="1620894489090"/>
<node TEXT=" 从用户的角度来看，好象是数据库可以提供同一数据的多个版本" ID="ID_295625765" CREATED="1619601072985" MODIFIED="1619601074332"/>
</node>
<node TEXT=" MVCC 可以解决什么问题" ID="ID_155359762" CREATED="1620909518132" MODIFIED="1620909519043">
<node TEXT="解决读-写不阻塞的问题" ID="ID_1799616326" CREATED="1620894509409" MODIFIED="1620909749893">
<node TEXT=" 读-读不阻塞，读-写不阻塞， 写不阻塞读" ID="ID_1226656754" CREATED="1620909580771" MODIFIED="1620909859087"/>
<node TEXT=" 写-写阻塞，但也只锁定必要的行" ID="ID_282702271" CREATED="1620910115912" MODIFIED="1620910138085"/>
<node TEXT="本事务写，只会阻塞其它事务写，其它事务读自己的快照" ID="ID_602649602" CREATED="1620909674619" MODIFIED="1620909714638"/>
</node>
<node TEXT="降低死锁的概率" ID="ID_1208414751" CREATED="1620910176559" MODIFIED="1620910191122">
<node TEXT=" InnoDB 的 MVCC 采用了乐观锁的方式" ID="ID_1029738434" CREATED="1620910203039" MODIFIED="1620910204163"/>
<node TEXT=" 读取数据时并不需要加锁，对于写操作，也只锁定必要的行" ID="ID_472079172" CREATED="1620910211720" MODIFIED="1620910212686"/>
</node>
<node TEXT=" 解决一致性读的问题" ID="ID_17695708" CREATED="1620910218255" MODIFIED="1620910219270">
<node TEXT=" 一致性读也被称为快照读" ID="ID_1861987614" CREATED="1620910230479" MODIFIED="1620910231689"/>
<node TEXT="本事务快照只能看到事务创建之前其它事务已提交的数据" ID="ID_1109777393" CREATED="1620910261519" MODIFIED="1620910328929"/>
<node TEXT="因为读的是快照，也避免了脏读和不可重复读" ID="ID_1296066306" CREATED="1620894633080" MODIFIED="1620894670997"/>
</node>
</node>
<node TEXT=" 事务隔离级别与MVCC" ID="ID_1162379324" CREATED="1620888980957" MODIFIED="1620889170129">
<node TEXT=" MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作" ID="ID_1100686420" CREATED="1620888988300" MODIFIED="1620888990337"/>
<node TEXT="不兼容MVCC的隔离级别" ID="ID_758255603" CREATED="1620889023597" MODIFIED="1620889205169">
<node TEXT=" READ UNCOMMITTED" ID="ID_266224718" CREATED="1620889214820" MODIFIED="1620889215698">
<node TEXT=" 读取最新的数据行, 而不是符合当前事务版本的数据行" ID="ID_1877083248" CREATED="1620889244893" MODIFIED="1620889246106"/>
</node>
<node TEXT=" SERIALIZABLE" ID="ID_685812970" CREATED="1620889219268" MODIFIED="1620889220080">
<node TEXT=" SERIALIZABLE 对所有读取的行都加锁" ID="ID_1738426585" CREATED="1620889039293" MODIFIED="1620889226560"/>
</node>
</node>
</node>
<node TEXT="InnoDB中MVCC的实现方式" ID="ID_162188861" CREATED="1620889301420" MODIFIED="1620909382339" VGAP_QUANTITY="6.8999999999999995 pt">
<node TEXT=" InnoDB中通过undo log实现了数据的多版本，而并发控制通过锁来实现" ID="ID_1236562950" CREATED="1620889346861" MODIFIED="1620909382339"/>
<node TEXT=" undo log除了实现MVCC外，还用于事务的回滚" ID="ID_1586284367" CREATED="1620889364965" MODIFIED="1620889365954"/>
</node>
<node TEXT="原理" ID="ID_1102938439" CREATED="1620725873424" MODIFIED="1620725879407">
<node TEXT="" ID="ID_857952225" CREATED="1620725969234" MODIFIED="1620725972267">
<hook URI="事务_files/png_8907720653673498133.png" SIZE="1.0" NAME="ExternalObject"/>
</node>
<node TEXT="（1）写任务发生时，将数据克隆一份，以版本号区分" ID="ID_1607585373" CREATED="1620725884143" MODIFIED="1620725896480"/>
<node TEXT=" （2）写任务操作新克隆的数据，直至提交" ID="ID_1045153518" CREATED="1620725886607" MODIFIED="1620725908069"/>
<node TEXT=" （3）并发读任务可以继续读取旧版本的数据，不至于阻塞" ID="ID_1036107961" CREATED="1620725916751" MODIFIED="1620725918483"/>
<node TEXT=" 写操作不覆盖已有数据项，而是创建一个新的版本" ID="ID_22812349" CREATED="1620960862139" MODIFIED="1620960863293"/>
<node TEXT="  为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联" ID="ID_7076370" CREATED="1620894707840" MODIFIED="1620894713586"/>
</node>
<node TEXT="事务版本号" ID="ID_404378450" CREATED="1620896880621" MODIFIED="1620896888495">
<node TEXT="概念" ID="ID_1660526012" CREATED="1620912311029" MODIFIED="1620912314520">
<node TEXT=" 一事务开启前都会从数据库获得一个自增的事务ID" ID="ID_1686412302" CREATED="1620896893974" MODIFIED="1620912269984"/>
<node TEXT=" 可以从事务ID的大小来判断事务的执行的时间顺序" ID="ID_1116664184" CREATED="1620896901430" MODIFIED="1620910855910"/>
<node TEXT=" 不显式使用 BEGIN 来开启事务时，执行的每一条语句就是一个事务" ID="ID_428076921" CREATED="1620912291238" MODIFIED="1620912309581"/>
</node>
<node TEXT=" 每一行数据中额外保存两个隐藏的列" ID="ID_424987041" CREATED="1620805396374" MODIFIED="1620805398709">
<node TEXT=" 插入这个数据行时的版本号" ID="ID_1035580550" CREATED="1620805408200" MODIFIED="1620805409007">
<node TEXT=" DB_TRX_ID" ID="ID_398533876" CREATED="1620912359726" MODIFIED="1620912361440"/>
<node TEXT="修改一条数据是标记旧数据删除，插入新一条数据" ID="ID_26646964" CREATED="1620912369324" MODIFIED="1620912409807"/>
</node>
<node TEXT=" 删除这个数据行时的版本号" ID="ID_1320491031" CREATED="1620805416054" MODIFIED="1620912429407">
<node TEXT="可能为空" ID="ID_380439525" CREATED="1620912429629" MODIFIED="1620912460402"/>
<node TEXT="是 db_roll_ptr吗? todo" ID="ID_443015744" CREATED="1620912461108" MODIFIED="1620912479793"/>
</node>
</node>
<node TEXT=" 事务在对数据修改后，进行保存时，如果数据行的当前版本号与事务开始取得数据的版本号一致就保存成功，否则保存失败" ID="ID_961372937" CREATED="1620805452438" MODIFIED="1620805456437"/>
</node>
<node TEXT="多版本的实现方法" ID="ID_502114800" CREATED="1621062023435" MODIFIED="1621062032243">
<node TEXT="" ID="ID_1195845274" CREATED="1621061857048" MODIFIED="1621061860975">
<hook URI="事务_files/png_5874577514793112094.png" SIZE="0.3106564" NAME="ExternalObject"/>
</node>
<node TEXT="隐藏列row_trx_id 记录行的最近修改事务ID" ID="ID_726582814" CREATED="1621062043196" MODIFIED="1621062102182"/>
<node TEXT="事务ID在事务开始的时候向事务系统申请，按时间先后顺序递增" ID="ID_812854418" CREATED="1621062115571" MODIFIED="1621062121574"/>
</node>
<node TEXT="行记录的隐藏列" ID="ID_1390988040" CREATED="1620895810455" MODIFIED="1620910868992">
<node TEXT="InnoDB 的叶子段存储了数据页，数据页中保存了行记录" ID="ID_1156636086" CREATED="1620911082530" MODIFIED="1620911100928"/>
<node TEXT="delete_bit" ID="ID_1567581868" CREATED="1621234769110" MODIFIED="1621234774375">
<node TEXT="删除标志，用于标识该记录是否被删除" ID="ID_1257617688" CREATED="1620906397569" MODIFIED="1621235166470"/>
<node TEXT="bool值" ID="ID_10064438" CREATED="1621235660215" MODIFIED="1621235672744"/>
<node TEXT="非cluster索引的二级索引，只有这个隐藏列" ID="ID_1178926208" CREATED="1621237031332" MODIFIED="1621237073968"/>
</node>
<node TEXT="db_row_id" ID="ID_1787553000" CREATED="1620895843214" MODIFIED="1620911033046">
<node TEXT=" DB_ROW_ID 隐藏的行 ID，用来生成默认聚簇索引" ID="ID_679532493" CREATED="1620910933163" MODIFIED="1620910973109"/>
<node TEXT="当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引" ID="ID_1985859161" CREATED="1620896980621" MODIFIED="1620910950377"/>
<node TEXT=" 采用聚簇索引的方式可以提升数据的查找效率" ID="ID_1085721162" CREATED="1620910960947" MODIFIED="1620910961881"/>
</node>
<node TEXT=" db_trx_id" ID="ID_1297717346" CREATED="1620895829432" MODIFIED="1620911028806">
<node TEXT=" DB_TRX_ID 表示最近修改的事务的id" ID="ID_550043636" CREATED="1620910985803" MODIFIED="1620911003777"/>
<node TEXT=" 在每次事务更新数据的时候,把自身的事务id赋值给当前版本的row trx_id" ID="ID_1934297540" CREATED="1620896244094" MODIFIED="1620896271113"/>
<node TEXT=" 新增一个事务时事务id会增加，trx_id能够表示事务开始的先后顺序" ID="ID_270419790" CREATED="1620895884831" MODIFIED="1620895886265"/>
<node TEXT="例子" ID="ID_634785893" CREATED="1620896331398" MODIFIED="1620896337449">
<node TEXT="" ID="ID_865638128" CREATED="1620896357720" MODIFIED="1620896360468">
<hook URI="事务_files/png_5802658053169638312.png" SIZE="0.5065147" NAME="ExternalObject"/>
</node>
<node TEXT=" 假如三个事务更新了同一行数据，那么就会有对应的三个数据版本" ID="ID_1935780597" CREATED="1620896346126" MODIFIED="1620896347225"/>
<node TEXT=" 实际上版本1、版本2并非实际物理存在的" ID="ID_1399110525" CREATED="1620896388734" MODIFIED="1620896389723"/>
<node TEXT=" 图中的U1和U2实际就是undo log" ID="ID_356049146" CREATED="1620896396590" MODIFIED="1620896398266"/>
<node TEXT=" 这v1和v2版本是根据当前v3和undo log计算出来的" ID="ID_1645723461" CREATED="1620896403326" MODIFIED="1620896404235"/>
</node>
</node>
<node TEXT=" db_roll_ptr" ID="ID_344052179" CREATED="1620895834718" MODIFIED="1620895835771">
<node TEXT="DB_ROLL_PTR 回滚指针，roll_pointer" ID="ID_1967359060" CREATED="1620906379370" MODIFIED="1621319554637"/>
<node TEXT=" 指向上一个版本数据在undo log 回滚段（rollback segment）的指针" ID="ID_519076367" CREATED="1620897010917" MODIFIED="1620912799638"/>
<node TEXT=" 该行记录上所有旧版本都可以找到，在 undo 中都通过链表的形式组织" ID="ID_1834828523" CREATED="1620912818283" MODIFIED="1620912826734"/>
</node>
</node>
<node TEXT=" 快照读" ID="ID_1207467890" CREATED="1620652074169" MODIFIED="1620652075242">
<node TEXT="概念" ID="ID_1667689844" CREATED="1620910369278" MODIFIED="1620910371897">
<node TEXT="快照读（SnapShot Read） 是一种一致性不加锁的读" ID="ID_1347589158" CREATED="1620910376439" MODIFIED="1620910453722"/>
<node TEXT="快照读不用加锁，非阻塞，性能高" ID="ID_1606549674" CREATED="1620804661749" MODIFIED="1620804689026"/>
<node TEXT="快照读是InnoDB并发如此之高的核心原因之一" ID="ID_1816805284" CREATED="1620910378990" MODIFIED="1620910392345"/>
<node TEXT=" 不加锁的简单的 SELECT 都属于快照读" ID="ID_619209818" CREATED="1620910637549" MODIFIED="1620910639106"/>
<node TEXT="快照读保证不会幻读、不会不可重复读，因为读的都是旧数据:)" ID="ID_1746508816" CREATED="1620910686517" MODIFIED="1620910748942"/>
</node>
<node TEXT="快照读取数据的范围" ID="ID_283969328" CREATED="1620910472815" MODIFIED="1620910495712">
<node TEXT=" 事务开始前就已经存在的数据" ID="ID_1794987058" CREATED="1620910503965" MODIFIED="1620910505050"/>
<node TEXT=" 事务自身插入或者修改过的数据" ID="ID_456704151" CREATED="1620910511358" MODIFIED="1620910512184"/>
</node>
<node TEXT="例子" ID="ID_285624527" CREATED="1620652214658" MODIFIED="1620652218292">
<node TEXT="表test, 字段a" ID="ID_1568954098" CREATED="1620652243945" MODIFIED="1620652254334"/>
<node TEXT="事务A" ID="ID_1284081466" CREATED="1620652218547" MODIFIED="1620652221868">
<node ID="ID_1269282000" CREATED="1620652448332" MODIFIED="1620652448332"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: JetBrains Mono,monospace; font-size: 9.8pt"><span style="color: #6a8759"><font color="#6a8759"># </font></span><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">事务</font></span><span style="color: #6a8759"><font color="#6a8759">1</font></span><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">， 只查询</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">BEGIN<br/></span><span style="color: #6a8759">SELECT a FROM test;  # a == 1<br/></span></font></pre>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="事务B" ID="ID_332751370" CREATED="1620652222035" MODIFIED="1620652225221">
<node ID="ID_1158805624" CREATED="1620652452635" MODIFIED="1620652452635"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: JetBrains Mono,monospace; font-size: 9.8pt"><span style="color: #6a8759"><font color="#6a8759"># </font></span><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">事务</font></span><span style="color: #6a8759"><font color="#6a8759">2</font></span><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">，递增字段并提交</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">BEGIN<br/></span><span style="color: #6a8759">UPDATE test SET a = a + 1<br/></span><span style="color: #6a8759">commit;<br/></span><span style="color: #6a8759"># a == 2</span></font></pre>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="两个事务并发执行" ID="ID_1821399746" CREATED="1620652489696" MODIFIED="1620652501635">
<node TEXT=" 这时候事务A，无论你怎么查，都只能查到计数值为1" ID="ID_985255233" CREATED="1620652462631" MODIFIED="1620652463488"/>
<node TEXT=" 因为InnoDB在可重复读下通过MVCC提供的视图确保了不可能发生幻读" ID="ID_699712409" CREATED="1620652464879" MODIFIED="1620652471028"/>
</node>
<node TEXT="触发当前读" ID="ID_615482960" CREATED="1620652521720" MODIFIED="1620652529884">
<node TEXT=" 如果事务A在事务B提交后执行insert、update语句，会触发一次当前读" ID="ID_159063613" CREATED="1620652535505" MODIFIED="1620652556363"/>
<node TEXT="触发了一次当前读，可获得的最新计数值是2" ID="ID_564878306" CREATED="1620652556927" MODIFIED="1620652579474"/>
<node TEXT="但后面再执行快照读，还是与之前的快照一致" ID="ID_1978319373" CREATED="1620910559397" MODIFIED="1620910602543"/>
</node>
</node>
</node>
<node TEXT=" 当前读" ID="ID_42918390" CREATED="1620652068548" MODIFIED="1620652080414">
<node TEXT=" 当前读就是读取最新数据，而不是历史版本的数据" ID="ID_82810007" CREATED="1620910773316" MODIFIED="1620910774387"/>
<node TEXT=" 加锁的 SELECT 就属于当前读" ID="ID_1295335493" CREATED="1620910780292" MODIFIED="1620910781491">
<node TEXT="SELECT IN SHARE MODE" ID="ID_326888940" CREATED="1620910782964" MODIFIED="1620910796038"/>
<node TEXT=" SELECT FOR UPDATE" ID="ID_1502733020" CREATED="1620910800660" MODIFIED="1620910806905"/>
</node>
<node TEXT=" 对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式" ID="ID_798030110" CREATED="1620804823459" MODIFIED="1620804824790"/>
<node TEXT="  没有快照，因此会有锁，会有阻塞" ID="ID_1635650347" CREATED="1621056958383" MODIFIED="1621056959794"/>
</node>
<node TEXT="InnoDB 可重复读下的MVCC" ID="ID_1285503537" CREATED="1620911159930" MODIFIED="1620911188709">
<node TEXT=" 查询（SELECT）" ID="ID_1206127509" CREATED="1620911197834" MODIFIED="1620911198756">
<node TEXT=" 根据两个条件检查每行记录，返回符合的作为结果" ID="ID_1177045227" CREATED="1620911212866" MODIFIED="1620911836004"/>
<node TEXT="过虑行的删除版本" ID="ID_334973059" CREATED="1620911520360" MODIFIED="1620911666628">
<node TEXT="收集未删除的，行的删除版本未定义" ID="ID_460895691" CREATED="1620911529041" MODIFIED="1620911582187"/>
<node TEXT="收集已删除的，行的删除版本大于当前事务版本号" ID="ID_268967764" CREATED="1620911556144" MODIFIED="1620911587121"/>
<node TEXT=" 确保事务读取到的行，在事务开始之前未被删除" ID="ID_1963942848" CREATED="1620911421633" MODIFIED="1620911422688"/>
</node>
<node TEXT="过滤行的修改版本" ID="ID_1066786250" CREATED="1620911669272" MODIFIED="1620911678780">
<node TEXT=" 收集的行，行的版本号小于或等于事务的版本号" ID="ID_655920918" CREATED="1620911232618" MODIFIED="1620911783683"/>
<node TEXT="能读的行一是事务读取的行事务开始前已经存在的" ID="ID_548330904" CREATED="1620911339346" MODIFIED="1620911386299"/>
<node TEXT="能读的行一是事务自身插入或者修改过的" ID="ID_335145495" CREATED="1620911372402" MODIFIED="1620911390932"/>
</node>
</node>
<node TEXT=" 插入（INSERT）" ID="ID_84301558" CREATED="1620911841623" MODIFIED="1620911846222">
<node TEXT=" InnoDB为新插入的每一行保存当前系统版本号作为行版本号" ID="ID_309058225" CREATED="1620911850495" MODIFIED="1620911851511"/>
<node TEXT=" 赋值db_trx_id" ID="ID_1207812220" CREATED="1621236087288" MODIFIED="1621236116442"/>
<node TEXT="db_roll_ptr为空" ID="ID_955370958" CREATED="1621236116609" MODIFIED="1621236161955"/>
</node>
<node TEXT=" 删除（DELETE）" ID="ID_1654663634" CREATED="1620911862207" MODIFIED="1620911863238">
<node TEXT=" InnoDB为删除的每一行保存当前系统版本号作为行删除标识" ID="ID_1881639733" CREATED="1620911874369" MODIFIED="1620911875717"/>
<node TEXT=" 删除在内部被视为更新" ID="ID_1060440385" CREATED="1620911884519" MODIFIED="1621234844254"/>
<node TEXT=" 更新行中的删除标识位DELELE_BIT" ID="ID_475767440" CREATED="1621234833764" MODIFIED="1621234840250"/>
</node>
<node TEXT=" 更新（UPDATE）" ID="ID_930128814" CREATED="1620911893167" MODIFIED="1620911894173">
<node TEXT="老记录" ID="ID_1478123691" CREATED="1621236252830" MODIFIED="1621236267041">
<node TEXT=" 老记录被复制到rollback segment中形成undo log" ID="ID_29051041" CREATED="1621236531634" MODIFIED="1621236533516"/>
<node TEXT=" DB_TRX_ID和DB_ROLL_PTR不动" ID="ID_363572949" CREATED="1621236401221" MODIFIED="1621236402321"/>
<node TEXT=" 删除标识位DELELE_BIT为1" ID="ID_1487517932" CREATED="1621236477187" MODIFIED="1621236489125"/>
</node>
<node TEXT="插入一行新记录" ID="ID_1437454148" CREATED="1620911908415" MODIFIED="1621236270374">
<node TEXT="DB_TRX_ID = 当前事务ID" ID="ID_62425337" CREATED="1620911913311" MODIFIED="1621236422344"/>
<node TEXT=" DB_ROLL_PTR指向老记录形成的undo log" ID="ID_135529920" CREATED="1621236428155" MODIFIED="1621236429061"/>
<node TEXT=" 新记录与undo log会组成一个链表，遍历这个链表可以看到这条记录的变迁" ID="ID_448835543" CREATED="1621236448275" MODIFIED="1621236449465"/>
</node>
<node TEXT=" 保存这两个额外系统版本号，使大多数读操作都可以不用加锁" ID="ID_1838293783" CREATED="1621045764361" MODIFIED="1621045766356"/>
<node TEXT=" 每行记录都需要额外的存储空间，需要做更多的行检查工作" ID="ID_299056870" CREATED="1621045784488" MODIFIED="1621045785769"/>
</node>
</node>
<node TEXT="read view 结构" ID="ID_959523314" CREATED="1621236615529" MODIFIED="1621236621702">
<node TEXT=" read_view中维护了系统中活跃事务集合的快照" ID="ID_882127900" CREATED="1621236622313" MODIFIED="1621236632393"/>
<node TEXT=" up_limit_id" ID="ID_595169371" CREATED="1621236634482" MODIFIED="1621236655780">
<node TEXT=" 活跃事务ID的最小值" ID="ID_1681971058" CREATED="1621236671689" MODIFIED="1621236672656"/>
<node TEXT="能够看到所有当前trx_id &lt; up_limit_id" ID="ID_1432646040" CREATED="1621236700840" MODIFIED="1621236814507"/>
</node>
<node TEXT=" low_limit_id" ID="ID_1717464321" CREATED="1621236655985" MODIFIED="1621236665796">
<node TEXT="目前已经出现过的事务ID的最大值+1" ID="ID_1193147155" CREATED="1621236674745" MODIFIED="1621318506088"/>
<node TEXT=" 当前系统尚未分配的下一个事务ID" ID="ID_1668257291" CREATED="1621318493476" MODIFIED="1621318494479"/>
<node TEXT="不能看到所有当前trx_id &gt;= low_limit_id" ID="ID_1545210472" CREATED="1621236700840" MODIFIED="1621236729827"/>
</node>
<node TEXT="SELECT操作" ID="ID_1775171712" CREATED="1621236766719" MODIFIED="1621236777715">
<node TEXT=" DB_TRX_ID &lt; up_limit_id" ID="ID_1310675697" CREATED="1621236843950" MODIFIED="1621236850200">
<node TEXT=" 此记录的最后一次修改在read_view创建之前，可见" ID="ID_1609328693" CREATED="1621236858223" MODIFIED="1621236859765"/>
</node>
<node TEXT=" DB_TRX_ID &gt;= low_limit_id" ID="ID_746664066" CREATED="1621236864552" MODIFIED="1621236873123">
<node TEXT=" 此记录的最后一次修改在read_view创建之后，不可见" ID="ID_1430807761" CREATED="1621236880784" MODIFIED="1621236881890"/>
<node TEXT="  需要用DB_ROLL_PTR查找undo log(此记录的上一次修改)，然后根据undo log的DB_TRX_ID再计算一次可见性" ID="ID_1114408453" CREATED="1621236893335" MODIFIED="1621236894414"/>
</node>
<node TEXT=" up_limit_id &lt;= DB_TRX_ID &lt;= low_limit_id" ID="ID_1234569120" CREATED="1621236903487" MODIFIED="1621236905100">
<node TEXT=" 需要进一步检查read_view中是否含有DB_TRX_ID" ID="ID_622265509" CREATED="1621236913710" MODIFIED="1621236914777"/>
</node>
</node>
<node TEXT="" ID="ID_1046514781" CREATED="1621237104158" MODIFIED="1621237104158"/>
</node>
<node TEXT=" 二级索引与MVCC" ID="ID_624070968" CREATED="1621237110996" MODIFIED="1621237111786">
<node TEXT=" MySQL的索引" ID="ID_1364916512" CREATED="1621237118677" MODIFIED="1621237128135">
<node ID="ID_776926601" CREATED="1621237135990" MODIFIED="1621237135990"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      聚簇索引(clustered index)
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_598789085" CREATED="1621237135990" MODIFIED="1621237135990"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      二级索引(secondary index)
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT=" 聚簇索引中含有DB_TRX_ID与DB_ROLL_PTR隐藏列，可以比较容易的实现MVCC" ID="ID_1673020452" CREATED="1621237152813" MODIFIED="1621237154340"/>
<node TEXT=" 二级索引只有delete bit 隐藏列" ID="ID_690711671" CREATED="1621237162803" MODIFIED="1621237176928"/>
</node>
<node TEXT="并发写的事务" ID="ID_385359304" CREATED="1621062242714" MODIFIED="1621062305768">
<node TEXT=" update时读的是当前读" ID="ID_1334585880" CREATED="1621062366210" MODIFIED="1621062367086"/>
<node TEXT="事务A先update，update会加行锁。事务B的update会被阻塞" ID="ID_1337184493" CREATED="1621062308826" MODIFIED="1621062404029"/>
<node TEXT="直到事务A提交，事务B才能继续执行" ID="ID_1684944221" CREATED="1621062575094" MODIFIED="1621062588848"/>
<node TEXT=" 如果事务A的时间太长，那么事务B很有可能出现超时异常" ID="ID_68057258" CREATED="1621062589407" MODIFIED="1621062594874"/>
<node TEXT="例子" ID="ID_1701862063" CREATED="1621063193220" MODIFIED="1621063195565">
<node TEXT="" ID="ID_1987788687" CREATED="1621062617106" MODIFIED="1621062621352">
<hook URI="事务_files/png_134939678103519408.png" SIZE="0.63172984" NAME="ExternalObject"/>
</node>
<node TEXT=" 当事务A执行update user set name=&apos;风筝2号’ where age = 10; 的时候" ID="ID_822252759" CREATED="1621063198564" MODIFIED="1621063199831"/>
<node TEXT=" 更新条件 where age = 10" ID="ID_99006186" CREATED="1621063560648" MODIFIED="1621063571357">
<node TEXT="如果age是索引列" ID="ID_6240173" CREATED="1621063521392" MODIFIED="1621063528234">
<node TEXT=" 数据库不仅在 age =10 的行上添加了行锁" ID="ID_1451282078" CREATED="1621063581727" MODIFIED="1621063582979"/>
<node TEXT=" 也在这条记录的两边，也就是(负无穷,10]、(10,30]这两个区间加了间隙锁" ID="ID_1803859437" CREATED="1621063591551" MODIFIED="1621063592623"/>
</node>
<node TEXT=" 如果 age 不是索引列，那么数据库会为整个表加上间隙锁" ID="ID_1122772046" CREATED="1621063564952" MODIFIED="1621063601755"/>
</node>
<node TEXT=" 从而导致事务B插入操作无法完成，只能等待事务A提交，这样就避免了幻读" ID="ID_1675580405" CREATED="1621063253515" MODIFIED="1621064439237"/>
<node TEXT=" 但仍可能幻读。在加锁之前就insert了新数据。 此时无法控制幻读" ID="ID_491141194" CREATED="1621064532039" MODIFIED="1621065611619"/>
</node>
</node>
</node>
</node>
<node TEXT="锁" FOLDED="true" POSITION="right" ID="ID_128098079" CREATED="1620385150653" MODIFIED="1620822897194">
<edge COLOR="#00ffff"/>
<node TEXT=" Myisam 只支持表级锁，InnerDB支持行级锁" ID="ID_481155830" CREATED="1620386873860" MODIFIED="1620386875872"/>
<node TEXT=" MySQL引擎 对事务、锁的支持" ID="ID_1606093437" CREATED="1621066256214" MODIFIED="1621066258318">
<node TEXT=" Myisam" ID="ID_910085353" CREATED="1621066263399" MODIFIED="1621066264359">
<node TEXT="不支持事务" ID="ID_534629714" CREATED="1621066300119" MODIFIED="1621066305555"/>
<node TEXT=" 只支持表级锁，不支持行级锁" ID="ID_1099733433" CREATED="1621066264895" MODIFIED="1621066297588"/>
</node>
<node TEXT=" InnerDB" ID="ID_1992145868" CREATED="1621066272383" MODIFIED="1621066274012">
<node TEXT="支持事务" ID="ID_501070612" CREATED="1621066307335" MODIFIED="1621066313476"/>
<node TEXT=" 支持表级锁、行级锁" ID="ID_445817540" CREATED="1621066281431" MODIFIED="1621066289372"/>
</node>
</node>
<node TEXT="加锁的目的" ID="ID_1013947644" CREATED="1620725548241" MODIFIED="1620906644146">
<node TEXT=" 让事务之间相互不影响" ID="ID_1460808174" CREATED="1620906659790" MODIFIED="1620906662256"/>
<node TEXT="在读取数据前，对其加锁，阻止其他事务对数据进行修改" ID="ID_901507986" CREATED="1619600949835" MODIFIED="1620725568823"/>
</node>
<node TEXT="数据库锁的实现" ID="ID_284744819" CREATED="1620906723733" MODIFIED="1620906733975">
<node TEXT=" 数据库里面的锁是基于索引实现的" ID="ID_760074816" CREATED="1620906742357" MODIFIED="1620906743893"/>
<node TEXT=" innodb索引用的数据结构是B+ tree" ID="ID_425216636" CREATED="1620906864844" MODIFIED="1620906880749"/>
<node TEXT=" 在Innodb中锁都是作用在索引上面的" ID="ID_290158929" CREATED="1620906758596" MODIFIED="1620906765887">
<node TEXT=" 当SQL操作命中索引时，那么锁住的就是命中条件内的索引节点(行锁)" ID="ID_708185404" CREATED="1620906774861" MODIFIED="1620906795848"/>
<node TEXT=" 当SQL操作没有命中索引，那锁的就是整个索引树（表锁）" ID="ID_1254452200" CREATED="1620906801875" MODIFIED="1620906833138"/>
</node>
</node>
<node TEXT="sql的显式与隐式加锁" ID="ID_409013514" CREATED="1620905957367" MODIFIED="1621066467466">
<node TEXT=" 增、删、改会默认加上排它锁" ID="ID_1689304026" CREATED="1620905981136" MODIFIED="1620906072400"/>
<node TEXT="查询加锁" ID="ID_1037495487" CREATED="1620906075445" MODIFIED="1620906079253">
<node TEXT=" 单纯只是查询并不会加锁" ID="ID_1012381541" CREATED="1620905986470" MODIFIED="1620906091406"/>
<node TEXT="查询时加共享锁" ID="ID_768083320" CREATED="1620906003958" MODIFIED="1620906013980">
<node TEXT=" select语句后显式加lock in share mode" ID="ID_1262762382" CREATED="1620906026830" MODIFIED="1620906027777"/>
</node>
<node TEXT="查询时加排它锁" ID="ID_363509752" CREATED="1620906014183" MODIFIED="1620906021313">
<node TEXT=" select语句后显式加for update" ID="ID_1323116030" CREATED="1620906026830" MODIFIED="1620906053097"/>
</node>
</node>
</node>
<node TEXT="锁的分类" FOLDED="true" ID="ID_1943076456" CREATED="1620906889011" MODIFIED="1620906897472">
<node TEXT=" 基于锁的属性分类" ID="ID_1751616923" CREATED="1620906904002" MODIFIED="1620906904980">
<node TEXT="共享锁" ID="ID_996719719" CREATED="1620906915604" MODIFIED="1620906919150"/>
<node ID="ID_98544596" CREATED="1620906915604" MODIFIED="1620906915604"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      排他锁
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT=" 基于锁的粒度分类" ID="ID_48056986" CREATED="1620906925219" MODIFIED="1620906926060">
<node ID="ID_1269835460" CREATED="1620906940699" MODIFIED="1620906940699"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      表锁
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1179502525" CREATED="1620906940699" MODIFIED="1620906940699"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      行锁
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1191089729" CREATED="1620906940702" MODIFIED="1620906940702"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      记录锁
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_230741771" CREATED="1620906940703" MODIFIED="1620906940703"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      间隙锁
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_887872261" CREATED="1620906940703" MODIFIED="1620906940703"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      临键锁
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT=" 基于锁的状态分类" ID="ID_1327541230" CREATED="1620906949723" MODIFIED="1620906950584">
<node ID="ID_758935759" CREATED="1620906962323" MODIFIED="1620906962323"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      意向共享锁
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_641580242" CREATED="1620906962323" MODIFIED="1620906962323"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      意向排它锁
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node TEXT="属性锁" FOLDED="true" ID="ID_1984861654" CREATED="1620907002337" MODIFIED="1620907543135">
<node TEXT="共享锁(Share Lock)" ID="ID_591296007" CREATED="1620644840697" MODIFIED="1620907335971">
<node TEXT="概念" ID="ID_1248349031" CREATED="1620645586559" MODIFIED="1620645592033">
<node TEXT=" 共享锁又称读锁、read lock，简称S锁" ID="ID_64545542" CREATED="1620644852233" MODIFIED="1620907043358"/>
<node TEXT=" 共享锁是读取操作创建的锁" ID="ID_92326888" CREATED="1620907043945" MODIFIED="1620907053019"/>
<node TEXT="共享锁可并发，但与其它事务的排它锁互斥" ID="ID_1244069174" CREATED="1620907221560" MODIFIED="1620907289657"/>
<node TEXT=" 一事务为数据上了共享锁，其他的事务可读不可写" ID="ID_548533763" CREATED="1620645238761" MODIFIED="1620907176780"/>
</node>
<node TEXT="效果" ID="ID_267488299" CREATED="1620645613279" MODIFIED="1620645615338">
<node TEXT=" 如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排他锁" ID="ID_130431345" CREATED="1620645230568" MODIFIED="1620645231954"/>
<node TEXT=" 加上共享锁后，对于update,insert,delete语句会自动加排它锁" ID="ID_686635882" CREATED="1620645583038" MODIFIED="1620645584933"/>
<node TEXT=" 其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据" ID="ID_1216643979" CREATED="1620645566190" MODIFIED="1620645567249"/>
</node>
<node TEXT="使用共享锁" ID="ID_186789490" CREATED="1620645687013" MODIFIED="1620645694826">
<node TEXT="行共享锁" ID="ID_1869275833" CREATED="1621048951129" MODIFIED="1621048956740">
<node TEXT=" 在查询语句后面增加 LOCK IN SHARE MODE" ID="ID_178848082" CREATED="1620645425887" MODIFIED="1620645428029"/>
<node ID="ID_1788331265" CREATED="1620645369383" MODIFIED="1620645369383"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: JetBrains Mono,monospace; font-size: 9.8pt"><span style="color: #6a8759"><font color="#6a8759">begin<br/></font></span><font color="#6a8759"><span style="color: #6a8759">SELECT * from TABLE where id = 1  lock in share mode;</span></font></pre>
  </body>
</html>
</richcontent>
</node>
<node TEXT="  Mysql会对查询结果中的每行都加共享锁" ID="ID_398671445" CREATED="1620645707038" MODIFIED="1620645708110"/>
<node TEXT=" 当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞" ID="ID_288045509" CREATED="1620645545302" MODIFIED="1620645546573"/>
</node>
<node TEXT="表共享锁" ID="ID_636804420" CREATED="1621048995448" MODIFIED="1621048999807">
<node ID="ID_1059829950" CREATED="1621049185190" MODIFIED="1621049185190"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: JetBrains Mono,monospace; font-size: 9.8pt"><span style="color: #6a8759"><font color="#6a8759">mysql> begin;<br/></font></span><font color="#6a8759"><span style="color: #6a8759">Query OK, 0 rows affected (0.00 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759"># </span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">上表共享锁</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">mysql> lock table user read;<br/></span><span style="color: #6a8759">Query OK, 0 rows affected (0.01 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759"># </span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">可读</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">mysql> select * from user;<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">| id   | name |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">|    1 | t1   |<br/></span><span style="color: #6a8759">+------+------+<br/></span><span style="color: #6a8759">1 row in set (0.03 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759"># </span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">不可写</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">mysql> insert into user values (2, "t1-2");<br/></span><span style="color: #6a8759">ERROR 1099 (HY000): Table 'user' was locked with a READ lock and can't be updated<br/></span></font></pre>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
</node>
<node TEXT="排它锁（eXclusive Lock）" ID="ID_523021388" CREATED="1620640337092" MODIFIED="1620907368712">
<node TEXT="概念" ID="ID_359655365" CREATED="1620645737214" MODIFIED="1620645739753">
<node TEXT=" 排它锁 又称writer lock、写锁，简称X锁" ID="ID_1961855124" CREATED="1620645770438" MODIFIED="1620907412951"/>
<node TEXT=" 排它锁是悲观锁的一种实现" ID="ID_260016009" CREATED="1620645778117" MODIFIED="1620645780053"/>
<node TEXT="对这行加排他锁，只有该事务对其才可读可写" ID="ID_222496558" CREATED="1620645807229" MODIFIED="1620645874193"/>
<node TEXT=" 排他锁会阻塞所有的排他锁和共享锁" ID="ID_1455447211" CREATED="1620645887095" MODIFIED="1620645894561"/>
</node>
<node TEXT="使用排它锁" ID="ID_974724247" CREATED="1620385166948" MODIFIED="1621059997811">
<node TEXT="排它锁行锁" ID="ID_1458763476" CREATED="1621059976295" MODIFIED="1621059992706">
<node TEXT=" 在需要执行的语句后面加上for update" ID="ID_1771291660" CREATED="1620645924141" MODIFIED="1620645925770"/>
<node TEXT=" select…for updateu语句，会影响到同样在同一行执行了select …for update的事务" ID="ID_1132310193" CREATED="1620385253147" MODIFIED="1620645978327"/>
<node ID="ID_712503297" CREATED="1620450050839" MODIFIED="1620450050839"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: JetBrains Mono,monospace; font-size: 9.8pt"><span style="color: #6a8759"><font color="#6a8759">//</font></span><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">开始事务</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">begin;<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">//</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">消费金额</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">$spend = 10;<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">//</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">查询用户余额</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">$user = select id,fee from `users` where id = 12 for update;<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">//</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">计算金额</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">$newFee = $user['fee']-$spend;<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">//.. </span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">这里检查余额是否足够</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759"><br/></span><span style="color: #6a8759">//</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">更新余额</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">update `users` set fee = $newFee where id = 12  ;<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">//</span></font><span style="color: #6a8759; font-family: 宋体,monospace"><font color="#6a8759" face="宋体,monospace">确认成功之后  提交事务</font></span><span style="color: #6a8759"><font color="#6a8759"><br/></font></span><font color="#6a8759"><span style="color: #6a8759">commit</span></font></pre>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="排它锁表锁" ID="ID_876951723" CREATED="1621060021686" MODIFIED="1621060033267">
<node ID="ID_65258197" CREATED="1621060114655" MODIFIED="1621060114655"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <pre style="background-color: #2b2b2b; color: #a9b7c6; font-family: JetBrains Mono,monospace; font-size: 9.8pt"><span style="color: #6a8759"><font color="#6a8759">mysql> begin;<br/></font></span><font color="#6a8759"><span style="color: #6a8759">Query OK, 0 rows affected (0.00 sec)<br/></span><span style="color: #6a8759"><br/></span><span style="color: #6a8759">mysql> lock table user write;<br/></span><span style="color: #6a8759">Query OK, 0 rows affected (0.00 sec)<br/></span></font></pre>
  </body>
</html>
</richcontent>
</node>
<node TEXT="解锁 unlock table;" ID="ID_100754031" CREATED="1621060187006" MODIFIED="1621060192459"/>
</node>
<node TEXT=" 被影响事务会进入阻塞状态，无法执行select语句，直到当前事务提交（commit）或者回滚（rollback）" ID="ID_838352300" CREATED="1620385275307" MODIFIED="1620385284992"/>
</node>
</node>
</node>
<node TEXT="粒度锁" FOLDED="true" ID="ID_684669801" CREATED="1620906925219" MODIFIED="1620907573326">
<node ID="ID_882442408" CREATED="1620906940699" MODIFIED="1620906940699"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      表锁
    </p>
  </body>
</html>
</richcontent>
<node TEXT=" 表锁是指上锁的时候锁住的是整个表" ID="ID_1224058379" CREATED="1620907583043" MODIFIED="1620907583895"/>
<node TEXT=" 当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问" ID="ID_1488093969" CREATED="1620907589243" MODIFIED="1620907590129"/>
<node TEXT=" 特点" ID="ID_52183630" CREATED="1620907594427" MODIFIED="1620907595192">
<node ID="ID_1424572698" CREATED="1620907605748" MODIFIED="1620907605748"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      粒度大
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1965010517" CREATED="1620907605748" MODIFIED="1620907605748"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      加锁简单
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT="容易冲突，从而并发度低" ID="ID_1300081831" CREATED="1620907605749" MODIFIED="1620907617511"/>
</node>
<node TEXT="语法" ID="ID_1457242997" CREATED="1621067023740" MODIFIED="1621067025564">
<node TEXT="S锁" ID="ID_474423603" CREATED="1621067042940" MODIFIED="1621067054153">
<node TEXT=" LOCK TABLES tablename READ;" ID="ID_133803898" CREATED="1621067028820" MODIFIED="1621067042017"/>
<node TEXT=" UNLOCK TABLES;" ID="ID_97046268" CREATED="1621067075165" MODIFIED="1621067076776"/>
</node>
<node TEXT="X锁" ID="ID_1364724783" CREATED="1621067054308" MODIFIED="1621067057095">
<node TEXT=" LOCK TABLES tablename WRITE;" ID="ID_200868829" CREATED="1621067025813" MODIFIED="1621067028262"/>
<node TEXT=" UNLOCK TABLES;" ID="ID_1949143114" CREATED="1621067077268" MODIFIED="1621067078780"/>
</node>
</node>
</node>
<node ID="ID_913202808" CREATED="1620906940699" MODIFIED="1620906940699"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      行锁
    </p>
  </body>
</html>
</richcontent>
<node TEXT=" 行锁是指上锁的时候锁住的是表的某一行或多行记录" ID="ID_404939654" CREATED="1620907629603" MODIFIED="1620907630372"/>
<node TEXT=" 其他事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问" ID="ID_1422357113" CREATED="1620907635378" MODIFIED="1620907636208"/>
<node TEXT=" 特点" ID="ID_833265492" CREATED="1620907594427" MODIFIED="1620907595192">
<node TEXT="粒度小" ID="ID_101696561" CREATED="1620907605748" MODIFIED="1620907649170"/>
<node TEXT="加锁比表锁麻烦" ID="ID_1922863690" CREATED="1620907605748" MODIFIED="1620907657064"/>
<node TEXT="不容易冲突，相比表锁支持的并发要高" ID="ID_246854454" CREATED="1620907605749" MODIFIED="1620907662340"/>
</node>
</node>
<node TEXT=" 记录锁(Record Locks)" ID="ID_546724671" CREATED="1620721425519" MODIFIED="1620721430587">
<node TEXT=" 记录锁也属于行锁中的一种" ID="ID_1013909922" CREATED="1620907806776" MODIFIED="1620907812900"/>
<node TEXT=" 记录锁的范围只是表中的某一条记录，根据唯一索引" ID="ID_1317605665" CREATED="1620907874769" MODIFIED="1620907901795"/>
<node TEXT=" 记录锁，它封锁索引记录。以阻止其他事务插入，更新，删除加了记录锁的行" ID="ID_1071506776" CREATED="1620725010301" MODIFIED="1620725052577"/>
<node TEXT="作用" ID="ID_523756433" CREATED="1620907963775" MODIFIED="1620907965867">
<node TEXT=" 加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题" ID="ID_1401629775" CREATED="1620907977024" MODIFIED="1620907979179"/>
<node TEXT=" 避免了在修改的事务未提交前被其他事务读取的脏读问题" ID="ID_1422156563" CREATED="1620907997440" MODIFIED="1620907998620"/>
</node>
<node TEXT="加锁例子" ID="ID_1207578363" CREATED="1620907926753" MODIFIED="1620907930804">
<node TEXT="加锁" ID="ID_661246658" CREATED="1620907950024" MODIFIED="1620907952363">
<node TEXT=" select * from t where id=1 for update;" ID="ID_1377978653" CREATED="1620724990796" MODIFIED="1620724991818"/>
<node TEXT=" update user_info set name=’张三’ where id=1" ID="ID_1490439324" CREATED="1620907937079" MODIFIED="1620907938051"/>
</node>
<node TEXT="不加锁" ID="ID_1796149801" CREATED="1620907956223" MODIFIED="1620907958354">
<node TEXT="普通select是快照读(SnapShot Read)，并不加锁" ID="ID_1908263735" CREATED="1620725074165" MODIFIED="1620725082410"/>
</node>
</node>
</node>
<node TEXT=" 间隙锁(Gap Locks)" ID="ID_328959240" CREATED="1620721430798" MODIFIED="1620721435651">
<node TEXT="概念" ID="ID_281290227" CREATED="1620908176893" MODIFIED="1620908182609">
<node TEXT=" 间隙锁属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间" ID="ID_463730969" CREATED="1620908183357" MODIFIED="1620908184543"/>
<node TEXT=" 间隙锁的主要目的，就是为了防止其他事务在间隔中插入数据，以导致“不可重复读”" ID="ID_192175013" CREATED="1620725233755" MODIFIED="1620725235079"/>
<node TEXT=" 只在RR隔离级别中，如果降级为RC，间隙锁则会自动失效" ID="ID_889576925" CREATED="1620725263437" MODIFIED="1620908337295"/>
</node>
<node TEXT="封锁范围" ID="ID_245746774" CREATED="1620725160588" MODIFIED="1620725170024">
<node TEXT=" 当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则" ID="ID_1258003897" CREATED="1620908208861" MODIFIED="1620908210099"/>
<node TEXT=" 封锁索引记录中的间隔" ID="ID_568798528" CREATED="1620725174915" MODIFIED="1620725175811"/>
<node TEXT=" 或者第一条索引记录之前的范围" ID="ID_756804393" CREATED="1620725183812" MODIFIED="1620725184535"/>
<node TEXT=" 或者最后一条索引记录之后的范围" ID="ID_1107208119" CREATED="1620725188715" MODIFIED="1620725189539"/>
<node TEXT="记录行的B+索引树是有序的，表索引被分割成几个区间" ID="ID_404925027" CREATED="1621060523877" MODIFIED="1621060585306"/>
<node TEXT="" ID="ID_1067244454" CREATED="1621060481945" MODIFIED="1621060486243">
<hook URI="事务_files/png_7395896614889362422.png" SIZE="0.47041473" NAME="ExternalObject"/>
</node>
</node>
<node TEXT="作用" ID="ID_1047398400" CREATED="1620908406924" MODIFIED="1620908409440">
<node TEXT=" 防止幻读问题" ID="ID_257132761" CREATED="1620908433555" MODIFIED="1620908434448"/>
<node TEXT="" ID="ID_247972157" CREATED="1621060621113" MODIFIED="1621060625978">
<hook URI="事务_files/png_7969555274075544866.png" SIZE="0.30852404" NAME="ExternalObject"/>
</node>
</node>
<node TEXT="例子" ID="ID_541328681" CREATED="1620725267419" MODIFIED="1620725269415">
<node TEXT=" select * from t where id between 8 and 15 for update;" ID="ID_1925675975" CREATED="1620725273764" MODIFIED="1620725281945"/>
<node TEXT=" SQL查询不到对应的记录，那么此时会使用间隙锁" ID="ID_1026924791" CREATED="1620908520739" MODIFIED="1620908521909"/>
<node TEXT=" 会封锁区间[8, 15]，以阻止其他事务id=10的记录插入" ID="ID_636837469" CREATED="1620725291636" MODIFIED="1620905906139"/>
</node>
</node>
<node TEXT=" 临键锁(Next-key Locks)" ID="ID_25549059" CREATED="1620721440062" MODIFIED="1620721441260">
<node TEXT="概念" ID="ID_838712132" CREATED="1620908680369" MODIFIED="1620908683084">
<node TEXT=" 临键锁也属于行锁的一种，并且它是INNODB的行锁默认算法" ID="ID_1463543637" CREATED="1620908544226" MODIFIED="1620908545442"/>
<node TEXT=" 加了临键锁之后，在范围区间内数据不允许被修改和插入" ID="ID_1449354737" CREATED="1620908687369" MODIFIED="1620908688868"/>
<node TEXT=" 临键锁，是记录锁与间隙锁的组合" ID="ID_122805510" CREATED="1620725308938" MODIFIED="1620725333996">
<node TEXT="封锁范围，既包含索引记录，又包含索引区间" ID="ID_847643967" CREATED="1620725334989" MODIFIED="1620725338769"/>
<node TEXT="封锁索引记录本身，以及索引记录之前的区间" ID="ID_456343850" CREATED="1620725319163" MODIFIED="1620725347344"/>
</node>
</node>
<node TEXT="如果一个会话占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录" ID="ID_1323794864" CREATED="1620725377377" MODIFIED="1620725382920"/>
<node TEXT="作用" ID="ID_70676825" CREATED="1620908623731" MODIFIED="1620908625365">
<node TEXT=" 避免了在范围查询时出现脏读、重复读、幻读问题" ID="ID_327794112" CREATED="1620908643426" MODIFIED="1620908644625"/>
<node TEXT="主要目的是为了避免幻读(Phantom Read)" ID="ID_744441361" CREATED="1620725397946" MODIFIED="1620908656493"/>
</node>
</node>
</node>
<node TEXT="状态锁" FOLDED="true" ID="ID_213598471" CREATED="1620907545316" MODIFIED="1620908742817">
<node TEXT=" 意向锁(Intention Locks)" ID="ID_784451322" CREATED="1620721413262" MODIFIED="1620721419272">
<node TEXT="概念" ID="ID_346033666" CREATED="1621233853121" MODIFIED="1621233857251">
<node TEXT=" 意向锁是一个表级别的锁(table-level locking)" ID="ID_1868728740" CREATED="1620722136243" MODIFIED="1620722139090"/>
<node TEXT=" 意向锁先提前声明一个意向，声明未来的某个时刻事务可能要加共享/排它锁了" ID="ID_1868141592" CREATED="1620722121043" MODIFIED="1620722170745"/>
<node TEXT=" 意向共享锁(intention shared lock, IS)" ID="ID_1876037632" CREATED="1620722200532" MODIFIED="1620722212048">
<node TEXT=" 事务有意向对表中的某些行加共享S锁" ID="ID_1255275640" CREATED="1620722227916" MODIFIED="1620722229029"/>
</node>
<node TEXT=" 意向排它锁(intention exclusive lock, IX)" ID="ID_850830524" CREATED="1620722219484" MODIFIED="1620722220291">
<node TEXT=" 事务有意向对表中的某些行加排它X锁" ID="ID_1223150546" CREATED="1620722235003" MODIFIED="1620722235872"/>
</node>
</node>
<node TEXT="协议" ID="ID_728447524" CREATED="1620722350083" MODIFIED="1620722352433">
<node TEXT=" 事务要获得某些行的S锁，必须先获得表的IS锁" ID="ID_1218740790" CREATED="1620722359836" MODIFIED="1620722360964"/>
<node TEXT=" 事务要获得某些行的X锁，必须先获得表的IX锁" ID="ID_1140421780" CREATED="1620722370143" MODIFIED="1620722370775"/>
<node TEXT=" 意向锁之间都相互兼容" ID="ID_420363706" CREATED="1620722407491" MODIFIED="1620722408423">
<node TEXT=" 由于意向锁仅仅表明意向，它其实是比较弱的锁，" ID="ID_795547708" CREATED="1620722326978" MODIFIED="1620722412475"/>
<node TEXT=" 意向锁之间并不相互互斥，而是可以并行" ID="ID_95984066" CREATED="1620722412978" MODIFIED="1620722414043"/>
</node>
<node TEXT="意向锁与共享锁/排它锁互斥" ID="ID_572734467" CREATED="1620722431300" MODIFIED="1620722446736">
<node TEXT=" 排它锁是很强的锁，不与其他类型的锁兼容" ID="ID_829816554" CREATED="1620722460635" MODIFIED="1620722461633"/>
<node TEXT="只有IS锁与S锁兼容，其它都相互斥" ID="ID_982806153" CREATED="1620722474962" MODIFIED="1620722497879"/>
</node>
</node>
</node>
<node TEXT=" 插入意向锁(Insert Intention Locks)" ID="ID_748756690" CREATED="1620721419757" MODIFIED="1620721425329">
<node TEXT=" 插入意向锁，是间隙锁(Gap Locks)的一种（所以也是实施在索引上的）" ID="ID_1186348292" CREATED="1620724554048" MODIFIED="1620724564605"/>
<node TEXT="插入意向锁是专门针对insert操作的" ID="ID_127465342" CREATED="1620724564862" MODIFIED="1620724570452"/>
<node TEXT=" 多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此" ID="ID_1629687877" CREATED="1620724592230" MODIFIED="1620724593923"/>
</node>
</node>
<node TEXT=" 注意点" ID="ID_1105090470" CREATED="1619603591853" MODIFIED="1619603618174">
<node TEXT="开启事务" FOLDED="true" ID="ID_828109536" CREATED="1619603670619" MODIFIED="1621233981042">
<node TEXT=" 锁表期间，开始一个新事务" ID="ID_372783811" CREATED="1619603618469" MODIFIED="1619603638111"/>
<node TEXT=" 会造成一个隐含的 unlock&#xa;tables 被执行" ID="ID_1685595384" CREATED="1619603647980" MODIFIED="1619603668689"/>
</node>
<node TEXT="结束事务" ID="ID_1215681688" CREATED="1621233981374" MODIFIED="1621233987811">
<node TEXT="在事务执行过程中，使用两阶段锁协议" ID="ID_1819330921" CREATED="1619608696895" MODIFIED="1619608766622"/>
<node TEXT=" 随时都可以执行锁定，InnoDB会根据隔离级别在需要的时候自动加锁" ID="ID_218704358" CREATED="1619608706231" MODIFIED="1619608707125"/>
<node TEXT=" 锁只有在执行commit或者rollback的时候才会释放" ID="ID_1381917563" CREATED="1619608711327" MODIFIED="1619608712185"/>
<node TEXT=" 所有的锁都是在同一时刻被释放" ID="ID_1454065209" CREATED="1619608716399" MODIFIED="1619608718264"/>
</node>
<node TEXT=" InnoDB显式锁定" ID="ID_351433075" CREATED="1619608722407" MODIFIED="1619608763037">
<node TEXT=" 存储引擎层" ID="ID_1760835996" CREATED="1619608775878" MODIFIED="1619608776642">
<node TEXT="select ... lock in share mode //共享锁&#xa;select ... for update //排他锁" ID="ID_117363525" CREATED="1619608780511" MODIFIED="1619608785368"/>
</node>
<node TEXT=" Server层" ID="ID_1080428135" CREATED="1619608792839" MODIFIED="1619608797009">
<node TEXT=" lock table和unlock table" ID="ID_515704791" CREATED="1619608801799" MODIFIED="1619608802826"/>
</node>
</node>
</node>
<node TEXT="行锁、表锁" FOLDED="true" ID="ID_1958450510" CREATED="1620385497051" MODIFIED="1620385503049">
<node TEXT=" MyISAM和MEMORY存储引擎采用的是表级锁，InnoDB默认使用行锁" ID="ID_1541454898" CREATED="1620646164756" MODIFIED="1620646210870"/>
<node TEXT="行锁" ID="ID_1089531453" CREATED="1620646356348" MODIFIED="1620646359391">
<node TEXT=" 行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁" ID="ID_1350162516" CREATED="1620646016789" MODIFIED="1620646018009"/>
<node TEXT=" 使用select…for update配合where子句可以达到行级锁的效果" ID="ID_1816566134" CREATED="1620385194884" MODIFIED="1620385195931"/>
<node TEXT="行锁的优点" ID="ID_559915781" CREATED="1620646394528" MODIFIED="1620646399824">
<node TEXT=" 开销小，加锁快" ID="ID_429034362" CREATED="1620646404853" MODIFIED="1620646405908"/>
<node TEXT=" 锁定粒度最小，发生锁冲突的概率最低，并发度最高" ID="ID_1492086255" CREATED="1620646499387" MODIFIED="1620646557544"/>
</node>
<node TEXT=" 行锁的缺点" ID="ID_152120108" CREATED="1620646087542" MODIFIED="1620646391484">
<node TEXT=" 开销大，加锁慢，需要请求大量的锁资源，内存消耗大" ID="ID_1454073350" CREATED="1620646427228" MODIFIED="1620646483695"/>
<node TEXT=" 会出现死锁" ID="ID_1587620151" CREATED="1620646445459" MODIFIED="1620646446669"/>
</node>
</node>
<node TEXT="表锁" ID="ID_1598249421" CREATED="1620646359564" MODIFIED="1620646361127">
<node TEXT=" select for update在where子句指定不明确的时候，会导致行级锁退化为表锁" ID="ID_1938444244" CREATED="1620385513132" MODIFIED="1620385514141"/>
<node TEXT="表锁的优点" ID="ID_1660648407" CREATED="1620646394528" MODIFIED="1620646415583">
<node TEXT=" 开销小，加锁快" ID="ID_456242922" CREATED="1620646404853" MODIFIED="1620646405908"/>
<node TEXT=" 不会出现死锁" ID="ID_1851546776" CREATED="1620646535515" MODIFIED="1620646536581"/>
</node>
<node TEXT="表锁的缺点" ID="ID_1612173039" CREATED="1620646537996" MODIFIED="1620646541968">
<node TEXT=" 锁定粒度大，发生锁冲突的概率最高，并发度最低" ID="ID_1282159342" CREATED="1620646549147" MODIFIED="1620646550607"/>
</node>
</node>
<node TEXT=" 页面锁" ID="ID_1853338043" CREATED="1620646569779" MODIFIED="1620646571115">
<node TEXT=" 开销和加锁时间界于表锁和行锁之间" ID="ID_1314701480" CREATED="1620646576907" MODIFIED="1620646577994"/>
<node TEXT=" 会出现死锁" ID="ID_907040583" CREATED="1620646582579" MODIFIED="1620646583456"/>
<node TEXT=" 锁定粒度界于表锁和行锁之间" ID="ID_1759063749" CREATED="1620646588156" MODIFIED="1620646589265"/>
<node TEXT=" 并发度一般" ID="ID_443918579" CREATED="1620646593869" MODIFIED="1620646595459"/>
</node>
</node>
<node TEXT="悲观锁" FOLDED="true" ID="ID_790858379" CREATED="1620385155341" MODIFIED="1620385166701">
<node TEXT="概念" FOLDED="true" ID="ID_721355048" CREATED="1620453655701" MODIFIED="1620453657882">
<node TEXT=" 悲观并发控制 Pessimistic Concurrency Control，缩写“PCC”" ID="ID_1334019013" CREATED="1620961168604" MODIFIED="1620961176735"/>
<node TEXT=" 悲观锁适合写操作多的场景，写冲突频率超高越适合" ID="ID_1729973914" CREATED="1620453875322" MODIFIED="1620962309834"/>
<node TEXT=" 需要关闭mysql数据库的默认使用autocommit模式，要搭配事务一起使用" ID="ID_1163260761" CREATED="1620640427996" MODIFIED="1620640453783"/>
<node TEXT=" 典型的，Java中的synchronized锁就是悲观锁" ID="ID_721606766" CREATED="1620453711445" MODIFIED="1620453712848"/>
</node>
<node TEXT="原理" ID="ID_242354438" CREATED="1620961254562" MODIFIED="1620961267958">
<node TEXT=" 当一个线程使用数据时，悲观锁总是认为其它线程也会过来修改这个数据" ID="ID_1852443509" CREATED="1620453671863" MODIFIED="1620453673391"/>
<node TEXT="为了保证数据安全，其采用的是一种先加锁再访问的排它策略" ID="ID_695622249" CREATED="1620453697488" MODIFIED="1620961240582"/>
<node TEXT="其它线程要想也访问该数据则被阻塞等待、直到其获取到锁才可以访问" ID="ID_738176949" CREATED="1620453705356" MODIFIED="1620453706960"/>
</node>
<node TEXT="优缺点" ID="ID_475421296" CREATED="1620961385593" MODIFIED="1620961390749">
<node TEXT="优点" ID="ID_452181818" CREATED="1620961521313" MODIFIED="1620961525548">
<node TEXT=" 适合在写多读少的并发环境中使用" ID="ID_86099751" CREATED="1620961557296" MODIFIED="1620961558820"/>
<node TEXT="在乐观锁无法提更好的性能前提下，可以做到数据的安全性" ID="ID_1751842033" CREATED="1620961536033" MODIFIED="1620961568630"/>
</node>
<node TEXT="缺点" ID="ID_293976098" CREATED="1620961517329" MODIFIED="1620961520252">
<node TEXT="不适合在读书写少的场合下使用" ID="ID_1445211572" CREATED="1620961607920" MODIFIED="1620961609117"/>
<node TEXT=" 处理加锁的机制会让数据库产生额外的开销" ID="ID_701052484" CREATED="1620961422433" MODIFIED="1620961424674"/>
<node TEXT="加锁阻塞读与写，很大程度影响并发性" ID="ID_1040178623" CREATED="1620961460561" MODIFIED="1620961597416"/>
<node TEXT=" 增加产生死锁的机会" ID="ID_1064386490" CREATED="1620961433153" MODIFIED="1620961434354"/>
</node>
</node>
</node>
<node TEXT="乐观锁" FOLDED="true" ID="ID_1233233029" CREATED="1620449651190" MODIFIED="1620449657790">
<node TEXT="概念" ID="ID_1377098057" CREATED="1620453091080" MODIFIED="1620453093308">
<node TEXT=" 乐观并发控制 Optimistic Concurrency Control，缩写“OCC”" ID="ID_1857337006" CREATED="1620961642351" MODIFIED="1620961651502"/>
<node TEXT=" 解决的是数据库并发场景下的写-写冲突，指在用无锁的方式去解决" ID="ID_770600762" CREATED="1620961830302" MODIFIED="1620961831491"/>
<node TEXT=" 乐观锁认为在使用数据的过程中其它线程不会修改这个数据，故不加锁直接访问" ID="ID_1156115733" CREATED="1620453736431" MODIFIED="1620453757664"/>
<node TEXT=" 乐观锁不是一把锁" ID="ID_583480237" CREATED="1620961742662" MODIFIED="1620961743916"/>
<node TEXT="数据库乐观锁可以认为是 version字段" ID="ID_1327832117" CREATED="1620453033504" MODIFIED="1620453090139"/>
</node>
<node TEXT=" 乐观锁是用来解决写-写冲突的无锁并发控制" ID="ID_1012715301" CREATED="1620892811814" MODIFIED="1620893487716">
<node TEXT=" 乐观锁是一种思想，即认为读多写少，遇到并发写的可能性比较低，所以先进行修改" ID="ID_394134067" CREATED="1620453134335" MODIFIED="1620893745199"/>
<node TEXT=" 在提交事务前，检查一下事务开始后，有没有新提交改变，如果没有就提交，如果有就放弃并重试。" ID="ID_995578736" CREATED="1620893574332" MODIFIED="1620893581656"/>
<node TEXT=" 乐观锁的失败重试类似自旋锁" ID="ID_1574712733" CREATED="1620893697346" MODIFIED="1620893960101"/>
</node>
<node TEXT="大概流程" ID="ID_849507799" CREATED="1620453169576" MODIFIED="1620453175599">
<node TEXT=" 在写时先读出当前版本号" ID="ID_1418665394" CREATED="1620453188711" MODIFIED="1620453203340"/>
<node TEXT=" 然后加锁操作，比较跟上一次的版本号，如果一样则更新" ID="ID_836599081" CREATED="1620453204135" MODIFIED="1620453218404"/>
<node TEXT="如果别人修改了数据则放弃操作，然后重复读-比较-写的操作" ID="ID_873253116" CREATED="1620453225752" MODIFIED="1620454400133"/>
<node TEXT=" 因为业务层实现，因此自旋次数也可因需决定" ID="ID_1737842725" CREATED="1620961973398" MODIFIED="1620962009905"/>
</node>
<node TEXT="优缺点" FOLDED="true" ID="ID_990996362" CREATED="1620961962581" MODIFIED="1620961971585">
<node TEXT="优点" ID="ID_669673968" CREATED="1620962023798" MODIFIED="1620962025881">
<node TEXT=" 在读多写少的并发场景下，可以避免数据库加锁的开销，提高Dao层的响应性能" ID="ID_1323564541" CREATED="1620962036813" MODIFIED="1620962042683"/>
</node>
<node TEXT="缺点" ID="ID_818535775" CREATED="1620962064821" MODIFIED="1620962067385">
<node TEXT=" 在写操作竞争激烈的情况下，会导致多次重试，开锁比悲观锁更高" ID="ID_632517499" CREATED="1620962067645" MODIFIED="1620962088153"/>
<node TEXT="如果重试过程的代码执行很耗时，不如用悲观锁" ID="ID_1232017437" CREATED="1620962321733" MODIFIED="1620962351351"/>
</node>
</node>
<node TEXT=" CAS 业务层面乐观锁" ID="ID_17221125" CREATED="1620449802625" MODIFIED="1620449803834">
<node TEXT=" 什么是 CAS" ID="ID_1872036781" CREATED="1620450895327" MODIFIED="1620450897022">
<node TEXT=" CAS(compare and swap) 比较并替换，比较和替换是线程并发算法时用到的一种技术" ID="ID_572350022" CREATED="1620451460607" MODIFIED="1620451461652"/>
<node TEXT=" CAS是原子操作，保证并发安全，而不是保证并发同步" ID="ID_1967412135" CREATED="1620451473992" MODIFIED="1620451475632"/>
<node TEXT=" CAS是非阻塞的、轻量级的乐观锁，通过CPU指令实现" ID="ID_1989376827" CREATED="1620451482278" MODIFIED="1620452780936"/>
<node TEXT=" CAS是乐观锁写那一步操作的一种实现方式" ID="ID_507356472" CREATED="1620453434425" MODIFIED="1620453442763"/>
</node>
<node TEXT=" 为什么说CAS是乐观锁" ID="ID_1901490112" CREATED="1620452505577" MODIFIED="1620452506793">
<node TEXT=" 乐观锁，严格来说并不是锁，通过原子性来保证数据的同步" ID="ID_1943926926" CREATED="1620452517458" MODIFIED="1620452558045"/>
<node TEXT=" 比如说数据库的乐观锁，通过版本控制来实现等" ID="ID_1279899092" CREATED="1620452547625" MODIFIED="1620452549019"/>
<node TEXT=" CAS不会保证线程同步。乐观的认为在数据更新期间没有其他线程影响" ID="ID_1119478508" CREATED="1620452572953" MODIFIED="1620452574505"/>
</node>
<node TEXT=" CAS原理" ID="ID_1972028114" CREATED="1620452581266" MODIFIED="1620452582714">
<node TEXT="  算法" ID="ID_966289938" CREATED="1621233239304" MODIFIED="1621233240438">
<node TEXT="3个操作数" ID="ID_1360562758" CREATED="1620453979129" MODIFIED="1621233243085">
<node ID="ID_1172405126" CREATED="1621233208440" MODIFIED="1621233208440"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      变量当前内存值V
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_50576240" CREATED="1621233208440" MODIFIED="1621233208440"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      变量的预期值E
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1417547001" CREATED="1621233208442" MODIFIED="1621233208442"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      新值U
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="修改时，V==E，则可以修改内存值为U" ID="ID_255317530" CREATED="1621233266975" MODIFIED="1621233365831"/>
<node TEXT="修改时，V!=E，则放弃修改" ID="ID_1080353123" CREATED="1621233323303" MODIFIED="1621233345694"/>
</node>
<node TEXT="在更新时，只有在初始值没有改变才允许更新成功" ID="ID_1158421841" CREATED="1620450914295" MODIFIED="1620450945457"/>
<node TEXT=" 如果发生事务同时修改产生并发 将只有一边修改成功" ID="ID_340301277" CREATED="1620449902432" MODIFIED="1620449938089"/>
</node>
<node TEXT=" CAS优缺点" ID="ID_362414043" CREATED="1620452733760" MODIFIED="1620452734701">
<node TEXT=" 优点" ID="ID_1742285756" CREATED="1620452738474" MODIFIED="1620452739320">
<node TEXT=" 在资源竞争不激烈的情况下性能高" ID="ID_182176557" CREATED="1620452794280" MODIFIED="1620452795517"/>
<node TEXT=" 相比synchronized重量锁，synchronized会进行比较复杂的加锁，解锁和唤醒操作" ID="ID_1051706948" CREATED="1620452817048" MODIFIED="1620452818798"/>
</node>
<node TEXT="缺点" ID="ID_692803607" CREATED="1620452814673" MODIFIED="1620452878795">
<node TEXT=" 未解决ABA问题" ID="ID_1091069092" CREATED="1620452858168" MODIFIED="1620452949548">
<node TEXT=" 线程D将A修改为B后又修改为A，此时C线程以为A没有改变过" ID="ID_1702605996" CREATED="1620452905528" MODIFIED="1620452917204"/>
<node TEXT=" java的原子类AtomicStampedReference，通过控制变量值的版本来保证CAS的正确性" ID="ID_1836512789" CREATED="1620452935280" MODIFIED="1620452936304"/>
<node TEXT="加version解决ABA问题" ID="ID_1036359733" CREATED="1620453493823" MODIFIED="1620453514579"/>
</node>
<node TEXT=" CPU开销" ID="ID_568790734" CREATED="1620454256215" MODIFIED="1620454257343">
<node TEXT=" 如果CAS操作一直不成功不断循环，将会大大浪费CPU资源" ID="ID_918501176" CREATED="1620454201768" MODIFIED="1620454203657"/>
<node TEXT=" 引入退出机制，如重试次数超过一定阈值后失败退出" ID="ID_957278789" CREATED="1620454687752" MODIFIED="1620454691004"/>
</node>
<node TEXT=" 只能保证一个变量的原子性" ID="ID_1702936333" CREATED="1620454238359" MODIFIED="1620454240021">
<node TEXT=" 当对多个变量进行操作时，CAS算法无法保证原子性" ID="ID_1532179186" CREATED="1620454248599" MODIFIED="1620454249868"/>
<node TEXT=" Java提供了一个AtomicReference类，可以通过组合的方式将多个变量封装为一个对象再使用CAS算法" ID="ID_1918137065" CREATED="1620454272576" MODIFIED="1620454273546"/>
</node>
</node>
</node>
</node>
</node>
<node TEXT="死锁（Deadlock）" ID="ID_258135013" CREATED="1620647204550" MODIFIED="1620647251015">
<node TEXT="概念" ID="ID_1479938518" CREATED="1620647239293" MODIFIED="1620647241619">
<node TEXT=" 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去" ID="ID_235002950" CREATED="1620647236526" MODIFIED="1620647237711"/>
<node TEXT=" 这些永远在互相等待的进程称为死锁进程" ID="ID_807399104" CREATED="1620647271646" MODIFIED="1620647272699"/>
</node>
<node TEXT="产生死锁的4个必要条件" ID="ID_1971960411" CREATED="1620647601899" MODIFIED="1620647616030">
<node TEXT=" 互斥条件：一个资源每次只能被一个进程使用" ID="ID_1454931690" CREATED="1620647616540" MODIFIED="1620647627203"/>
<node TEXT=" 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。" ID="ID_1449948835" CREATED="1620647627683" MODIFIED="1620647639178"/>
<node TEXT=" 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。" ID="ID_292222790" CREATED="1620647639858" MODIFIED="1620647648390"/>
<node TEXT=" 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系" ID="ID_1937765993" CREATED="1620647654298" MODIFIED="1620647655578"/>
</node>
<node TEXT=" 解除正在死锁的方法" ID="ID_777263622" CREATED="1620647370653" MODIFIED="1620647452441">
<node TEXT="1：查看当前的事务" ID="ID_1875253677" CREATED="1620647547467" MODIFIED="1620647554313">
<node TEXT=" SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;" ID="ID_920617773" CREATED="1620647557779" MODIFIED="1620647560400"/>
</node>
<node TEXT=" 2：查看当前锁定的事务" ID="ID_1959442138" CREATED="1620647563947" MODIFIED="1620647568663">
<node TEXT=" SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;" ID="ID_522623523" CREATED="1620647571723" MODIFIED="1620647572781"/>
</node>
<node TEXT=" 3：查看当前等锁的事务" ID="ID_1110201025" CREATED="1620647587403" MODIFIED="1620647592272">
<node TEXT=" SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;" ID="ID_1548483566" CREATED="1620647592667" MODIFIED="1620647593524"/>
</node>
<node TEXT=" 杀死锁进程" ID="ID_1533281543" CREATED="1620647383853" MODIFIED="1620647515776"/>
</node>
<node TEXT=" 降低死锁的方法" ID="ID_620581666" CREATED="1620647668756" MODIFIED="1620647671294">
<node TEXT="按同一顺序访问对象，以固定的顺序访问表和行" ID="ID_645011038" CREATED="1620647692815" MODIFIED="1621065902835"/>
<node TEXT="避免事务中的用户交互。" ID="ID_1026109435" CREATED="1620647692815" MODIFIED="1621065901415"/>
<node TEXT="保持事务简短并在一个批处理中。" ID="ID_1614898323" CREATED="1620647692815" MODIFIED="1621065899536"/>
<node TEXT="使用低隔离级别。将隔离级别从RR调整为RC，可以避免掉很多因为gap锁造成的死锁" ID="ID_167995686" CREATED="1620647692816" MODIFIED="1621065896682"/>
<node TEXT=" 大事务更倾向于死锁，如果业务允许，将大事务拆小" ID="ID_1164249917" CREATED="1621065849008" MODIFIED="1621065852856"/>
<node TEXT=" 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁概率" ID="ID_1893747641" CREATED="1621065861720" MODIFIED="1621065870047"/>
</node>
<node TEXT="InnoDB 参数" ID="ID_1972349116" CREATED="1621071778068" MODIFIED="1621234336784">
<node TEXT="最大写锁数" ID="ID_1513670083" CREATED="1621234269070" MODIFIED="1621234272938">
<node TEXT=" max_write_lock_count" ID="ID_1501191391" CREATED="1621071780253" MODIFIED="1621072131208"/>
</node>
<node TEXT=" 锁等待超时参数" ID="ID_293454900" CREATED="1621072126554" MODIFIED="1621072127185">
<node TEXT=" innodb_lock_wait_timeout" ID="ID_1962184475" CREATED="1621072155226" MODIFIED="1621072156724"/>
</node>
<node TEXT="死锁检测" ID="ID_40854699" CREATED="1621072188331" MODIFIED="1621072197871">
<node TEXT=" innodb_deadlock_detect" ID="ID_452263238" CREATED="1621072199058" MODIFIED="1621072200211"/>
</node>
</node>
</node>
<node TEXT="普通锁" ID="ID_358279133" CREATED="1620725597145" MODIFIED="1620725600549">
<node TEXT="协议" ID="ID_872645388" CREATED="1620725618897" MODIFIED="1620725620789">
<node TEXT="操作数据前，锁住，实施互斥，不允许其他的并发任务操作" ID="ID_1960354467" CREATED="1620725600753" MODIFIED="1620725611578"/>
<node TEXT=" 操作完成后，释放锁，让其他任务执行" ID="ID_803901423" CREATED="1620725616001" MODIFIED="1620725618521"/>
</node>
<node TEXT=" 缺点" ID="ID_393904434" CREATED="1620725624616" MODIFIED="1620725631381">
<node TEXT=" 太过粗暴，连“读任务”也无法并行" ID="ID_26011092" CREATED="1620725642496" MODIFIED="1620725652711"/>
<node TEXT=" 任务执行过程本质上是串行的" ID="ID_598914898" CREATED="1620725652920" MODIFIED="1620725654282"/>
</node>
<node TEXT="分化出现了共享锁与排他锁，可以实现读读并发" ID="ID_1857102151" CREATED="1620725671137" MODIFIED="1620726176354"/>
</node>
<node TEXT=" InnoDB七种类型锁" ID="ID_1256917181" CREATED="1620721394863" MODIFIED="1620721401403">
<node TEXT=" 自增锁(Auto-inc Locks)" ID="ID_1230661430" CREATED="1620721405662" MODIFIED="1620721407216">
<node TEXT=" 自增锁是一种特殊的表级别锁（table-level lock）" ID="ID_1146399169" CREATED="1620721637309" MODIFIED="1620721638314"/>
<node TEXT="自增锁专门针对事务插入AUTO_INCREMENT类型的列" ID="ID_1084410489" CREATED="1620721645965" MODIFIED="1620721662467"/>
<node TEXT=" 如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值" ID="ID_99850314" CREATED="1620721678541" MODIFIED="1620721679715"/>
<node TEXT=" InnoDB提供了innodb_autoinc_lock_mode配置，可以调节与改变该锁的模式与行为" ID="ID_704654933" CREATED="1620721778172" MODIFIED="1620721779024"/>
</node>
<node TEXT=" 共享/排它锁(Shared and Exclusive Locks)" ID="ID_922473044" CREATED="1620721407430" MODIFIED="1620721413113">
<node TEXT="读锁共享" ID="ID_174399743" CREATED="1620722059708" MODIFIED="1620722075545">
<node TEXT=" 事务拿到某一行记录的共享S锁，才可以读取这一行" ID="ID_721518412" CREATED="1620721943972" MODIFIED="1620721945052"/>
<node TEXT=" 多个事务可以拿到一把S锁，读读可以并行" ID="ID_926982296" CREATED="1620721966501" MODIFIED="1620721969214"/>
</node>
<node TEXT="写锁排它" ID="ID_388954677" CREATED="1620722075691" MODIFIED="1620722081640">
<node TEXT=" 事务拿到某一行记录的排它X锁，才可以修改或者删除这一行" ID="ID_871315485" CREATED="1620721955029" MODIFIED="1620721956748"/>
<node TEXT=" 而只有一个事务可以拿到X锁，写写/读写必须互斥" ID="ID_1035044263" CREATED="1620721976692" MODIFIED="1620721977574"/>
</node>
<node TEXT="潜在问题" ID="ID_309338401" CREATED="1620722001781" MODIFIED="1620722023807">
<node TEXT=" 共享/排它锁的潜在问题是，不能充分的并行" ID="ID_593895443" CREATED="1620722007507" MODIFIED="1620722015720"/>
<node TEXT=" 解决思路是数据多版本" ID="ID_1870834630" CREATED="1620722015957" MODIFIED="1620722017318"/>
</node>
</node>
</node>
</node>
<node TEXT="redo undo" POSITION="right" ID="ID_1602277559" CREATED="1619506383693" MODIFIED="1619506389690">
<edge COLOR="#7c7c00"/>
<node TEXT=" 数据库通常借助日志来实现事务，这里主要是原子性和持久性。还可用于数据恢复" ID="ID_39422470" CREATED="1619508075691" MODIFIED="1619599044934"/>
<node TEXT="数据库语句操作" ID="ID_1189164306" CREATED="1619599182911" MODIFIED="1619599217186">
<node TEXT=" 当执行 Insert、Update、Delete 动作时数据库不会真的去数据文件中执行 I/O 操作" ID="ID_188220250" CREATED="1619599225943" MODIFIED="1619599227099"/>
<node TEXT="改内存值、记log" ID="ID_117893794" CREATED="1619599233472" MODIFIED="1619599269121">
<node TEXT=" 修改内存中的数据(数据库称为 Buffer)" ID="ID_276358573" CREATED="1619599273390" MODIFIED="1619599274469">
<node TEXT=" 读写数据文件是一次随机 I/O 会降低系统性能" ID="ID_758221328" CREATED="1619599468062" MODIFIED="1619599469305"/>
<node TEXT=" 随机I/O需要在磁盘的多个地方移动磁头" ID="ID_1431658238" CREATED="1619603121031" MODIFIED="1619603122640"/>
<node TEXT=" 只有当 Buffer 达到刷新条件(比如脏数据达到一定比例)才会对数据文件进行操作" ID="ID_694416360" CREATED="1619599450823" MODIFIED="1619599451916"/>
</node>
<node TEXT=" 记录 Redo Undo 日志" ID="ID_1791333689" CREATED="1619599277839" MODIFIED="1619599278890">
<node TEXT=" Redo Undo 也会写文件，但它是顺序写入，性能比较高" ID="ID_586463711" CREATED="1619599478390" MODIFIED="1619599480632"/>
<node TEXT=" 顺序写入一般采用 LSM (Log Structured Merge Trees)算法，比如 Kafka，HBase、LevelDB 都采用这种结构" ID="ID_1140602721" CREATED="1619599497238" MODIFIED="1619599498288"/>
</node>
</node>
</node>
<node TEXT="恢复操作" ID="ID_742671225" CREATED="1619599523638" MODIFIED="1619599533152">
<node TEXT=" 从前向后读取 Redo，重做所有已提交的事务" ID="ID_1068612789" CREATED="1619599539853" MODIFIED="1619599540868"/>
<node TEXT=" 从后往前读取 Undo，回滚未提交的事务" ID="ID_1143909490" CREATED="1619599550149" MODIFIED="1619599551475"/>
</node>
<node TEXT="只用undo log实现原子性、持久性，不用redo log" ID="ID_1552575208" CREATED="1619507346717" MODIFIED="1619507380901">
<node TEXT="IO较多" ID="ID_205512523" CREATED="1619507593318" MODIFIED="1619507608486">
<node TEXT=" 事务提交前需要将 Undo Log 写磁盘（提供可回滚功能，保证原子性），多次磁盘IO" ID="ID_1796195324" CREATED="1619507414267" MODIFIED="1619507511292"/>
<node TEXT="事务提交后需要将数据立即更新到数据库中,至少一次磁盘随机IO" ID="ID_1697276088" CREATED="1619507407683" MODIFIED="1619507643879"/>
</node>
<node TEXT="用redo log" ID="ID_397071125" CREATED="1619507612421" MODIFIED="1619507623503">
<node TEXT=" 事务提交后如果能够将数据缓存一段时间，而不是立即更新到数据库" ID="ID_1485988471" CREATED="1619507669044" MODIFIED="1619507670254"/>
<node TEXT="将一次次的随机 IO 打包变成一次 IO" ID="ID_1988973276" CREATED="1619507623853" MODIFIED="1619507661185"/>
<node TEXT=" 在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化" ID="ID_1123222964" CREATED="1619507710595" MODIFIED="1619507711584"/>
</node>
</node>
</node>
<node TEXT="如何保证事务的持久性" POSITION="right" ID="ID_1086741424" CREATED="1621323257925" MODIFIED="1621323304173">
<edge COLOR="#0000ff"/>
<node TEXT=" InnoDB 通过force log at commit机制实现事务的持久性" ID="ID_1072234137" CREATED="1621323282228" MODIFIED="1621323283409"/>
<node TEXT=" 即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的redo log file和undo log file中进行持久化" ID="ID_950589549" CREATED="1621323296332" MODIFIED="1621323297820"/>
</node>
<node TEXT="redo log" POSITION="right" ID="ID_997825636" CREATED="1621320397661" MODIFIED="1621320400770">
<edge COLOR="#7c007c"/>
<node TEXT="概念" ID="ID_1920994868" CREATED="1621320549221" MODIFIED="1621320551457">
<node TEXT=" 重做日志（redo log）用于保证事务持久性" ID="ID_1937951261" CREATED="1621320407732" MODIFIED="1621320660189"/>
<node TEXT="  redo log记录了数据操作在物理层面的修改，修改了数据块那么就会记录redo信息" ID="ID_985224004" CREATED="1621320703898" MODIFIED="1621320721768"/>
<node TEXT=" 具体来说就是只记录事务对数据页做了哪些修改，先顺序io记下日志" ID="ID_1310816289" CREATED="1622635433474" MODIFIED="1622702110484"/>
</node>
<node TEXT="作用" ID="ID_188796524" CREATED="1621320474133" MODIFIED="1621320477480">
<node TEXT="提供前滚操作" ID="ID_1845391296" CREATED="1621320593557" MODIFIED="1621320605360"/>
<node TEXT=" 确保事务的持久性" ID="ID_1066562173" CREATED="1621320477757" MODIFIED="1621320478519">
<node TEXT=" 防止在发生故障的时间点，尚有脏页未写入磁盘" ID="ID_1461336365" CREATED="1621320493228" MODIFIED="1621320494300"/>
<node TEXT="宕机未写入磁盘的数据，会在重启时，根据redo log进行重做。如果redo log中有事务提交，则进行事务提交修改数据" ID="ID_229687048" CREATED="1621320505132" MODIFIED="1621320877333"/>
</node>
</node>
<node TEXT=" 修改的数据块包括" ID="ID_1854063914" CREATED="1619506507155" MODIFIED="1619506508204">
<node ID="ID_163763439" CREATED="1619506526341" MODIFIED="1619506526341"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      表所在数据块（表数据块）
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1332244065" CREATED="1619506526341" MODIFIED="1619506526341"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      索引所在数据块（索引数据块）
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1358964249" CREATED="1619506526342" MODIFIED="1619506526342"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      以及undo段所在数据块（undo数据块）
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT=" mini-transaction" FOLDED="true" ID="ID_1253185560" CREATED="1622701916897" MODIFIED="1622701918263">
<node TEXT="概念" ID="ID_512802507" CREATED="1622701939440" MODIFIED="1622701943615">
<node TEXT=" mini-transaction是一种InnoDB内部使用的机制" ID="ID_450171492" CREATED="1622701927808" MODIFIED="1622701929871"/>
<node TEXT=" 通过mini-transaction来保证并发事务操作下以及数据库异常时数据页中数据的一致性，但它不属于事务" ID="ID_756567099" CREATED="1622701930072" MODIFIED="1622701939013"/>
</node>
<node TEXT=" 遵循三种协议" ID="ID_320337727" CREATED="1622701947418" MODIFIED="1622701964996">
<node TEXT="The FIX Rules" ID="ID_1464491034" CREATED="1622701979021" MODIFIED="1622701983069">
<node TEXT=" 修改一个数据页时需要获得该页的x-latch(排他锁)" ID="ID_1504188316" CREATED="1622701999720" MODIFIED="1622702000946"/>
<node TEXT=" 获取一个数据页时需要该页的s-latch(读锁或者称为共享锁) 或者是 x-latch" ID="ID_1925779749" CREATED="1622702018608" MODIFIED="1622702019770"/>
<node TEXT=" 持有该页的锁直到修改或访问该页的操作完成" ID="ID_1921191181" CREATED="1622702025930" MODIFIED="1622702027320"/>
</node>
<node ID="ID_541654678" CREATED="1622701979022" MODIFIED="1622701979022"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Write-Ahead Log
    </p>
  </body>
</html>
</richcontent>
<node TEXT=" 预先写日志。在持久化一个数据页之前，必须先将内存中相应的日志页持久化" ID="ID_833857443" CREATED="1622702041232" MODIFIED="1622702050591"/>
<node TEXT=" 每个页都有一个LSN(log sequence number)，代表日志序列号，（LSN占用8字节，单调递增)" ID="ID_502672752" CREATED="1622702061225" MODIFIED="1622702062487"/>
<node TEXT=" 当一个数据页需要写入到持久化设备之前，要求内存中小于该页LSN的日志先写入持久化设备" ID="ID_1615609703" CREATED="1622702073848" MODIFIED="1622702077759"/>
</node>
<node TEXT=" Force Log at Commit 机制" ID="ID_176212759" CREATED="1622701703319" MODIFIED="1622701704707">
<node TEXT=" Force Log at Commit 机制实现事务的持久性" ID="ID_835652581" CREATED="1622701712883" MODIFIED="1622701714080"/>
<node TEXT=" 当事务提交时，先将 redo log buffer 写入到 redo log file 进行持久化，待事务的commit操作完成时才算完成" ID="ID_1106654374" CREATED="1622701728537" MODIFIED="1622701729902"/>
<node TEXT=" 也被称为 Write-Ahead Log(预先日志持久化)" ID="ID_1667622172" CREATED="1622701746465" MODIFIED="1622701756824"/>
</node>
</node>
</node>
<node TEXT="组成" ID="ID_1710846109" CREATED="1621323177837" MODIFIED="1621323181177">
<node TEXT=" redo log buffer" ID="ID_201252402" CREATED="1621323190847" MODIFIED="1621323191890">
<node TEXT=" 内存中的日志缓冲，是易失性的" ID="ID_1887975050" CREATED="1621323201942" MODIFIED="1621323217896"/>
</node>
<node TEXT=" redo log file" ID="ID_1940539239" CREATED="1621323196389" MODIFIED="1621323197410">
<node TEXT=" 磁盘上的重做日志文件，持久的" ID="ID_1922756578" CREATED="1621323225597" MODIFIED="1621323231321"/>
<node TEXT="文件位置" ID="ID_1236422701" CREATED="1621321348143" MODIFIED="1621321352882">
<node TEXT=" MySQL\MySQL Server 8.0\Data\" ID="ID_1040217836" CREATED="1621322045793" MODIFIED="1621322127346"/>
<node TEXT="ib_logfile1文件" ID="ID_1311159352" CREATED="1621322120129" MODIFIED="1621322132753"/>
<node TEXT="ib_logfile2文件" ID="ID_1714002709" CREATED="1621322120130" MODIFIED="1621322137265"/>
</node>
</node>
<node TEXT="  先写日志，再写磁盘" ID="ID_1850177720" CREATED="1622635546658" MODIFIED="1622635547753">
<node TEXT="  MySQL的WAL(Write-Ahead Logging) 技术" ID="ID_413134897" CREATED="1622635558234" MODIFIED="1622635587083"/>
<node TEXT=" mysql 每执行一条 DML 语句，先将记录写入 redo log buffer ，后续某个时间点再一次性将多个操作记录写到 redo log file" ID="ID_249439961" CREATED="1622635526034" MODIFIED="1622635533623"/>
</node>
</node>
<node TEXT="过程" ID="ID_1038809764" CREATED="1621321034973" MODIFIED="1621321037455">
<node TEXT="事务在执行中就会写redo log，而不是在事务提交后" ID="ID_308613936" CREATED="1621320994871" MODIFIED="1621321016248"/>
<node TEXT="默认事务提交时将重做日志缓存刷新到重做日志文件" ID="ID_1543788471" CREATED="1621321882730" MODIFIED="1621323747766"/>
<node TEXT=" 当对应事务的脏页写入到磁盘之后，相关的redo log就可被清掉" ID="ID_764200733" CREATED="1621321040877" MODIFIED="1621321069751"/>
</node>
<node TEXT="重做日志缓存刷新到重做日志文件" ID="ID_335297687" CREATED="1621425635187" MODIFIED="1621425742681" VGAP_QUANTITY="6.8999999999999995 pt">
<node TEXT=" innodb_flush_log_at_timeout 刷日志的频率" ID="ID_732545971" CREATED="1621425926202" MODIFIED="1621425947812"/>
<node TEXT="" ID="ID_1311074057" CREATED="1621425875115" MODIFIED="1621425878818">
<hook URI="事务_files/png_4655205674052193788.png" SIZE="0.41287997" NAME="ExternalObject"/>
</node>
<node TEXT="参数" ID="ID_1277284638" CREATED="1621425887288" MODIFIED="1621425890412">
<node TEXT=" innodb_flush_log_at_trx_commit决定3种时机" ID="ID_259963540" CREATED="1621425660728" MODIFIED="1621425676401"/>
<node TEXT=" 0" ID="ID_548226520" CREATED="1621425680791" MODIFIED="1621425753588">
<node TEXT=" 每秒写入os buffer并调用fsync()写入到log file on disk中" ID="ID_881507792" CREATED="1621425811143" MODIFIED="1621425814763"/>
<node TEXT=" 系统崩溃，会丢失 1 秒钟的数据" ID="ID_1357294302" CREATED="1621425822678" MODIFIED="1621425824026"/>
</node>
<node TEXT=" 1" ID="ID_940597575" CREATED="1621425676743" MODIFIED="1621425788304">
<node TEXT=" 默认模式，事务提交时写入" ID="ID_686582704" CREATED="1621425789726" MODIFIED="1621425791034"/>
<node TEXT=" 将log buffer中的日志写入os buffer并调用fsync()刷到log file on disk中" ID="ID_658982422" CREATED="1621425783319" MODIFIED="1621425784970"/>
<node TEXT="性能较0、2 差" ID="ID_1526079381" CREATED="1621426039630" MODIFIED="1621426056245"/>
</node>
<node TEXT=" 2" ID="ID_895096480" CREATED="1621425681784" MODIFIED="1621425757819">
<node TEXT=" 每次提交都仅写入到os buffer，os buffer 在内存中" ID="ID_743313153" CREATED="1621425844616" MODIFIED="1621426021813"/>
<node TEXT=" 每秒调用fsync()将os buffer中的日志写入到log file on disk" ID="ID_183532869" CREATED="1621425855061" MODIFIED="1621425856528"/>
<node TEXT=" 值为 2 和 0 的时候差距并不大" ID="ID_550147010" CREATED="1621426002790" MODIFIED="1621426004247"/>
</node>
</node>
</node>
<node TEXT=" redo log block" ID="ID_1459158082" CREATED="1621426115863" MODIFIED="1621426116828">
<node TEXT="概念" ID="ID_389298153" CREATED="1621426166093" MODIFIED="1621426169656">
<node TEXT=" redo log是以块为单位进行存储的，每个块占 512 字节" ID="ID_1940019101" CREATED="1621426121948" MODIFIED="1621426122806"/>
<node TEXT=" 不管是log buffer中还是os buffer中以及redo log file on disk中，都是这样以 512 字节的块存储的" ID="ID_1364140910" CREATED="1621426141174" MODIFIED="1621426142174"/>
</node>
<node TEXT="组成" ID="ID_1708254057" CREATED="1621426170309" MODIFIED="1621426171458">
<node ID="ID_1429263839" CREATED="1621426190385" MODIFIED="1621426190385"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      日志块头
    </p>
  </body>
</html>
</richcontent>
<node TEXT=" 占用 12 字节" ID="ID_448756356" CREATED="1621426203438" MODIFIED="1621426204439"/>
</node>
<node ID="ID_915818191" CREATED="1621426190385" MODIFIED="1621426190385"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      日志块尾
    </p>
  </body>
</html>
</richcontent>
<node TEXT=" 占用 8 字节" ID="ID_851973525" CREATED="1621426209653" MODIFIED="1621426210557"/>
</node>
<node ID="ID_1612565301" CREATED="1621426190386" MODIFIED="1621426190386"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      日志主体
    </p>
  </body>
</html>
</richcontent>
<node TEXT=" 只有512 - 12 - 8 = 492字节" ID="ID_154185560" CREATED="1621426221069" MODIFIED="1621426222109"/>
</node>
<node TEXT="" ID="ID_185765943" CREATED="1621426237532" MODIFIED="1621426240832">
<hook URI="事务_files/png_6317344699689044514.png" SIZE="0.40587217" NAME="ExternalObject"/>
</node>
</node>
</node>
<node TEXT="log block" ID="ID_1949864134" CREATED="1621426098061" MODIFIED="1621426102043"/>
<node TEXT="redo log 与 mysql 缓存" ID="ID_1902127658" CREATED="1621320777649" MODIFIED="1621320790716">
<node TEXT=" mysql中使用了大量缓存， 缓存存在于内存中，修改操作时会直接修改内存，而不是立刻修改磁盘" ID="ID_322886155" CREATED="1620889734105" MODIFIED="1621320810965"/>
<node TEXT=" 当内存和磁盘的数据不一致时，称内存中的数据为脏页(dirty page)" ID="ID_127712712" CREATED="1620889755528" MODIFIED="1620889756683"/>
</node>
</node>
<node TEXT="undo log" POSITION="right" ID="ID_435526798" CREATED="1621320359166" MODIFIED="1621320363689">
<edge COLOR="#007c00"/>
<node TEXT="概念" ID="ID_1288287650" CREATED="1621427109981" MODIFIED="1621427112605">
<node TEXT=" 回滚日志（undo log），提供回滚操作，实现mvcc" ID="ID_1394027733" CREATED="1619507237726" MODIFIED="1622702489653"/>
<node TEXT="undo是一种逻辑日志，记录的是数据的逻辑变化(sql执行的反向操作)" ID="ID_873821644" CREATED="1619609340604" MODIFIED="1622702544476"/>
<node TEXT=" undo log是事务原子性和隔离性实现的基础" ID="ID_481895754" CREATED="1619609235942" MODIFIED="1621427400913"/>
<node TEXT="  undo log是逻辑日志，在执行undo的时候，仅仅是将数据从逻辑上恢复至事务之前的状态，而不是从物理页面上操作实现的，这一点是不同于redo log的" ID="ID_1908037697" CREATED="1621429833220" MODIFIED="1621429857472"/>
</node>
<node TEXT="作用" ID="ID_1051445835" CREATED="1621427346890" MODIFIED="1621427361017" VGAP_QUANTITY="6.8999999999999995 pt">
<node TEXT="数据回滚， 把所有没有COMMIT的事务回滚到事务开始前的状态" ID="ID_1197072990" CREATED="1621427354058" MODIFIED="1621427372319"/>
<node TEXT=" 行的多版本，可以根据undo log回溯到某个特定的版本的数据，实现MVCC" ID="ID_1865623864" CREATED="1620890747971" MODIFIED="1621427381361"/>
</node>
<node TEXT="过程" ID="ID_1891459863" CREATED="1621429904284" MODIFIED="1621429907513">
<node TEXT=" 事务开始之前，将当前是的版本生成undo log，undo 也会产生 redo 来保证undo log的可靠性" ID="ID_1714491702" CREATED="1621429914549" MODIFIED="1621429934097"/>
<node TEXT=" 当事务提交之后，undo log并不能立马被删除，而是放入待清理的链表" ID="ID_330711741" CREATED="1621429942901" MODIFIED="1621429961599"/>
<node TEXT=" purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间" ID="ID_579022458" CREATED="1621429975884" MODIFIED="1621429976869"/>
</node>
<node TEXT="版本链与undo log" ID="ID_461198110" CREATED="1620891359782" MODIFIED="1620891373472">
<node TEXT=" innodb中通过B+树作为索引的数据结构" ID="ID_1171698255" CREATED="1620891405589" MODIFIED="1620891406796"/>
<node TEXT=" 聚簇索引(ClusterIndex)" ID="ID_1681221997" CREATED="1620891561613" MODIFIED="1620891589990">
<node TEXT=" 主键所在的索引为ClusterIndex, ClusterIndex中的叶子节点中保存了对应的数据内容" ID="ID_818156019" CREATED="1620891421615" MODIFIED="1620891605070"/>
<node TEXT=" 一个表只能有一个主键，所以只能有一个聚簇索引" ID="ID_1241108938" CREATED="1620891488420" MODIFIED="1620891489827"/>
<node TEXT=" 如果表没有定义主键，则选择第一个非NULL唯一索引作为聚簇索引" ID="ID_913361604" CREATED="1620891504772" MODIFIED="1620891506115"/>
<node TEXT=" 如果连唯一索引都没有则生成一个隐藏id列作为聚簇索引" ID="ID_717108192" CREATED="1620891520445" MODIFIED="1620891536319"/>
</node>
<node TEXT="辅助索引(Secondary Index)" ID="ID_1890238039" CREATED="1620891570637" MODIFIED="1620891619181">
<node TEXT=" 除了Cluster Index外的索引是辅助索引" ID="ID_781545948" CREATED="1620891624444" MODIFIED="1620891629013"/>
<node TEXT=" 辅助索引中的叶子节点保存的是聚簇索引的叶子节点的值" ID="ID_1556890743" CREATED="1620891636276" MODIFIED="1620891637215"/>
</node>
</node>
<node TEXT="undo log类型" ID="ID_231325954" CREATED="1620895955886" MODIFIED="1620895964682">
<node TEXT=" Insert undo log" ID="ID_1602843658" CREATED="1620895968542" MODIFIED="1622702618773">
<node TEXT=" 在insert 操作中产生的undo log" ID="ID_1371247852" CREATED="1622702712879" MODIFIED="1622702721668"/>
<node TEXT=" 因为insert操作的记录，只对事务本身可见，对其他事务不可见" ID="ID_12392202" CREATED="1622702730622" MODIFIED="1622702731983"/>
<node TEXT=" 该undo log可以在事务提交后直接删除，不需要进行purge操作" ID="ID_337863116" CREATED="1622702742142" MODIFIED="1622702743399"/>
</node>
<node TEXT=" Update undo log" ID="ID_934913676" CREATED="1620895972806" MODIFIED="1622702625483">
<node TEXT=" 记录的是对delete 和update操作产生的undo log" ID="ID_53680005" CREATED="1622702765294" MODIFIED="1622702766488"/>
<node TEXT="delete操作" ID="ID_1972314294" CREATED="1622702833262" MODIFIED="1622702838905">
<node TEXT=" delete可以看做是一种特殊的update，即在记录上修改删除标记" ID="ID_1063172902" CREATED="1620895986638" MODIFIED="1620895987959"/>
<node TEXT=" 进行删除修改操作时，会生成对应的undo log，并将当前数据记录中的db_roll_ptr指向新的undo log" ID="ID_427295711" CREATED="1620896059590" MODIFIED="1620896060669"/>
<node TEXT="delete是一种&quot;假删除&quot;,只是在记录上标识Delete_Bit" ID="ID_1330342840" CREATED="1622702906814" MODIFIED="1622702957859"/>
<node TEXT=" 真正的删除工作需要后台purge线程去完成" ID="ID_941378946" CREATED="1622702958263" MODIFIED="1622702960357"/>
</node>
<node TEXT=" 该undo log可能需要提供MVCC机制，因此不能再事务提交时就进行删除" ID="ID_326880204" CREATED="1622702798590" MODIFIED="1622702800859"/>
<node TEXT=" 提交时放入undo log链表，等待purge线程进行最后的删除，清理undo页和清除page里面带有Delete_Bit标识的数据行" ID="ID_867793998" CREATED="1622702806719" MODIFIED="1622702993354"/>
</node>
</node>
<node TEXT=" undo 撤销流程" ID="ID_208180288" CREATED="1619506398468" MODIFIED="1619506427270">
<node TEXT="undo log" ID="ID_1259358572" CREATED="1619507227399" MODIFIED="1619507230809"/>
<node TEXT=" undo段，是指数据库为了保持读一致性，存储历史数据在一个位置" ID="ID_1695039297" CREATED="1619506587492" MODIFIED="1619506588827"/>
<node TEXT=" 回滚操作" ID="ID_1677357429" CREATED="1619609380621" MODIFIED="1619609383832">
<node TEXT=" InnoDB会根据undo log的内容做与之前相反的工作" ID="ID_1753071967" CREATED="1619609391084" MODIFIED="1619609392113"/>
<node TEXT=" 对于每个insert，回滚时会执行delete" ID="ID_1008357154" CREATED="1619609396549" MODIFIED="1619609397617"/>
<node TEXT=" 对于每个delete，回滚时会执行insert" ID="ID_1779720272" CREATED="1619609402037" MODIFIED="1619609402832"/>
<node TEXT=" 对于每个update，回滚时会执行一个相反的update" ID="ID_244755680" CREATED="1619609408548" MODIFIED="1619609409365"/>
</node>
</node>
</node>
<node TEXT="redo log 对比 undo log" POSITION="right" ID="ID_552318032" CREATED="1622703256133" MODIFIED="1622703266248">
<edge COLOR="#00ff00"/>
<node TEXT=" redo log是重做日志，提供前滚操作" ID="ID_702328839" CREATED="1622703273813" MODIFIED="1622703275043"/>
<node TEXT=" undo log是回滚日志，提供回滚操作" ID="ID_669061240" CREATED="1622703275773" MODIFIED="1622703282091"/>
<node TEXT=" undo log不是redo log的逆向过程，其实它们都算是用来恢复的日志" ID="ID_1890669576" CREATED="1622703282734" MODIFIED="1622703294326"/>
<node TEXT="redo log 记录的是物理日志，数据页的变化。用来恢复提交后的物理数据页，且只能恢复到最后一次提交的位置" ID="ID_1621989432" CREATED="1622703303350" MODIFIED="1622703421323"/>
<node TEXT="undo log 记录的是逻辑日志，操作数据的sql反向操作，根据每行记录进行记录" ID="ID_1154335111" CREATED="1622703327829" MODIFIED="1622703439985"/>
</node>
<node TEXT=" 慢查询日志（slow query log）" POSITION="right" ID="ID_844712779" CREATED="1621320447493" MODIFIED="1621320449547">
<edge COLOR="#007c7c"/>
</node>
<node TEXT=" 一般查询日志（general log）" POSITION="right" ID="ID_692764164" CREATED="1621320455437" MODIFIED="1621320456302">
<edge COLOR="#7c7c00"/>
</node>
<node TEXT=" 中继日志（relay log）" POSITION="right" ID="ID_1334232057" CREATED="1621320462788" MODIFIED="1621320463772">
<edge COLOR="#ff0000"/>
</node>
<node TEXT="Bin Log" POSITION="right" ID="ID_1513708535" CREATED="1620889427452" MODIFIED="1620889439783">
<edge COLOR="#00007c"/>
<node TEXT="概念" ID="ID_1074687621" CREATED="1621430375971" MODIFIED="1621430377886">
<node TEXT=" 二进制日志（binlog），存储引擎的上层产生的，存于磁盘" ID="ID_319787642" CREATED="1621320427278" MODIFIED="1622703499097"/>
<node TEXT=" 逻辑格式的日志，可以简单认为是执行过的事务中的sql语句，同时包括了执行的sql语句（增删改）反向的信息" ID="ID_1877744667" CREATED="1621430378210" MODIFIED="1621430434311"/>
<node TEXT=" binlog的默认是保持时间由参数expire_logs_days配置" ID="ID_1101575292" CREATED="1621430635026" MODIFIED="1621430636219"/>
<node TEXT=" 非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除" ID="ID_1053513708" CREATED="1621430649740" MODIFIED="1621430651382"/>
<node TEXT="可用使用mysqlbinlog解析binlog" ID="ID_1300631568" CREATED="1621430451275" MODIFIED="1621430453861"/>
</node>
<node TEXT="作用" ID="ID_380022609" CREATED="1621430315803" MODIFIED="1621430317407">
<node TEXT=" 用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步" ID="ID_198034774" CREATED="1621430333155" MODIFIED="1621430334852"/>
<node TEXT=" 用于数据库的基于时间点的还原，可通过使用mysqlbinlog 工具" ID="ID_1695909033" CREATED="1621430359747" MODIFIED="1622635014086"/>
</node>
<node TEXT="过程" ID="ID_603458099" CREATED="1621430472564" MODIFIED="1621430479781">
<node TEXT=" binlog是在事务提交的时候一次性写入" ID="ID_162594962" CREATED="1621430558986" MODIFIED="1621430561718"/>
<node TEXT="写入按一定的格式，包含事务中的所有sql语句" ID="ID_1865551813" CREATED="1621430487425" MODIFIED="1621430592493"/>
</node>
<node TEXT="刷盘时机" ID="ID_1254849458" CREATED="1622635049981" MODIFIED="1622635058357">
<node TEXT=" 对于 InnoDB 存储引擎而言，只有在事务提交时才会记录 biglog，此时记录还在内存中" ID="ID_697525952" CREATED="1622635067629" MODIFIED="1622635081398"/>
<node TEXT=" mysql 通过 sync_binlog 参数控制 biglog 的刷盘时机，默认是1" ID="ID_486573316" CREATED="1622635092949" MODIFIED="1622635204928"/>
<node TEXT="参数0-N" ID="ID_1022231772" CREATED="1622635103620" MODIFIED="1622635107730">
<node ID="ID_1755415815" CREATED="1622635120219" MODIFIED="1622635120219"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      0：不去强制要求，由系统自行判断何时写入磁盘；
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_900920753" CREATED="1622635120220" MODIFIED="1622635120220"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      1：每次 commit 的时候都要将 binlog 写入磁盘；
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT="N：每N个事务，才会将 binlog 写入磁盘。牺牲一定的一致性" ID="ID_1855191578" CREATED="1622635120222" MODIFIED="1622635183569"/>
</node>
</node>
<node TEXT="对比redo log" ID="ID_254260797" CREATED="1621430669843" MODIFIED="1621430675006">
<node TEXT=" 实现方式" ID="ID_1230407915" CREATED="1622635720472" MODIFIED="1622635721854">
<node TEXT=" redo log" ID="ID_706629032" CREATED="1622635742881" MODIFIED="1622635744348">
<node TEXT=" 是 InnoDB 引擎层实现的，并不是所有引擎都有" ID="ID_788709112" CREATED="1622635748817" MODIFIED="1622635749965"/>
<node TEXT=" redo log是保证事务的持久性的，是事务层面的" ID="ID_1279017616" CREATED="1621430694898" MODIFIED="1621430709590"/>
</node>
<node TEXT=" binlog" ID="ID_166768625" CREATED="1622635755680" MODIFIED="1622635761227">
<node TEXT=" binlog 是 Server 层实现的，所有引擎都可以使用 binlog 日志" ID="ID_798253496" CREATED="1622635768184" MODIFIED="1622635769301"/>
<node TEXT=" binlog作为还原的功能，是数据库层面的（当然也可以精确到事务层面的）" ID="ID_54316405" CREATED="1621430710436" MODIFIED="1621430721902"/>
<node TEXT=" 不管是什么存储引擎，对数据库进行了修改都会产生二进制日志" ID="ID_1862809284" CREATED="1622703697452" MODIFIED="1622703698565"/>
</node>
<node TEXT=" 二进制日志先于redo log被记录" ID="ID_720572288" CREATED="1622703661684" MODIFIED="1622703662668"/>
</node>
<node TEXT="记录方式" ID="ID_1568535509" CREATED="1622635781985" MODIFIED="1622635786116">
<node TEXT="redo log" ID="ID_27587168" CREATED="1622635813345" MODIFIED="1622635815550">
<node TEXT=" redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志" ID="ID_1469879374" CREATED="1622635810839" MODIFIED="1622635812230"/>
<node TEXT="  redo log是物理日志，是数据页面的修改之后的物理记录" ID="ID_925294911" CREATED="1622635840769" MODIFIED="1622635841815"/>
</node>
<node TEXT="bin log" ID="ID_393739440" CREATED="1622635815768" MODIFIED="1622635817467">
<node TEXT=" binlog通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上" ID="ID_433572187" CREATED="1622635826135" MODIFIED="1622635827274"/>
<node TEXT=" binlog是逻辑日志，可以简单认为记录的就是sql语句" ID="ID_1869982818" CREATED="1622635849167" MODIFIED="1622635850513"/>
</node>
</node>
<node TEXT=" 日志产生的时间，可以释放的时间，在可释放的情况下清理机制，都是完全不同的" ID="ID_1916710558" CREATED="1621430751641" MODIFIED="1621430752557"/>
<node TEXT=" 恢复数据时候的效率，基于物理日志的redo log恢复数据的效率要高于语句逻辑日志的binlog" ID="ID_1386626586" CREATED="1621430760820" MODIFIED="1621430761816"/>
<node TEXT="文件大小" ID="ID_1348770398" CREATED="1622635654082" MODIFIED="1622635657492">
<node TEXT=" redo log" ID="ID_1429179202" CREATED="1622635663529" MODIFIED="1622635664925">
<node TEXT=" 大小是固定的" ID="ID_82134175" CREATED="1622635680385" MODIFIED="1622635681465"/>
</node>
<node TEXT=" bin log" ID="ID_1788477638" CREATED="1622635670057" MODIFIED="1622635674294">
<node TEXT="配置参数 max_binlog_size 设每个 binlog 文件的大小" ID="ID_76731644" CREATED="1622635688257" MODIFIED="1622635712822"/>
</node>
</node>
<node TEXT="适用场景" ID="ID_1043573069" CREATED="1622635860680" MODIFIED="1622635865334">
<node TEXT="redo log" ID="ID_1466958126" CREATED="1622635873691" MODIFIED="1622635876651">
<node TEXT=" redo log 适用于崩溃恢复(crash-safe)" ID="ID_640073929" CREATED="1622635880648" MODIFIED="1622635881799"/>
<node TEXT=" 日志上的记录落盘后会被覆盖掉" ID="ID_1112623821" CREATED="1622636052343" MODIFIED="1622636054498"/>
</node>
<node TEXT="bin log" ID="ID_74190497" CREATED="1622635876807" MODIFIED="1622635879267">
<node TEXT=" binlog 适用于主从复制和数据恢复" ID="ID_1007397458" CREATED="1622635888784" MODIFIED="1622635889587"/>
<node TEXT=" binlog 日志只用于归档，只依靠 binlog 是没有 `&#xa;crash-safe 能力的" ID="ID_115006986" CREATED="1622636039566" MODIFIED="1622636040746"/>
</node>
</node>
</node>
</node>
<node TEXT=" 高并发下的余额扣减" POSITION="right" ID="ID_1416458646" CREATED="1623738768345" MODIFIED="1623738779590">
<edge COLOR="#ff00ff"/>
<node TEXT=" 单应用，单数据库" ID="ID_1043712817" CREATED="1623738830869" MODIFIED="1623738832017">
<node TEXT="做好业务场景就OK了" ID="ID_1272030546" CREATED="1623738908132" MODIFIED="1623738909311"/>
<node TEXT=" 推荐的TPS 在5w以下" ID="ID_244075331" CREATED="1623738894500" MODIFIED="1623738895676"/>
</node>
<node TEXT=" 单应用，多数据库" ID="ID_763606633" CREATED="1623738911308" MODIFIED="1623738917013">
<node TEXT=" 使用分库来解决数据库横向扩容的问题来增加TPS" ID="ID_1015817443" CREATED="1623738927668" MODIFIED="1623738928696"/>
</node>
<node TEXT=" 多应用，多数据库" ID="ID_1225446403" CREATED="1623739002028" MODIFIED="1623739003098">
<node TEXT=" 出现分布式一致性事务的问题" ID="ID_938701926" CREATED="1623739015643" MODIFIED="1623739023877"/>
</node>
</node>
<node TEXT=" CAP定理" FOLDED="true" POSITION="right" ID="ID_567204530" CREATED="1619353310973" MODIFIED="1623835279568">
<edge COLOR="#7c0000"/>
<node TEXT="概念" ID="ID_828166751" CREATED="1623745873007" MODIFIED="1623745875659">
<node TEXT="CAP是描述性理论" ID="ID_1846086378" CREATED="1623828064302" MODIFIED="1623835577237" VGAP_QUANTITY="6.8999999999999995 pt">
<node TEXT=" 在一个分布式系统中， CAP三者不可得兼，选其二" ID="ID_357559233" CREATED="1619353364941" MODIFIED="1623741898200"/>
<node TEXT="CAP 定理主要描述的是状态，基于瞬态，是一个描述性的理论，它并不解决工程问题" ID="ID_675069055" CREATED="1623828095213" MODIFIED="1623828985844"/>
<node TEXT=" CAP理论忽略网络延迟，认为一致性是立即生效的" ID="ID_376155790" CREATED="1623745869142" MODIFIED="1623833824849"/>
<node TEXT="CAP理论忽略节点内部的处理速度不一致" ID="ID_1361187916" CREATED="1623828999746" MODIFIED="1623829044230"/>
<node TEXT="CAP理论节点间存储方式和速度的不一致" ID="ID_109532529" CREATED="1623829044897" MODIFIED="1623829065278"/>
</node>
<node TEXT=" 当分布式系统出现分区时，设计上要么迁就A，要么迁就C" ID="ID_1189146252" CREATED="1623830960854" MODIFIED="1623831115250"/>
<node TEXT=" 选择了CP，并不是叫你放弃A。因为P出现的概率实在是太小了，大部分的时间你仍然需要保证CA" ID="ID_1757578650" CREATED="1623745899439" MODIFIED="1623745900658"/>
<node TEXT=" 就算分区出现了你也要为后来的A做准备，比如通过一些日志的手段，是其他机器回复至可用" ID="ID_1642321788" CREATED="1623745921591" MODIFIED="1623745923351"/>
<node TEXT="" ID="ID_353162172" CREATED="1623826981844" MODIFIED="1623826986043">
<hook URI="事务_files/png_3788974772742642786.png" SIZE="0.6588356" NAME="ExternalObject"/>
</node>
</node>
<node TEXT=" 一致性（Consistency）" ID="ID_1345117072" CREATED="1619353431373" MODIFIED="1623741856526">
<node TEXT="概念" ID="ID_868187512" CREATED="1623741952129" MODIFIED="1623741954477">
<node TEXT=" 客户端是否能拿到最新数据" ID="ID_635829048" CREATED="1623829095393" MODIFIED="1623829096664"/>
<node TEXT="所有节点在同一时间的数据完全一致" ID="ID_1627248071" CREATED="1619353450701" MODIFIED="1623761491875"/>
<node TEXT="一致性的问题是同一份数据在多个节点上拷贝带来的" ID="ID_1566283160" CREATED="1623761575130" MODIFIED="1623761658755"/>
<node TEXT=" 分布式数据库在访问总是完全一致的，读操作总是能读取到之前完成的写操作结果" ID="ID_200355734" CREATED="1619354229497" MODIFIED="1619354233892"/>
</node>
<node TEXT="强弱一致性" ID="ID_869269500" CREATED="1619353157086" MODIFIED="1619353463238">
<node TEXT=" 强一致性" ID="ID_475289716" CREATED="1619353053144" MODIFIED="1619353177326">
<node TEXT=" 在任意时刻，所有节点中的数据是一样的" ID="ID_132527306" CREATED="1619353138695" MODIFIED="1619353139547"/>
</node>
<node TEXT=" 弱一致性" ID="ID_806420024" CREATED="1619353151350" MODIFIED="1619353176388">
<node TEXT=" 数据更新后，如果能容忍后续的访问只能访问到部分或者全部访问不到，则是弱一致性" ID="ID_290534938" CREATED="1619353199830" MODIFIED="1619353203132"/>
</node>
<node TEXT=" 最终一致性" ID="ID_1201833021" CREATED="1619353235262" MODIFIED="1619353236084">
<node TEXT=" 不保证在任意时刻任意节点上的同一份数据都是相同的" ID="ID_198501482" CREATED="1619353248462" MODIFIED="1619353249984"/>
<node TEXT=" 但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化" ID="ID_986173334" CREATED="1619353259886" MODIFIED="1619353260834"/>
<node TEXT=" 就是在一段时间后，节点间的数据会最终达到一致状态" ID="ID_1281407497" CREATED="1619353265501" MODIFIED="1619353266372"/>
</node>
</node>
</node>
<node TEXT=" 可用性（Availability）" ID="ID_715830772" CREATED="1619353466996" MODIFIED="1623741863247">
<node TEXT=" 可用性在 CAP 里就是对结果的要求" ID="ID_1403753935" CREATED="1623829392511" MODIFIED="1623829393460">
<node TEXT="服务在正常响应时间内一直可用" ID="ID_741637743" CREATED="1623741979448" MODIFIED="1623835748295"/>
<node TEXT=" 不是错误和超时的响应" ID="ID_903639032" CREATED="1623835743502" MODIFIED="1623835744442"/>
<node TEXT="可以是错误的结果、旧的数据" ID="ID_299547240" CREATED="1623835758814" MODIFIED="1623835783090"/>
<node TEXT="不等一致性，返回结果就不合理了。等太久，时间就不合理了" ID="ID_1892016344" CREATED="1623745006977" MODIFIED="1623745064837"/>
</node>
<node TEXT="可用性的判断条件" ID="ID_1688178521" CREATED="1623829566461" MODIFIED="1623829576585">
<node TEXT="返回结果必须在合理的时间以内" ID="ID_1774015357" CREATED="1623829576861" MODIFIED="1623829592238">
<node TEXT=" 业务说必须 100ms 内返回，合理的时间就是 100ms" ID="ID_658705762" CREATED="1623829612188" MODIFIED="1623829632562"/>
<node TEXT="超出规定的返回时间，就是不可用的" ID="ID_248842290" CREATED="1623829643581" MODIFIED="1623829664161"/>
</node>
<node TEXT=" 需要系统内能正常接收请求的所有节点都返回结果" ID="ID_971564170" CREATED="1623829602685" MODIFIED="1623829603939">
<node TEXT=" 部分节点宕机，其它节点还能接收请求。那么系统还是可用的，不影响可用性指标" ID="ID_569918708" CREATED="1623829711172" MODIFIED="1623829774145"/>
<node TEXT=" 如果节点能正常接收请求，但是发现节点内部数据有问题，那么也必须返回结果，哪怕返回的结果是有问题的" ID="ID_235906003" CREATED="1623829774540" MODIFIED="1623829795053"/>
</node>
</node>
<node TEXT="工程中的情况" ID="ID_580185648" CREATED="1623829400550" MODIFIED="1623829422795">
<node TEXT=" 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求" ID="ID_867447452" CREATED="1619353483659" MODIFIED="1619353484967"/>
<node TEXT=" 可用性通常情况下与可用性和分布式数据冗余，负载均衡等有着很大的关联" ID="ID_1365234729" CREATED="1623761730017" MODIFIED="1623761737145"/>
</node>
</node>
<node TEXT=" 分区容错性（Partition tolerance）" ID="ID_1794477651" CREATED="1619353507204" MODIFIED="1623741870413">
<node TEXT="什么是分区？" ID="ID_1254925800" CREATED="1619354051737" MODIFIED="1619597329392">
<node TEXT="区" ID="ID_73697595" CREATED="1623830010194" MODIFIED="1623830013311">
<node TEXT="大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）" ID="ID_160528612" CREATED="1568772186926" MODIFIED="1568772205552"/>
</node>
<node TEXT=" 分区" ID="ID_160613198" CREATED="1536671243482" MODIFIED="1568772337328">
<node TEXT="节点通信出现了问题，那么就出现了分区" ID="ID_887113817" CREATED="1623830065674" MODIFIED="1623830243836"/>
<node TEXT="一是网络故障，二是节点故障" ID="ID_415539057" CREATED="1623830172321" MODIFIED="1623830206968"/>
<node TEXT="数据就散布在了这些不连通的区域中" ID="ID_534528940" CREATED="1536671251385" MODIFIED="1536671255091"/>
<node TEXT=" 在分布式系统中，网络无法100%可靠，分区其实是一个必然现象" ID="ID_435761277" CREATED="1623745168033" MODIFIED="1623745169279"/>
</node>
<node TEXT="数据只在一个区独一份就肯定是强一致性的，因为分区导成了一致性与可用性的取舍" ID="ID_1427043498" CREATED="1619354493792" MODIFIED="1619354586425"/>
</node>
<node TEXT="概念" ID="ID_971526223" CREATED="1623745405224" MODIFIED="1623745407398">
<node TEXT="分区容错的意思是，区间通信可能失败，业务依然能够继续运行" ID="ID_666609340" CREATED="1619354140896" MODIFIED="1619354198452"/>
<node TEXT="即挂了一部分节点，还是可以正常使用的" ID="ID_1252618031" CREATED="1623742104223" MODIFIED="1623742141358"/>
<node TEXT=" 以实际效果而言，分区容错相当于对通信的时限要求" ID="ID_696354429" CREATED="1619353515934" MODIFIED="1623830309807"/>
</node>
<node TEXT="分区容错是必须的" ID="ID_1630647364" CREATED="1623745450577" MODIFIED="1623745589900">
<node TEXT="因为分布式系统中分区是必须发生的。不选P，整个系统直接不可用，意味着要舍弃分布式系统" ID="ID_1029443939" CREATED="1623830412649" MODIFIED="1623831648231"/>
<node TEXT=" 当你一个数据项只在一个节点中保存，那么分区出现后。和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的" ID="ID_1981457796" CREATED="1623834631154" MODIFIED="1623834646134"/>
<node TEXT="分区容错需要把数据复制到多个节点上，引发C(复制要时间)，继而引发A(时间长可用性低)。" ID="ID_1741960170" CREATED="1623834660458" MODIFIED="1623834830903"/>
<node TEXT=" 分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构" ID="ID_465629246" CREATED="1623745781799" MODIFIED="1623745783325"/>
</node>
</node>
<node TEXT="三者只得其二" ID="ID_831180696" CREATED="1536671022555" MODIFIED="1619354306408">
<node TEXT="一般认为P是必须提供的，所以AC需要权衡" ID="ID_1733886118" CREATED="1536671071156" MODIFIED="1536673563838"/>
<node TEXT=" 提高分区容忍性的办法" ID="ID_251199096" CREATED="1536671351041" MODIFIED="1536671352826">
<node TEXT=" 一个数据项复制到多个节点上" ID="ID_1017138650" CREATED="1536671361186" MODIFIED="1536671362290"/>
<node TEXT=" 带来一致性的问题" ID="ID_550108447" CREATED="1536671379553" MODIFIED="1536671381226"/>
<node TEXT="数据存在的节点越多，分区容忍性越高。&#xa;但要复制更新的数据就越多，一致性就越难保证。&#xa;为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。" ID="ID_104399103" CREATED="1536673505221" MODIFIED="1623827651353"/>
</node>
<node TEXT="要保致一性" ID="ID_294403021" CREATED="1536673434821" MODIFIED="1536673456582">
<node TEXT=" 每次写操作就都要等待全部节点写成功" ID="ID_1037690325" CREATED="1536673457061" MODIFIED="1536673458670"/>
<node TEXT=" 等待带来了可用性的问题" ID="ID_205541506" CREATED="1536673470453" MODIFIED="1536673476973"/>
</node>
<node TEXT="CA系统" FOLDED="true" ID="ID_1139041139" CREATED="1623826678078" MODIFIED="1623826683309">
<node TEXT=" 这种情况在分布式系统中几乎是不存在的" ID="ID_1196855585" CREATED="1623827276110" MODIFIED="1623827279218"/>
<node TEXT=" CA的系统更多的是允许分区后各子系统依然保持CA" ID="ID_686623134" CREATED="1623826683427" MODIFIED="1623826685351"/>
</node>
<node TEXT="CP系统" ID="ID_266617706" CREATED="1623826708697" MODIFIED="1623826715223">
<node TEXT=" 当一套系统在发生分区故障后，客户端的任何请求都被卡死或者超时，但是，系统的每个节点总是会返回一致的数据" ID="ID_1633159641" CREATED="1623831490046" MODIFIED="1623831491130"/>
<node TEXT=" 如果不要求A（可用），相当于每个请求都需要在Server之间强一致" ID="ID_490140186" CREATED="1623826729938" MODIFIED="1623826731126"/>
<node TEXT=" 而P（分区）会导致同步时间无限延长，如此CP也是可以保证的" ID="ID_833751460" CREATED="1623826760465" MODIFIED="1623826762142"/>
<node TEXT="例子" ID="ID_1612626291" CREATED="1623827558168" MODIFIED="1623827560356">
<node TEXT=" 数据库分布式事务都属于这种模式" ID="ID_405285826" CREATED="1623826774002" MODIFIED="1623827428830"/>
<node TEXT=" 像Redis、HBase这种分布式存储系统也是CP，一个连数据一致性都保证不了的分布式存储要他有何用？" ID="ID_1010867666" CREATED="1623827381012" MODIFIED="1623827425774"/>
</node>
</node>
<node TEXT="AP系统" ID="ID_749093530" CREATED="1623826777370" MODIFIED="1623836168905">
<node TEXT=" 要高可用并允许分区，则需放弃一致性" ID="ID_988352855" CREATED="1623826785970" MODIFIED="1623826787150"/>
<node TEXT=" 如果一套系统发生分区故障后，客户端依然可以访问系统，但是获取的数据有的是新的数据，有的还是老数据" ID="ID_1789393012" CREATED="1623830865327" MODIFIED="1623830866643"/>
<node TEXT=" 一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性" ID="ID_305954540" CREATED="1623826801858" MODIFIED="1623826802856"/>
<node TEXT=" 现在众多的NoSQL都属于此类" ID="ID_570491075" CREATED="1623826803233" MODIFIED="1623826808368"/>
</node>
</node>
</node>
<node TEXT="BASE理论" FOLDED="true" POSITION="right" ID="ID_1625774237" CREATED="1619354687829" MODIFIED="1623835285674">
<edge COLOR="#00007c"/>
<node TEXT="概念" ID="ID_684341471" CREATED="1623745953151" MODIFIED="1623745958275">
<node TEXT=" Basically Available(基本可用)，Soft state（软状态）,和Eventually consistent（最终一致性）" ID="ID_987633358" CREATED="1626848745464" MODIFIED="1626848747000"/>
<node TEXT=" BASE 理论本质上是对 CAP 理论的延伸，是对 CAP 中 AP 方案的一个补充" ID="ID_1262871699" CREATED="1619354877549" MODIFIED="1619354878888"/>
<node TEXT=" 核心思想是即便无法做到强一致性，但应该采用适合的方式保证最终一致性" ID="ID_992017847" CREATED="1619354742318" MODIFIED="1619354743797"/>
<node TEXT="系统分区时选择可用性，允许中间状态，放弃一致性。在分区故障恢复后，系统要在一定时间内达到最终一致性" ID="ID_343673625" CREATED="1623924205983" MODIFIED="1623924316502"/>
<node TEXT=" BASE解决了CAP中理论没有网络延迟" ID="ID_354073831" CREATED="1623745989270" MODIFIED="1623745990194"/>
</node>
<node TEXT="组成" ID="ID_241391731" CREATED="1623745963182" MODIFIED="1623745964516">
<node TEXT=" BA" ID="ID_1143584419" CREATED="1619354789372" MODIFIED="1619354790660">
<node ID="ID_710890731" CREATED="1619354731573" MODIFIED="1619354731573"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      基本可用 Basically Available
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT=" 分布式系统在出现故障的时候保证核心可用， 允许损失部分可用性" ID="ID_10168528" CREATED="1619354821797" MODIFIED="1623837124742"/>
<node TEXT=" 允许响应时间上的损失" ID="ID_1168756750" CREATED="1623837098643" MODIFIED="1623837136295">
<node TEXT="如正常200ms响应，基本可用2000ms响应" ID="ID_148375365" CREATED="1623837138628" MODIFIED="1623837187471"/>
</node>
<node TEXT=" 允许功能上的损失" ID="ID_544137447" CREATED="1623837089059" MODIFIED="1623837205942">
<node TEXT=" 系统的部分非核心功能无法使用" ID="ID_1335394102" CREATED="1623924358214" MODIFIED="1623924359247"/>
</node>
</node>
<node TEXT="S" ID="ID_1526064264" CREATED="1619354794365" MODIFIED="1619354795383">
<node TEXT="软状态 Soft State" ID="ID_1176700495" CREATED="1619354731573" MODIFIED="1619354793391"/>
<node TEXT=" 允许系统存在中间状态" ID="ID_852450287" CREATED="1619354842429" MODIFIED="1619354844198">
<node TEXT=" 该中间状态不会影响系统整体可用性" ID="ID_590688872" CREATED="1623837248234" MODIFIED="1623837251934"/>
<node TEXT=" 即允许系统在多个不同节点的数据副本存在数据延时" ID="ID_1233713983" CREATED="1623837267458" MODIFIED="1623837268421"/>
</node>
</node>
<node TEXT="E" ID="ID_1679634687" CREATED="1619354795695" MODIFIED="1619354797126">
<node ID="ID_564709097" CREATED="1619354731588" MODIFIED="1619354731588"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      最终一致性 Eventual Consistency
    </p>
  </body>
</html>
</richcontent>
</node>
<node TEXT=" 系统中的所有数据副本经过一定时间后，最终能够达到一致的状态" ID="ID_927500830" CREATED="1619354863189" MODIFIED="1619354864435"/>
<node TEXT=" 这个时间期限取决于网络延时、系统负载、数据复制方案设计等等因素" ID="ID_992092615" CREATED="1623837289218" MODIFIED="1623837311304"/>
</node>
</node>
<node TEXT="5种最终一致性" ID="ID_503590387" CREATED="1623837339097" MODIFIED="1623837473325">
<node TEXT=" 因果一致性（Causal consistency）" ID="ID_1954709923" CREATED="1623837355345" MODIFIED="1623837356448"/>
<node TEXT=" 读己之所写（Read your writes）" ID="ID_1529192436" CREATED="1623837356834" MODIFIED="1623837362605">
<node TEXT=" 节点A更新一个数据后，它自身总是能访问到自身更新过的最新值，而不会看到旧值" ID="ID_481056026" CREATED="1623837527676" MODIFIED="1623837529500"/>
</node>
<node TEXT=" 会话一致性（Session consistency）" ID="ID_834829233" CREATED="1623837370610" MODIFIED="1623837372150">
<node TEXT=" 会话一致性将对系统数据的访问过程框定在了一个会话当中" ID="ID_1465997662" CREATED="1623837560880" MODIFIED="1623837562028"/>
<node TEXT=" 同一个有效的会话中实现 “读己之所写” 的一致性" ID="ID_76582504" CREATED="1623837571520" MODIFIED="1623837572442"/>
<node TEXT=" 执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值" ID="ID_283819428" CREATED="1623837582784" MODIFIED="1623837583971"/>
</node>
<node TEXT=" 单调读一致性（Monotonic read consistency）" ID="ID_964722047" CREATED="1623837398410" MODIFIED="1623837400273">
<node TEXT=" 如果一个节点从系统中读取出一个数据项的某个值后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值" ID="ID_1974103331" CREATED="1623837609104" MODIFIED="1623837610260"/>
</node>
<node TEXT=" 单调写一致性（Monotonic write consistency）" ID="ID_801440275" CREATED="1623837404161" MODIFIED="1623837405679">
<node TEXT=" 一个系统要能够保证来自同一个节点的写操作被顺序的执行" ID="ID_710652284" CREATED="1623837620392" MODIFIED="1623837621753"/>
</node>
</node>
<node TEXT="实现最终一致性" ID="ID_70613622" CREATED="1623847804400" MODIFIED="1623847814388">
<node TEXT=" 写时修复" ID="ID_1533197914" CREATED="1623847818521" MODIFIED="1623847819369">
<node TEXT=" 在多个副本写的时候，如果其中一个写失败了，就缓存起来，系统自动通过重试的手段进行修复" ID="ID_645719092" CREATED="1623847834281" MODIFIED="1623847835331"/>
<node TEXT=" 写时修复，更快达到最终一致性，因为修复动作离写操作最近" ID="ID_1698782650" CREATED="1623847845865" MODIFIED="1623847846776"/>
</node>
<node TEXT=" 读时修复" ID="ID_1690964106" CREATED="1623847861986" MODIFIED="1623847862880">
<node TEXT=" 读数据的时候，可以同时读多个节点的同一份数据，然后根据一定的规则，比如以超过半数的数据值为准的办法，来决定返回的值" ID="ID_525399330" CREATED="1623847881224" MODIFIED="1623847885344"/>
<node TEXT=" 读时候发现数据不一致的时候会自动修复" ID="ID_58478753" CREATED="1623847904064" MODIFIED="1623847904843"/>
</node>
<node TEXT="异步修复" ID="ID_1083354022" CREATED="1623847916448" MODIFIED="1623847922237">
<node TEXT=" 通过定时不同节点比对的方式，来对照数据是否需要修复" ID="ID_1892778683" CREATED="1623847922400" MODIFIED="1623847923570"/>
</node>
</node>
</node>
<node TEXT="分布式事务" POSITION="right" ID="ID_605388676" CREATED="1619352792280" MODIFIED="1619352797283">
<edge COLOR="#7c7c00"/>
<node TEXT="概念" ID="ID_1665988412" CREATED="1619597318739" MODIFIED="1619597322000">
<node TEXT=" 分布式事务就是指有多个小事务分布在不同的服务器上" ID="ID_1447062014" CREATED="1623741211978" MODIFIED="1623741253719"/>
<node TEXT=" 本质上来说，分布式事务就是为了保证不同数据库的数据一致性" ID="ID_1734810884" CREATED="1619352880361" MODIFIED="1619352881415"/>
<node TEXT="不在同一节点的服务" ID="ID_1291730770" CREATED="1619352914920" MODIFIED="1619352925857">
<node TEXT=" 事务的参与者" ID="ID_389374101" CREATED="1619352931210" MODIFIED="1619352932346"/>
<node TEXT=" 支持事务的服务器" ID="ID_1784892598" CREATED="1619352937097" MODIFIED="1619352938014"/>
<node TEXT=" 资源服务器" ID="ID_96634837" CREATED="1619352943409" MODIFIED="1619352944382"/>
<node TEXT=" 事务管理器" ID="ID_1652423083" CREATED="1619352950616" MODIFIED="1619352951741"/>
</node>
<node TEXT="电商下单" ID="ID_974917459" CREATED="1619352991167" MODIFIED="1619353010169">
<node TEXT=" 下单接口通常会扣减库存、减去优惠、生成订单 id" ID="ID_1210629600" CREATED="1619353027241" MODIFIED="1619353028094"/>
<node TEXT=" 订单服务与库存、优惠、订单 id 都是不同的服务" ID="ID_1980734664" CREATED="1619353034209" MODIFIED="1619353034994"/>
<node TEXT=" 下单接口的成功与否，不仅取决于本地的 db 操作，而且依赖第三方系统的结果" ID="ID_842914839" CREATED="1619353042215" MODIFIED="1619353043009"/>
<node TEXT=" 这时候分布式事务就保证这些操作要么全部成功，要么全部失败" ID="ID_47117111" CREATED="1619353047503" MODIFIED="1619353048363"/>
</node>
<node TEXT=" 大并发下的分布式一致性服务，目前的大难点已经是异地跨机房的分钟级别容灾" ID="ID_887428826" CREATED="1620789509267" MODIFIED="1620789516041"/>
</node>
<node TEXT=" 分布式事务产生的原因" ID="ID_292231370" CREATED="1623741375759" MODIFIED="1623741382543">
<node TEXT=" service多个节点" ID="ID_346495517" CREATED="1623741452374" MODIFIED="1623741453319">
<node TEXT=" 微服务，SOA等服务架构模式拆分大应用为多个小应用" ID="ID_1860409911" CREATED="1623741462751" MODIFIED="1623741495787"/>
<node TEXT=" 比如余额，积分，优惠券等等，由不同团队维护" ID="ID_811342084" CREATED="1623741507470" MODIFIED="1623741518730"/>
</node>
<node TEXT=" resource多个节点" ID="ID_591219485" CREATED="1623741524589" MODIFIED="1623741525496">
<node TEXT=" 数据库的分库分表，单个数据库被拆成多节点" ID="ID_901333375" CREATED="1623741543669" MODIFIED="1623741592145"/>
</node>
</node>
<node TEXT=" 柔性事务" ID="ID_950757521" CREATED="1619354883772" MODIFIED="1619597339951">
<node TEXT=" 不同于 ACID 的刚性事务，在分布式场景下基于 BASE 理论，就出现了柔性事务的概念" ID="ID_416464163" CREATED="1619354935757" MODIFIED="1619354936739"/>
<node TEXT=" 通过柔性事务来达到最终的一致性" ID="ID_1655096652" CREATED="1619354955107" MODIFIED="1619354956854"/>
</node>
<node TEXT=" 分布式事务（XA 事务）的 SQL 语法" ID="ID_358618242" CREATED="1619597327942" MODIFIED="1619608870905">
<node TEXT=" XA {START|BEGIN} xid [JOIN|RESUME]" ID="ID_752087122" CREATED="1619608874863" MODIFIED="1619608875951"/>
</node>
</node>
<node TEXT=" 幂等操作" FOLDED="true" POSITION="right" ID="ID_687006667" CREATED="1619354970172" MODIFIED="1619354984484">
<edge COLOR="#007c00"/>
<node TEXT=" 一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同" ID="ID_94228215" CREATED="1619355000684" MODIFIED="1619355001925"/>
<node TEXT=" 幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数" ID="ID_1449717930" CREATED="1619355012372" MODIFIED="1619355013426"/>
<node TEXT=" 这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变" ID="ID_1666790020" CREATED="1619355024597" MODIFIED="1619355025728"/>
<node TEXT="例" ID="ID_238529734" CREATED="1624359780495" MODIFIED="1624359785312">
<node TEXT=" setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的" ID="ID_400112109" CREATED="1624359785483" MODIFIED="1624359786459"/>
<node TEXT=" 更复杂的操作幂等保证是利用唯一交易号(流水号)实现" ID="ID_102832369" CREATED="1624359837931" MODIFIED="1624359838791"/>
</node>
<node TEXT="保证幂等的检验" ID="ID_1052845346" CREATED="1626849134956" MODIFIED="1626849148082">
<node TEXT="强校验" ID="ID_1940732897" CREATED="1624359880962" MODIFIED="1624359887896">
<node TEXT="多个操作做成事务" ID="ID_752804364" CREATED="1624360027986" MODIFIED="1624360046646"/>
<node TEXT="如根据订单加钱" ID="ID_1688162062" CREATED="1624360056219" MODIFIED="1624360068646"/>
</node>
<node TEXT="弱校验" ID="ID_1058993658" CREATED="1624360048114" MODIFIED="1624360054558">
<node TEXT=" 用token判断" ID="ID_584273913" CREATED="1624360150993" MODIFIED="1624360162847"/>
<node TEXT="做一个唯一key到redis，用redis判断" ID="ID_1158940651" CREATED="1624360083547" MODIFIED="1624360155093"/>
<node TEXT="如发短信验证码" ID="ID_804986948" CREATED="1624360070402" MODIFIED="1624360082759"/>
</node>
</node>
</node>
<node TEXT=" 分布式事务使用场景" POSITION="right" ID="ID_1049740810" CREATED="1619355053684" MODIFIED="1619355054593">
<edge COLOR="#7c007c"/>
<node TEXT=" 转账" ID="ID_1933468736" CREATED="1619355057860" MODIFIED="1619355060019">
<node TEXT=" 用户 A 使用银行 app 发起一笔跨行转账给用户 B，银行系统首先扣掉用户 A 的钱，然后增加用户 B 账户中的余额" ID="ID_851930946" CREATED="1619355154667" MODIFIED="1619355155814"/>
<node TEXT="异常1" ID="ID_1039178177" CREATED="1619355157365" MODIFIED="1619355161942">
<node TEXT="  用户 A 的账户扣款成功，用户 B 账户余额增加失败" ID="ID_1685765057" CREATED="1619355171115" MODIFIED="1619355182049"/>
</node>
<node TEXT="异常2" ID="ID_1330538169" CREATED="1619355162171" MODIFIED="1619355164981">
<node TEXT=" 用户 A 账户扣款失败，用户 B 账户余额增加成功" ID="ID_1900668296" CREATED="1619355178163" MODIFIED="1619355179290"/>
</node>
</node>
<node TEXT=" 下单扣库存" ID="ID_1090610081" CREATED="1619355060372" MODIFIED="1619355068617">
<node TEXT=" 在电商系统中，下单接口中必定会涉及生成订单 id, 扣减库存等操作" ID="ID_1106060034" CREATED="1619355218835" MODIFIED="1619355232521"/>
<node TEXT=" 对于微服务架构系统，订单 id 与库存服务一般都是独立的服务" ID="ID_1517264089" CREATED="1619355240699" MODIFIED="1619355241621"/>
</node>
<node TEXT=" 同步超时" ID="ID_45821347" CREATED="1619355073452" MODIFIED="1619355074640">
<node TEXT="" ID="ID_218442954" CREATED="1619421153989" MODIFIED="1619421157868">
<hook URI="事务_files/png_6823414311983514842.png" SIZE="0.7192877" NAME="ExternalObject"/>
</node>
<node TEXT=" 我们的支付系统收到来自第三方支付的通知，告知某个订单支付成功" ID="ID_1594361270" CREATED="1619421212410" MODIFIED="1619421219994"/>
<node TEXT="支付服务告知订单服务，变更该订单支付状态" ID="ID_1182016641" CREATED="1619421229501" MODIFIED="1619421274869"/>
<node TEXT="两次支付成功的告知调用，都可能出现调用超时" ID="ID_626172528" CREATED="1619421324196" MODIFIED="1619421356109"/>
</node>
</node>
<node TEXT=" 分布式事务的解决方案" POSITION="right" ID="ID_773107424" CREATED="1619421368451" MODIFIED="1619421383347">
<edge COLOR="#007c7c"/>
<node TEXT="确保通知型事务" ID="ID_1646967717" CREATED="1620788672551" MODIFIED="1620788680934">
<node TEXT=" 补偿型事务与确保通知型事务，牺牲一点一致性，让业务等待时间缩短" ID="ID_1258041889" CREATED="1620788929198" MODIFIED="1620788957515"/>
<node TEXT=" 发起者先落库，然后再发出一条事务型消息，确保消息发出后，直接返回（此时参与者很多都未落库）" ID="ID_642832639" CREATED="1620788837759" MODIFIED="1620788838983"/>
</node>
<node TEXT="两阶段提交协议（Two-phase commit protocol, 2PC）" FOLDED="true" ID="ID_67386188" CREATED="1619421386659" MODIFIED="1619612553799">
<node TEXT="概念" ID="ID_1946137953" CREATED="1619612898799" MODIFIED="1619612902810">
<node TEXT=" 在此协议中，一个事务协调器（TM, transaction manager）协调多个资源管理器（RM, resource manager）的活动" ID="ID_482917298" CREATED="1619612912583" MODIFIED="1619612914517"/>
<node TEXT=" 2PC是一个非常经典的强一致、中心化的原子提交协议" ID="ID_304343589" CREATED="1619613844083" MODIFIED="1619613845392"/>
<node TEXT="所有资源管理器的状态最终都是一致的，要么全部提交，要么全部回滚" ID="ID_1036846999" CREATED="1619613226829" MODIFIED="1626849562180"/>
<node TEXT=" 本地资源管理器一般是由数据库实现XA协议" ID="ID_1828399068" CREATED="1619421455689" MODIFIED="1619613613951"/>
<node TEXT=" 协议假设的条件就是 commit 一定会成功，主要是考虑 commit 阶段做的工作比较简单" ID="ID_255627851" CREATED="1619680292460" MODIFIED="1619680296032"/>
<node TEXT=" 对应技术上的XA、JTA/JTS" ID="ID_1932475074" CREATED="1622705081536" MODIFIED="1622705089384"/>
</node>
<node TEXT="" ID="ID_466409686" CREATED="1619439901802" MODIFIED="1619439906248">
<hook URI="事务_files/png_8804033049627947075.png" SIZE="0.49588123" NAME="ExternalObject"/>
</node>
<node TEXT="角色" ID="ID_1897299005" CREATED="1619612296146" MODIFIED="1619612299057">
<node TEXT=" 协调者节点" ID="ID_1331942266" CREATED="1619613935787" MODIFIED="1619613936880">
<node TEXT=" 中心化协调者节点（coordinator）" ID="ID_422629702" CREATED="1619613943012" MODIFIED="1619613944073"/>
<node TEXT="亦叫事务管理器（TM）" ID="ID_1279727887" CREATED="1619612373568" MODIFIED="1619613961092"/>
</node>
<node TEXT="参与者节点" ID="ID_1232417077" CREATED="1619613967514" MODIFIED="1619613975478">
<node TEXT=" N个参与者节点（partcipant）" ID="ID_571508793" CREATED="1619613981154" MODIFIED="1619613982104"/>
<node TEXT="亦叫资源管理器（RM）" ID="ID_98542029" CREATED="1619612373570" MODIFIED="1619613992512"/>
</node>
</node>
<node TEXT=" 分两步提交" ID="ID_203113505" CREATED="1619421465610" MODIFIED="1619421466398">
<node TEXT="第一阶段（prepare）" ID="ID_31561317" CREATED="1619421622873" MODIFIED="1619421654563">
<node TEXT="协调者" ID="ID_677890618" CREATED="1619676783994" MODIFIED="1619676793021">
<node TEXT=" 事务管理器向所有本地资源管理器发起请求，通知它们执行准备操作" ID="ID_307667433" CREATED="1619421588568" MODIFIED="1619613036733"/>
<node TEXT="等待参与者响应结果" ID="ID_689573920" CREATED="1619676797922" MODIFIED="1619676822662"/>
</node>
<node TEXT="参与者" ID="ID_928320079" CREATED="1619676637067" MODIFIED="1619676644485">
<node TEXT=" 在本地执行事务，但不提交" ID="ID_794424501" CREATED="1619676630459" MODIFIED="1619676653268"/>
<node TEXT=" 写本地的redo和undo日志，主要是为了故障后恢复用" ID="ID_1225874933" CREATED="1619676649123" MODIFIED="1619676855790"/>
<node TEXT=" 向 事务管理器 回复准备成功或失败" ID="ID_363520314" CREATED="1619676673090" MODIFIED="1619676674432"/>
</node>
</node>
<node TEXT=" 第二阶段 (commit/rollback)" ID="ID_1673005309" CREATED="1619421661399" MODIFIED="1619421662401">
<node TEXT="协调者" ID="ID_363344388" CREATED="1619676875642" MODIFIED="1619676887205">
<node TEXT="收到参与者响应" ID="ID_1417192678" CREATED="1619676911313" MODIFIED="1619676920932"/>
<node TEXT="所有RM准备成功，TM会通知所有RM 提交" ID="ID_1820085228" CREATED="1619676929451" MODIFIED="1619676983065"/>
<node TEXT=" 如果任一RM准备失败(超时失败)，TM会通知所有RM回滚" ID="ID_469920835" CREATED="1619613117622" MODIFIED="1619613143714"/>
</node>
<node TEXT="参与者" ID="ID_1772958195" CREATED="1619677002033" MODIFIED="1619677004342">
<node TEXT="rm将准备阶段的事务真正提交" ID="ID_733912201" CREATED="1619677008577" MODIFIED="1619677029997"/>
<node TEXT=" Rm Commit之后释放整个事务执行期间占用的事务资源" ID="ID_1517308479" CREATED="1619614081474" MODIFIED="1619614107713"/>
<node TEXT="rm回复tm，提交事务成功" ID="ID_1069450598" CREATED="1619677032307" MODIFIED="1619677050152"/>
<node TEXT="就算回复tm失败，整个事务也完结了，人工恢复吧" ID="ID_203191416" CREATED="1619680328030" MODIFIED="1619680368529"/>
</node>
</node>
<node TEXT=" 要实现 2PC，所有的参与者都要实现三个接口" ID="ID_1279949391" CREATED="1619439952933" MODIFIED="1619439964881">
<node ID="ID_1456432260" CREATED="1619439976036" MODIFIED="1619439976036"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      &nbsp;Prepare()：TM 调用该接口询问各个本地事务是否就绪
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1103998342" CREATED="1619439976036" MODIFIED="1619439976036"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Commit()：TM 调用该接口要求各个本地事务提交
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_544259330" CREATED="1619439976038" MODIFIED="1619439976038"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      Rollback()：TM 调用该接口要求各个本地事务回滚
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node TEXT="存在的问题" ID="ID_1580716037" CREATED="1619421752350" MODIFIED="1619421762218">
<node TEXT=" 同步阻塞" ID="ID_857681278" CREATED="1619421805798" MODIFIED="1619421806691">
<node TEXT=" 当参与事务者存在占用公共资源的情况， 其中一个占用了资源，其他事务参与者就只能阻塞等待资源释放，处于阻塞状态" ID="ID_248611385" CREATED="1619421827502" MODIFIED="1619614216202"/>
<node TEXT=" 全过程所有的参与者资源和协调者资源都是被锁住的" ID="ID_393729520" CREATED="1619614187841" MODIFIED="1619614193211"/>
</node>
<node TEXT=" 单点故障" ID="ID_610101751" CREATED="1626855140177" MODIFIED="1626855141406"/>
<node TEXT=" 数据不一致" ID="ID_730119900" CREATED="1626855134297" MODIFIED="1626855135400"/>
<node TEXT=" 极限情况下,对某一事务的不确定性" ID="ID_1750956743" CREATED="1626855129329" MODIFIED="1626855130083"/>
<node TEXT=" 三种宕机情况" ID="ID_1399864179" CREATED="1619614313497" MODIFIED="1626854561433">
<node TEXT=" 协调者正常,参与者宕机" ID="ID_285186988" CREATED="1619614319464" MODIFIED="1619614320698">
<node TEXT="发生在第一阶段" ID="ID_1627600674" CREATED="1626854767120" MODIFIED="1626854774901">
<node TEXT=" 协调者 无法收集到所有 参与者 的反馈，会陷入阻塞情况" ID="ID_251451014" CREATED="1619614395872" MODIFIED="1619614397288"/>
<node TEXT=" 协调者引入超时机制，回滚正常的参与者" ID="ID_946291363" CREATED="1619614343272" MODIFIED="1626854638076"/>
</node>
<node TEXT="发生在第二阶段" ID="ID_1398831937" CREATED="1626854779704" MODIFIED="1626854786694">
<node TEXT="部分参与者提交成功，部分参与者提交失败" ID="ID_1010658383" CREATED="1626854792953" MODIFIED="1626854818196"/>
<node TEXT="出现数据不一致的情况" ID="ID_1808554830" CREATED="1626854818537" MODIFIED="1626854835172"/>
</node>
</node>
<node TEXT=" 协调者宕机,参与者正常" ID="ID_748436299" CREATED="1619614371792" MODIFIED="1619614373165">
<node TEXT="单点故障，一旦事务管理器出现故障，整个系统不可用" ID="ID_937682387" CREATED="1626854936349" MODIFIED="1626854953385"/>
<node TEXT="如果资源管理器在阻塞状态中，会一直阻塞下去" ID="ID_1435692244" CREATED="1626854431852" MODIFIED="1626854455555"/>
<node TEXT="如果此时资源被锁住，会一直阻塞下去" ID="ID_1684192203" CREATED="1619614252432" MODIFIED="1619614286339"/>
<node TEXT=" 引入协调者备份" ID="ID_823256040" CREATED="1619614504584" MODIFIED="1619614580855">
<node TEXT=" 协调者需记录操作日志" ID="ID_1447119284" CREATED="1619614576472" MODIFIED="1619614577586"/>
<node TEXT=" 当检测到协调者宕机一段时间后，协调者备份取代协调者" ID="ID_1465442423" CREATED="1619614513663" MODIFIED="1619614564875"/>
<node ID="ID_1837174142" CREATED="1619614559745" MODIFIED="1619614559745"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      并读取操作日志，向所有参与者询问状态
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
</node>
<node TEXT=" 协调者和参与者都宕机" ID="ID_427909033" CREATED="1619614522695" MODIFIED="1619614523636">
<node TEXT=" 发生在第一阶段" ID="ID_1053312218" CREATED="1619614590495" MODIFIED="1619614591477">
<node TEXT=" 因为第一阶段，所有参与者都没有真正执行commit，所以只需重新在剩余的参与者中重新选出一个协调者" ID="ID_1513635707" CREATED="1619614599111" MODIFIED="1619614600283"/>
<node TEXT=" 新的协调者在重新执行第一阶段和第二阶段就可以了" ID="ID_1059500328" CREATED="1619614609224" MODIFIED="1619614610193"/>
</node>
<node TEXT=" 发生在第二阶段 并且 挂了的参与者在挂掉之前没有收到协调者的指令" ID="ID_1013804046" CREATED="1619614616784" MODIFIED="1619614631170">
<node TEXT=" 新的协调者重新执行第一阶段和第二阶段操作" ID="ID_49923479" CREATED="1619614657918" MODIFIED="1619614658986"/>
</node>
<node TEXT="发生在第二阶段 并且 有部分参与者已经执行完commit操作，部分参与都未执行commit，双双宕机" ID="ID_1327571987" CREATED="1619614693823" MODIFIED="1619614789851">
<node TEXT=" 数据不一致" ID="ID_379199959" CREATED="1619421868029" MODIFIED="1619421868946">
<node TEXT=" 只发送了部分 commit 消息，此时网络发生异常" ID="ID_148365443" CREATED="1619421894045" MODIFIED="1623746447631"/>
<node TEXT=" 这个时候目前来讲数据是不一致的" ID="ID_1181692295" CREATED="1619614800880" MODIFIED="1619614801951"/>
<node TEXT=" 那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致" ID="ID_202700723" CREATED="1619421911229" MODIFIED="1619421912216"/>
</node>
<node TEXT=" 不确定性" ID="ID_1094893139" CREATED="1619421921687" MODIFIED="1619421923175">
<node TEXT="只有部分参与者收到了 commit" ID="ID_1779914600" CREATED="1619421954468" MODIFIED="1623746474723"/>
<node TEXT=" 那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功" ID="ID_755945378" CREATED="1619421982148" MODIFIED="1619421983372"/>
</node>
<node TEXT=" 2PC 无法解决这个问题" ID="ID_1253743933" CREATED="1619614823111" MODIFIED="1619614823933"/>
</node>
</node>
</node>
</node>
<node TEXT="XA规范" ID="ID_1060281690" CREATED="1619612227107" MODIFIED="1619612237493">
<node TEXT="XA属于2pc的应用" ID="ID_1682098521" CREATED="1619613528877" MODIFIED="1619613547215"/>
<node TEXT=" X/Open XA 定义了分布式事务处理的规范，并由数据库厂商在驱动层面进行实现" ID="ID_28759962" CREATED="1619612281739" MODIFIED="1619612282944"/>
<node TEXT=" XA 规范的基础是两阶段提交协议，并定义了分布式事务处理所涉及的角色" ID="ID_1426414750" CREATED="1619612291442" MODIFIED="1619612292845"/>
<node TEXT="角色" ID="ID_746664986" CREATED="1619612296146" MODIFIED="1619612299057">
<node ID="ID_826664997" CREATED="1619612373568" MODIFIED="1619612373568"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      应用程序（AP）
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_333765021" CREATED="1619612373568" MODIFIED="1619612373568"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      事务管理器（TM）
    </p>
  </body>
</html>
</richcontent>
<node TEXT=" 常见的事务管理器（ TM ）是交易中间件" ID="ID_1793743987" CREATED="1619612422305" MODIFIED="1619612424041"/>
</node>
<node ID="ID_600575133" CREATED="1619612373570" MODIFIED="1619612373570"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      资源管理器（RM）
    </p>
  </body>
</html>
</richcontent>
<node TEXT=" 常见的资源管理器（ RM ）是数据库" ID="ID_1781516460" CREATED="1619612428818" MODIFIED="1619612430382"/>
</node>
<node ID="ID_1149777114" CREATED="1619612373572" MODIFIED="1619612373572"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      通信资源管理器（CRM）
    </p>
  </body>
</html>
</richcontent>
<node TEXT=" 常见的通信资源管理器（ CRM ）是消息中间件" ID="ID_1055545133" CREATED="1619612438305" MODIFIED="1619612439870"/>
</node>
</node>
<node TEXT="XA接口" ID="ID_485485115" CREATED="1619613553684" MODIFIED="1619613558539">
<node ID="ID_1378272245" CREATED="1619613572134" MODIFIED="1619613572134"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      &nbsp;xa_start: 启动XA事务
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_867184202" CREATED="1619613572134" MODIFIED="1619613572134"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      xa_end: 结束XA事务
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1652081140" CREATED="1619613572135" MODIFIED="1619613572135"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      xa_prepare: 准备阶段，XA事务预提交
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_271174443" CREATED="1619613572137" MODIFIED="1619613572137"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      xa_commit：提交XA事务
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1941013635" CREATED="1619613572138" MODIFIED="1619613572138"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      xa_rollback: 回滚XA事务
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="XA二阶段" ID="ID_223067225" CREATED="1619613680883" MODIFIED="1619613687598">
<node TEXT="一阶段" ID="ID_1832634365" CREATED="1619613675027" MODIFIED="1619613679342">
<node TEXT=" 事务管理器协调所有数据库执行XA事务（xa_start、用户SQL、xa_end）" ID="ID_166645849" CREATED="1619613718579" MODIFIED="1619613724512"/>
<node TEXT=" 并完成XA事务预提交（xa_prepare）" ID="ID_388913301" CREATED="1619613724986" MODIFIED="1619613726221"/>
</node>
<node TEXT="二阶段" ID="ID_773192752" CREATED="1619613675027" MODIFIED="1619613695439">
<node TEXT=" 如果所有数据库上XA事务预提交均成功，那么事务管理器协调所有数据库提交XA事务（xa_commit）" ID="ID_1975398238" CREATED="1619613736995" MODIFIED="1619613738914"/>
<node TEXT=" 如果任一数据库上XA是我预提交失败，那么事务管理器会协调所有数据组回滚XA事务（xa_rollback）" ID="ID_384235856" CREATED="1619613746427" MODIFIED="1619613747387"/>
</node>
</node>
</node>
</node>
<node TEXT="三阶段提交（Three-phase commit）" FOLDED="true" ID="ID_1788909265" CREATED="1619441018943" MODIFIED="1619614918576">
<node TEXT="概念" ID="ID_192433366" CREATED="1619614845583" MODIFIED="1619614848017">
<node TEXT=" 三阶段提交协议（3PC）主要是为了解决两阶段提交协议的阻塞问题，但更易出现不一致性" ID="ID_227295918" CREATED="1619614858918" MODIFIED="1627020703281"/>
<node TEXT=" 2pc存在的问题是当协调者崩溃时，参与者不能做出最后的选择，因此参与者可能在协作者恢复之前保持阻塞" ID="ID_199201833" CREATED="1619614871654" MODIFIED="1626860080228"/>
</node>
<node TEXT="对比2pc的改动" ID="ID_885031615" CREATED="1619614926302" MODIFIED="1619614936544">
<node TEXT=" 引入超时机制" ID="ID_1769036514" CREATED="1619614941613" MODIFIED="1619615265119">
<node TEXT=" 同时在协调者和参与者中都引入超时机制。" ID="ID_289561563" CREATED="1619615265740" MODIFIED="1619615266829"/>
<node TEXT=" 2PC中只有协调者可以超时，参与者没有超时机制" ID="ID_1235869066" CREATED="1619615259540" MODIFIED="1619615273695"/>
<node TEXT="减少了资源阻塞，但更易出现不一致" ID="ID_1195316984" CREATED="1626859909694" MODIFIED="1626859950650"/>
</node>
<node TEXT="锁资源超时自动commit" ID="ID_184153858" CREATED="1619665698900" MODIFIED="1626859863574">
<node TEXT=" 参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源" ID="ID_70722573" CREATED="1619664306984" MODIFIED="1619664313008"/>
<node TEXT=" 解决的单点故障问题，并减少阻塞" ID="ID_613231224" CREATED="1619678691365" MODIFIED="1619678692762"/>
<node TEXT=" 避免了参与者在长时间无法与协调者节点通讯（协调者挂掉了）的情况下，无法释放资源的问题" ID="ID_821074296" CREATED="1619664296808" MODIFIED="1619664299628"/>
<node TEXT="如果超时没收到abort，和其他接到abort命令并执行回滚的参与者之间存在数据不一致的情况" ID="ID_756898308" CREATED="1619665726969" MODIFIED="1619665768500"/>
<node TEXT=" 因为其它参与者成功提交的几率很大，所以默认commit，而不是abort" ID="ID_574766509" CREATED="1619678754366" MODIFIED="1619678783440"/>
</node>
<node TEXT=" 3PC把2PC的准备阶段再次一分为二" ID="ID_952581678" CREATED="1619615012326" MODIFIED="1619615013648">
<node TEXT=" 这样三阶段提交就有CanCommit、PreCommit、DoCommit" ID="ID_824849737" CREATED="1619615038598" MODIFIED="1619615044109"/>
<node TEXT=" 先在CanCommit询问参与者能与参与，在PreComit才再让参与者锁资源、做事务，从而减少资源浪费" ID="ID_335860416" CREATED="1619677622783" MODIFIED="1619677767602"/>
<node TEXT=" 保证了在最后提交阶段之前各参与节点的状态是一致的" ID="ID_1592359060" CREATED="1619615023997" MODIFIED="1619615025163"/>
<node TEXT="多了一个阶段，就多了一次请求确认。因为效率问题，两阶段提交协议在实际系统中反而更加受宠" ID="ID_1506261821" CREATED="1619680123943" MODIFIED="1619680149204"/>
</node>
</node>
<node TEXT="三个阶段" ID="ID_1348585059" CREATED="1619615058286" MODIFIED="1619615063176">
<node TEXT=" CanCommit阶段" ID="ID_1348069353" CREATED="1619615069701" MODIFIED="1619615070532">
<node TEXT=" 协调者 向 参与者 发送CanCommit请求，询问是否可以执行事务提交操作" ID="ID_1362599754" CREATED="1619615203692" MODIFIED="1619615216031"/>
<node TEXT=" 在PreCommit之前，保证所有参与者都具备可执行条件，从而减少资源浪费。" ID="ID_1525138527" CREATED="1619677572416" MODIFIED="1619677615873"/>
<node TEXT=" 协调者协议流程" ID="ID_1837842641" CREATED="1619665098822" MODIFIED="1619665100753">
<node TEXT=" 写本地日志“BEGIN_COMMIT”，并进入WAIT状态" ID="ID_655117471" CREATED="1619665105918" MODIFIED="1619665107090"/>
<node TEXT=" 向所有参与者发送“VOTE_REQUEST”消息" ID="ID_1361888952" CREATED="1619665117255" MODIFIED="1619665118690"/>
<node TEXT=" 等待并接收参与者发送的对“VOTE_REQUEST”的响应， 参与者响应“VOTE_ABORT”或“VOTE_COMMIT”消息给协调者" ID="ID_594480872" CREATED="1619665133174" MODIFIED="1619665157907"/>
</node>
<node TEXT="参与者协议流程" ID="ID_1765440280" CREATED="1619665169374" MODIFIED="1619665181705">
<node TEXT=" 尝试获取数据库锁如果可以，就返回Yes，不锁资源" ID="ID_1418130123" CREATED="1619615151517" MODIFIED="1619677808433"/>
<node TEXT="不执行本地事务，只是确认自身能顺利执行事务" ID="ID_788334012" CREATED="1619615172117" MODIFIED="1619664659435"/>
</node>
</node>
<node TEXT=" PreCommit阶段" ID="ID_851450439" CREATED="1619615227461" MODIFIED="1619615228512">
<node TEXT=" 相较于2PC而言，PreCommit是多设置的缓冲阶段，保证了在最后提交阶段之前各参与节点的状态是一致的" ID="ID_137658314" CREATED="1619664342159" MODIFIED="1619665502319"/>
<node TEXT="PreCommit阶段 协调者和参与者都引入了超时机制" ID="ID_519508825" CREATED="1619664242019" MODIFIED="1619664250652"/>
<node TEXT="协调者协议流程" ID="ID_1133616492" CREATED="1619665195981" MODIFIED="1619665208282">
<node TEXT="如果所有的参与者都返回Yes的话，那么就会进入PreCommit阶段进行事务预提交" ID="ID_840126495" CREATED="1619678462374" MODIFIED="1619678468131"/>
<node TEXT=" 若收到任何一个参与者发送的“VOTE_ABORT”消息" ID="ID_1120681403" CREATED="1619665223055" MODIFIED="1619665226122">
<node TEXT=" 写本地“GLOBAL_ABORT”日志，进入ABORT状态" ID="ID_921339199" CREATED="1619665232710" MODIFIED="1619665233998"/>
<node TEXT=" 向所有的参与者发送“GLOBAL_ABORT”消息" ID="ID_264836620" CREATED="1619665238078" MODIFIED="1619665238995"/>
</node>
<node TEXT=" 若收到所有参与者发送的“VOTE_COMMIT”消息" ID="ID_1125515135" CREATED="1619665244229" MODIFIED="1619665245200">
<node TEXT=" 写本地“PREPARE_COMMIT”日志，进入PRECOMMIT状态" ID="ID_630193646" CREATED="1619665253366" MODIFIED="1619665254484"/>
<node TEXT=" 向所有的参与者发送“PREPARE _COMMIT”消息" ID="ID_1952548337" CREATED="1619665259006" MODIFIED="1619665259997"/>
</node>
<node TEXT=" 等待“GLOBAL_ABORT”或“PREPARE_COMMIT”" ID="ID_1054550924" CREATED="1619665424349" MODIFIED="1619665440422">
<node TEXT=" 如果收到所有参与者的“PREPARE_COMMIT”确认消息，则进入DoCommit阶段" ID="ID_1090384947" CREATED="1619665413900" MODIFIED="1619665415095"/>
<node TEXT="等待超时" ID="ID_1301497625" CREATED="1619665282197" MODIFIED="1619665292736">
<node TEXT=" 等待并接收参与者发送的对“GLOBAL_ABORT”消息或“PREPARE_COMMIT”消息的确认响应消息" ID="ID_717314415" CREATED="1619665300933" MODIFIED="1619665302468"/>
<node TEXT=" 一旦收到所有参与者的“GLOBAL_ABORT”确认消息或者超时没有收到，写本地“END_TRANSACTION”日志流程结束，不再进入DoCommit阶段" ID="ID_1615288270" CREATED="1619665312036" MODIFIED="1619665404425"/>
</node>
</node>
</node>
<node TEXT="参与者协议流程" ID="ID_1090656549" CREATED="1619678301774" MODIFIED="1619678310865">
<node TEXT=" 锁资源，进行事务预提交" ID="ID_1416783742" CREATED="1619615320900" MODIFIED="1619677821666"/>
<node TEXT="回复协调者成功与否" ID="ID_836711403" CREATED="1619678370933" MODIFIED="1619678394233"/>
</node>
</node>
<node TEXT=" DoCommit阶段" ID="ID_1450139940" CREATED="1619615334253" MODIFIED="1619615336891">
<node TEXT="协调者流程" ID="ID_403313490" CREATED="1619665538715" MODIFIED="1619665546581">
<node TEXT=" 向所有参与者发送的“GLOBAL _COMMIT”消息" ID="ID_1727278372" CREATED="1619665551827" MODIFIED="1619665553132"/>
<node TEXT=" 等待并接收参与者发送的对 “GLOBAL_COMMIT”消息的确认响应消息" ID="ID_1861826291" CREATED="1619665560763" MODIFIED="1619665562442"/>
<node TEXT=" 一旦收到所有参与者的确认消息，写本地“END_TRANSACTION”日志流程结束" ID="ID_1703981997" CREATED="1619665571794" MODIFIED="1619665572675"/>
</node>
<node TEXT=" 在DoCommit阶段，如果参与者无法及时接收到来自协调者的GLOBAL_COMMIT请求时，会在等待超时之后，会继续进行事务的提交" ID="ID_1788191605" CREATED="1619665593708" MODIFIED="1619665595805"/>
<node TEXT="这里超时，会有可能出现状态不一致的情况" ID="ID_786097390" CREATED="1619665596179" MODIFIED="1619665625379"/>
</node>
</node>
<node TEXT=" 缺点" ID="ID_1342579550" CREATED="1626852725223" MODIFIED="1626852726175"/>
</node>
<node TEXT="如果二阶段、三阶段最后各参与者真正提交，回复协调者却是提交失败" ID="ID_1615207500" CREATED="1619679004541" MODIFIED="1619679067231"/>
<node TEXT="commit阶段失败" FOLDED="true" ID="ID_517966846" CREATED="1619679079404" MODIFIED="1619679093943">
<node TEXT="问题" ID="ID_1698444992" CREATED="1619679110548" MODIFIED="1619679113295">
<node TEXT=" 两段提交协议和三段提交协议之后，协调者会收到事务提交的结果" ID="ID_1000975062" CREATED="1619679098949" MODIFIED="1619679100068"/>
<node TEXT=" 那么，如果参与点有的提交成功，有的提交失败，协调者是怎么来保证数据的一致性问题的呢" ID="ID_25111252" CREATED="1619679108316" MODIFIED="1619679109319"/>
<node TEXT="协议并没有针对已提交的操作进行回滚的过程" ID="ID_795003890" CREATED="1619679289243" MODIFIED="1619679302527"/>
</node>
<node TEXT="出错可能性低" ID="ID_57079050" CREATED="1627020927683" MODIFIED="1627020932977">
<node TEXT="2pc的prepare阶段，已经将事务逻辑都做完了，并且写了redo log，只是目前redo log中的数据状态还是prepare状态" ID="ID_852875333" CREATED="1619679120404" MODIFIED="1619679142119"/>
<node TEXT=" 一旦协调者发送commit消息，后续就是将数据的prepare状态标记位修改为finished状态，这里一般认为不会出错，但还是有可能出错" ID="ID_1358660884" CREATED="1619679149427" MODIFIED="1619679217945"/>
<node TEXT=" commit阶段是有可能出错的，2pc和3pc只是尽量减少commit阶段出错的概率，但无法保证" ID="ID_1522596660" CREATED="1619679219237" MODIFIED="1619679230587"/>
</node>
<node TEXT=" 如果真的提交失败，整个系统会block住，需要人工介入。这也是为什么还需要引入Paxos算法的原因" ID="ID_515105270" CREATED="1619679239324" MODIFIED="1619679240603"/>
</node>
<node TEXT=" 补偿型事务（TCC事务）" ID="ID_210829533" CREATED="1620788654552" MODIFIED="1620789816186">
<node TEXT="概念" ID="ID_1594385070" CREATED="1623746738694" MODIFIED="1623746745458">
<node TEXT=" 对业务逻辑初步操作的调用仅是一个临时性操作，调用它的主业务服务保留了后续的取消权" ID="ID_745221357" CREATED="1624441624246" MODIFIED="1624441627964"/>
<node TEXT=" 基于 TCC 实现分布式事务，会将原来只需要一个接口就可以实现的逻辑拆分为 Try、Confirm、Cancel 三个接口，所以代码实现复杂度相对较高" ID="ID_1581229442" CREATED="1619422657095" MODIFIED="1619422658347"/>
<node TEXT=" TCC对应 Try、Confirm、Cancel 三种操作可以理解成关系型数据库事务的三种操作：DML、Commit、Rollback" ID="ID_718767305" CREATED="1622707214723" MODIFIED="1622707215599"/>
<node TEXT="  依赖于业务方来配合提供这样的接口，推行难度大，所以一般不推荐使用这种方式" ID="ID_1076837551" CREATED="1623746631695" MODIFIED="1623746632684"/>
</node>
<node TEXT=" 补偿性事务" ID="ID_333788373" CREATED="1620788763303" MODIFIED="1620788772434">
<node TEXT=" 补偿性事务就是一阶段的时候都直接递交" ID="ID_1140177657" CREATED="1620788772736" MODIFIED="1620788773977"/>
<node TEXT=" 这样一阶段都成功的话，二阶段可以快速返回" ID="ID_599790382" CREATED="1620788780814" MODIFIED="1620788781678"/>
<node TEXT=" 如一阶段有参与者失败，则再使用一条补偿操作，把一阶段的递交给补偿回来" ID="ID_91527166" CREATED="1620788788951" MODIFIED="1620788790085"/>
<node TEXT=" 针对每个操作都要注册一个与其对应的确认和补偿（撤销操作）" ID="ID_926640974" CREATED="1622707174979" MODIFIED="1622707176624"/>
</node>
<node TEXT=" 作为对比的二阶段递交流程" ID="ID_555689409" CREATED="1620788696447" MODIFIED="1620788714372">
<node TEXT="2pc" ID="ID_1988807007" CREATED="1622705845523" MODIFIED="1622705848390">
<node TEXT=" 2PC是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁" ID="ID_1449463169" CREATED="1622707301403" MODIFIED="1622707303129"/>
<node TEXT="  XA事务中的两阶段提交内部过程是对开发者屏蔽的，事务管理器在两阶段提交过程中，从prepare到commit/rollback过程中，资源实际上一直都是被加锁的" ID="ID_878743450" CREATED="1622707322179" MODIFIED="1622707323382"/>
<node TEXT="dml阶段先锁行" ID="ID_1113032766" CREATED="1620788724768" MODIFIED="1620788726168"/>
<node TEXT=" 一阶段写redo" ID="ID_1381437935" CREATED="1620788732815" MODIFIED="1620788733739"/>
<node TEXT=" 二阶段再做真递交+解锁行" ID="ID_1755548659" CREATED="1620788738167" MODIFIED="1620788738990"/>
<node TEXT=" 这种模型虽然保证了一致性，但非常慢，latency很大" ID="ID_393921434" CREATED="1620788742943" MODIFIED="1620788911685"/>
</node>
<node TEXT="tcc" ID="ID_1376308614" CREATED="1622705856419" MODIFIED="1622705857873">
<node TEXT="TCC是业务层面（非资源层）的分布式事务，最终一致性，不会一直持有资源的锁" ID="ID_260455280" CREATED="1622705862994" MODIFIED="1622707374111"/>
<node TEXT=" TCC中的两阶段提交并没有对开发者完全屏蔽，也就是说从代码层面，开发者是可以感受到两阶段提交的存在" ID="ID_60360016" CREATED="1622707418827" MODIFIED="1622707419622"/>
<node TEXT="没有单独的准务阶段，Try操作兼备资源操作与准备能力" ID="ID_1354215439" CREATED="1622705872939" MODIFIED="1622706715236"/>
<node TEXT="Try操作可以灵活选择业务资源的锁定粒度" ID="ID_1593617500" CREATED="1622706721928" MODIFIED="1622706742763"/>
<node TEXT=" 由于是多个独立的本地事务，因此不会对资源一直加锁，相对2PC性能会好很多" ID="ID_888599252" CREATED="1622707453338" MODIFIED="1622707513277"/>
<node TEXT="较高开发成本，需要改造try、confirm、canel3个接口" ID="ID_353297616" CREATED="1622706743000" MODIFIED="1622707494599"/>
</node>
</node>
<node TEXT="解决二段提交(XA)的几个缺点" ID="ID_230197658" CREATED="1619422023012" MODIFIED="1619422066723">
<node TEXT=" 解决了协调者单点" ID="ID_793978089" CREATED="1619422080499" MODIFIED="1619422081726">
<node TEXT=" 由主业务方发起并完成这个业务活动" ID="ID_1398661673" CREATED="1619422091043" MODIFIED="1619422092093"/>
<node TEXT=" 业务活动管理器也变成多点，引入集群" ID="ID_1170706942" CREATED="1619422095732" MODIFIED="1619422096938"/>
</node>
<node TEXT=" 同步阻塞" ID="ID_125289713" CREATED="1619422104076" MODIFIED="1619422105106">
<node TEXT=" 引入超时，超时后进行补偿，并且不会锁定整个资源" ID="ID_31380783" CREATED="1619422163619" MODIFIED="1619422164539"/>
<node TEXT=" 将资源转换为业务逻辑形式，粒度变小" ID="ID_374790936" CREATED="1619422167866" MODIFIED="1619422168818"/>
</node>
<node TEXT=" 数据一致性" ID="ID_992953727" CREATED="1619422175482" MODIFIED="1619422181615">
<node TEXT=" 有了补偿机制之后，由业务活动管理器控制一致性" ID="ID_1038014712" CREATED="1619422181970" MODIFIED="1619422183052"/>
</node>
</node>
<node TEXT="适用场景" ID="ID_1958613666" CREATED="1620789005110" MODIFIED="1620789011218">
<node TEXT=" 强隔离性，严格一致性要求的活动业务" ID="ID_513343344" CREATED="1623746968318" MODIFIED="1623746969581"/>
<node TEXT=" 执行时间较短的业务" ID="ID_592706308" CREATED="1623746970166" MODIFIED="1623746975592"/>
<node TEXT=" 余额型业务" ID="ID_941830361" CREATED="1620789012006" MODIFIED="1620789019434">
<node TEXT=" 余额型业务的业务特点非常适合补偿型的事务" ID="ID_1826384975" CREATED="1620789039925" MODIFIED="1620789050177"/>
<node TEXT="由于余额是一个数字的加减，这意味着，加减的顺序不影响最终值，可以牺牲一定的一致性" ID="ID_1978576700" CREATED="1620789019918" MODIFIED="1620789111394"/>
<node TEXT="协议" ID="ID_439207543" CREATED="1620789195413" MODIFIED="1620789211017">
<node TEXT="一阶段" ID="ID_1662674619" CREATED="1620789128365" MODIFIED="1620789132434">
<node TEXT=" 更新余额 update amount = amount - 消费金额" ID="ID_1449824765" CREATED="1620789140709" MODIFIED="1620789141834"/>
</node>
<node TEXT="二阶段" ID="ID_1437053885" CREATED="1620789144021" MODIFIED="1620789148034">
<node TEXT="成功就直接返回" ID="ID_1933346155" CREATED="1620789151901" MODIFIED="1620789162042"/>
<node TEXT="失败则补偿 update amount = amount + 消费金额" ID="ID_946291646" CREATED="1620789162206" MODIFIED="1620789176843"/>
</node>
</node>
<node TEXT=" 如果不想让使用者看到这个不一致的过程" ID="ID_1817872027" CREATED="1620789244821" MODIFIED="1620789247977">
<node TEXT=" 设置一个冻结金额表" ID="ID_1133125628" CREATED="1620789266645" MODIFIED="1620789267561"/>
<node TEXT=" 一阶段操作冻结金额的表" ID="ID_969839367" CREATED="1620789280804" MODIFIED="1620789292442"/>
<node TEXT=" 二阶段把冻结金额更新到余额上" ID="ID_1579398110" CREATED="1620789286148" MODIFIED="1620789287113"/>
</node>
<node TEXT=" 不想让余额被两个同时来的消费请求扣减为负数" ID="ID_429725868" CREATED="1620789305076" MODIFIED="1620789306342">
<node TEXT=" 让一阶段检查 余额 - sum(冻结金额），然后再产生一笔新的冻结金额" ID="ID_184048711" CREATED="1620789335788" MODIFIED="1620789336954"/>
</node>
</node>
<node TEXT=" 长事务（ long-running ）" ID="ID_1680605170" CREATED="1622705485128" MODIFIED="1622705491996">
<node TEXT="业务" ID="ID_1766032746" CREATED="1622705551823" MODIFIED="1622705557931">
<node TEXT=" 一个由两台服务器一起参与的事务，服务器A发起事务，服务器B参与事务" ID="ID_1327779263" CREATED="1622705501360" MODIFIED="1622705502673"/>
<node TEXT=" B的事务需要人工参与，所以处理时间可能很长" ID="ID_1266393883" CREATED="1622705509968" MODIFIED="1622705510997"/>
<node TEXT=" 会造成事务A中的资源被长时间锁定，系统的可用性将不可接受" ID="ID_1197946669" CREATED="1622705537823" MODIFIED="1622705539987"/>
</node>
<node TEXT=" 服务器A的事务如果执行顺利，那么事务A就先行提交，如果事务B也执行顺利，则事务B也提交，整个事务就算完成" ID="ID_477509353" CREATED="1622705564918" MODIFIED="1622705583474"/>
<node TEXT="  但是如果事务B执行失败，事务B本身回滚，这时事务A已经被提交，所以需要执行一个补偿操作，将已经提交的事务A执行的操作作反操作，恢复到未执行前事务A的状态" ID="ID_1778340952" CREATED="1622705599231" MODIFIED="1622705600641"/>
<node TEXT=" 牺牲了一定的隔离性和一致性的，但是提高了long-running事务的可用性" ID="ID_1726292935" CREATED="1622705611214" MODIFIED="1622705612503"/>
</node>
</node>
<node TEXT="三个阶段" ID="ID_58627295" CREATED="1619422192866" MODIFIED="1619422204020">
<node TEXT=" Try 阶段" ID="ID_281728245" CREATED="1619422208969" MODIFIED="1619422209850">
<node TEXT=" 尝试执行" ID="ID_287896909" CREATED="1619422233081" MODIFIED="1619422238580">
<node TEXT=" 完成所有业务检查（一致性）" ID="ID_1480537982" CREATED="1619422239057" MODIFIED="1619422246077"/>
<node TEXT="  预留必须业务资源（准隔离性）" ID="ID_303054259" CREATED="1619422246874" MODIFIED="1619422247862"/>
<node TEXT=" 从底层数据库资源层面的加锁过渡为上层业务层面的加锁，从而提高并发性能" ID="ID_925124693" CREATED="1625139758394" MODIFIED="1625139776595"/>
</node>
<node TEXT="例子" ID="ID_1822491511" CREATED="1619422545120" MODIFIED="1619422546850">
<node TEXT=" 比如订单和存储操作" ID="ID_1620301284" CREATED="1619422557687" MODIFIED="1619422559033"/>
<node TEXT=" 需要检查库存剩余数量是否够用" ID="ID_823228400" CREATED="1619422567007" MODIFIED="1619422567987"/>
<node TEXT=" 并进行预留，预留操作的话就是新建一个可用库存数量字段" ID="ID_696259291" CREATED="1619422574560" MODIFIED="1619422576075"/>
<node TEXT=" Try 阶段操作是对这个可用库存数量进行操作" ID="ID_515729202" CREATED="1619422631822" MODIFIED="1619422642707"/>
</node>
<node TEXT=" 要拒绝执行空回滚之后 Try 请求，要避免出现悬挂" ID="ID_954488665" CREATED="1622713840682" MODIFIED="1622713843438"/>
</node>
<node TEXT=" Confirm 阶段" ID="ID_1318801447" CREATED="1619422271194" MODIFIED="1619422272402">
<node TEXT=" 确认执行真正执行业务" ID="ID_1694561966" CREATED="1619422286506" MODIFIED="1619422293220"/>
<node TEXT=" 不作任何业务检查，只使用 Try 阶段预留的业务资源" ID="ID_1523079251" CREATED="1619422293634" MODIFIED="1619422294884"/>
<node TEXT=" Confirm 操作满足幂等性。要求具备幂等设计，Confirm 失败后需要进行重试" ID="ID_1337084313" CREATED="1619422308433" MODIFIED="1619422310173"/>
<node TEXT=" Try成功则默认Confirm会成功。如果Confirm失败(无论什么失败)，会依靠活动日志进行重试" ID="ID_1328401412" CREATED="1623746891206" MODIFIED="1623746940602"/>
<node TEXT="被调用时状态" ID="ID_812970922" CREATED="1624452571453" MODIFIED="1624452591793">
<node TEXT="如果事务表中没有相对应的Try记录，则是一个空提交，中止操作" ID="ID_878671689" CREATED="1624452428462" MODIFIED="1624452478414"/>
<node TEXT="如果Confirm执行完成，则是一个重复提交，直接返回成功" ID="ID_1666160389" CREATED="1624452483799" MODIFIED="1624452520171"/>
<node TEXT="如果记录的Try的状态是失败，却调到这里，是一个异常，要报警" ID="ID_1199594730" CREATED="1624452377942" MODIFIED="1624452419793"/>
<node TEXT="如果已回滚，去调到这里，也是一个异常" ID="ID_926544936" CREATED="1624452540237" MODIFIED="1624452559802"/>
</node>
</node>
<node TEXT=" Cancel 阶段" ID="ID_733779930" CREATED="1619422317089" MODIFIED="1619422318188">
<node TEXT=" 取消执行" ID="ID_186504368" CREATED="1619422347064" MODIFIED="1619422348085">
<node TEXT=" Cancel 操作满足幂等性" ID="ID_1986370863" CREATED="1619422383016" MODIFIED="1619422383904"/>
<node TEXT=" 释放 Try 阶段预留的业务资源" ID="ID_1141288934" CREATED="1619422361936" MODIFIED="1619422362951"/>
</node>
<node TEXT=" Cancel 阶段的异常和 Confirm 阶段异常处理方案基本上一致" ID="ID_1320390468" CREATED="1619422403832" MODIFIED="1619422404898"/>
<node TEXT=" 被调用时的状态" ID="ID_862503413" CREATED="1625140871257" MODIFIED="1625140880037">
<node TEXT=" 如果事务记录为空，则" ID="ID_1956513285" CREATED="1625140917121" MODIFIED="1625141105868"/>
<node TEXT="查调事务记录" ID="ID_1933899886" CREATED="1625141059871" MODIFIED="1625141065866">
<node TEXT="事务记录为空" ID="ID_1243507991" CREATED="1625141067406" MODIFIED="1625141139471">
<node TEXT=" 认为 Try 方法还没执行，即是空回滚" ID="ID_636047351" CREATED="1625141106821" MODIFIED="1625141107791"/>
<node TEXT=" 空回滚的情况先插入一条事务记录" ID="ID_402586770" CREATED="1625140936079" MODIFIED="1625140994460">
<node TEXT=" 插入成功" ID="ID_269191300" CREATED="1625141001520" MODIFIED="1625141002260">
<node TEXT=" Try 方法还没有执行，空回滚继续执行" ID="ID_533281605" CREATED="1625141007590" MODIFIED="1625141008468"/>
</node>
<node TEXT=" 插入失败" ID="ID_460936399" CREATED="1625141012233" MODIFIED="1625141013080">
<node TEXT=" Try 方法正在执行，等待 TC 的重试即可" ID="ID_475892738" CREATED="1625141020991" MODIFIED="1625141351047"/>
</node>
</node>
</node>
<node TEXT="事为记录不为空" ID="ID_1374575340" CREATED="1625141117678" MODIFIED="1625141132594">
<node TEXT=" Try 方法已经执行完毕" ID="ID_1994175134" CREATED="1625141158614" MODIFIED="1625141159514"/>
<node TEXT=" 然后检查状态" ID="ID_1433286272" CREATED="1625141165574" MODIFIED="1625141324993">
<node TEXT="初始化状态，即可正常回滚" ID="ID_673650216" CREATED="1625141167309" MODIFIED="1625141228305"/>
<node TEXT="回滚状态，即是重复调用，空回滚" ID="ID_1180611821" CREATED="1625141240029" MODIFIED="1625141276121"/>
<node TEXT="已提交状态，是一个异常" ID="ID_544868476" CREATED="1625141182981" MODIFIED="1625141301568"/>
</node>
</node>
</node>
</node>
</node>
</node>
<node TEXT="异常处理" ID="ID_1905371270" CREATED="1624450770070" MODIFIED="1624450776611">
<node ID="ID_425938801" CREATED="1624450786941" MODIFIED="1624450786941"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      空回滚
    </p>
  </body>
</html>
</richcontent>
<node TEXT=" 在没有调用 TCC 资源 Try 方法的情况下，调用了二阶段的 Cancel 方法" ID="ID_1077752732" CREATED="1624450817334" MODIFIED="1624450820283"/>
<node TEXT=" 调用方机器宕机、网络异常，都会造成调用Try失败" ID="ID_556492631" CREATED="1624450868741" MODIFIED="1624450900978"/>
<node TEXT=" Cancel 方法需要识别出这是一个空回滚，然后直接返回成功" ID="ID_958615754" CREATED="1624450826573" MODIFIED="1624450827683"/>
<node TEXT=" 需要一张额外的事务控制表，其中有分布式事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了" ID="ID_41014552" CREATED="1624450979317" MODIFIED="1624450980773"/>
</node>
<node ID="ID_1062084786" CREATED="1624450786941" MODIFIED="1624450786941"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      幂等
    </p>
  </body>
</html>
</richcontent>
<node TEXT="重复调用接口，与成功调用一次接口的效果是一样的" ID="ID_1122646374" CREATED="1625140407358" MODIFIED="1625140442182"/>
<node TEXT=" 在执行前状态，如果已执行，那就不再执行；否则，正常执行" ID="ID_209367135" CREATED="1624451043077" MODIFIED="1624451044113"/>
<node TEXT="也可以用事务控制表的加一个字段作为标识" ID="ID_638460812" CREATED="1624451061973" MODIFIED="1624451080344"/>
</node>
<node ID="ID_1730948452" CREATED="1624450786942" MODIFIED="1624450786942"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      悬挂
    </p>
  </body>
</html>
</richcontent>
<node TEXT=" 悬挂就是对于一个分布式事务，其二阶段 Cancel 接口比 Try 接口先执行，导致了预留业务资源却没法继续处理" ID="ID_270807977" CREATED="1624451844425" MODIFIED="1625140499484"/>
<node TEXT=" 因为允许空回滚的原因，Cancel 接口认为 Try 接口没执行，空回滚直接返回成功" ID="ID_279532616" CREATED="1624451860489" MODIFIED="1624451862580"/>
<node TEXT="防悬挂" ID="ID_1088525343" CREATED="1625140724042" MODIFIED="1625140731118">
<node TEXT=" 如果二阶段执行过(comfirm、cancel)，那一阶段就不能再继续执行" ID="ID_809838852" CREATED="1624451924887" MODIFIED="1625140707336"/>
<node TEXT=" 在二阶段执行时插入一条事务控制记录作为执行过的标记" ID="ID_312796131" CREATED="1625140764010" MODIFIED="1625140775310"/>
</node>
</node>
</node>
<node TEXT="例" ID="ID_913397951" CREATED="1624363729231" MODIFIED="1624363732794">
<node TEXT=" 账务系统模型设计" ID="ID_155644794" CREATED="1624363847966" MODIFIED="1624363848993">
<node TEXT="扣钱接口" ID="ID_1347196549" CREATED="1624363950876" MODIFIED="1624363958202">
<node TEXT=" 场景为 A 转账 30 元给 B。账户 A 的余额中有 100 元，需要扣除其中 30 元" ID="ID_626419817" CREATED="1624364355721" MODIFIED="1624364356747"/>
<node TEXT="Try" ID="ID_1237329787" CREATED="1624365546645" MODIFIED="1624442223099">
<node TEXT=" 余额就是所谓的业务资源" ID="ID_863427521" CREATED="1624365527204" MODIFIED="1624365562072"/>
<node TEXT=" 第一阶段要检查并预留余额，即扣除或冻结 30 元" ID="ID_75204354" CREATED="1624365562580" MODIFIED="1624450702873"/>
</node>
<node TEXT=" Confirm" ID="ID_420410978" CREATED="1624365653684" MODIFIED="1624365654616">
<node TEXT="如果Try 接口里扣除掉了，那么在第二阶段的 Confirm 接口里，可以什么都不用做" ID="ID_739656717" CREATED="1624365671747" MODIFIED="1625139915365"/>
<node TEXT="如果Try接口是冻结，则扣掉冰结金额" ID="ID_1105982174" CREATED="1625139916811" MODIFIED="1625139966352"/>
</node>
<node TEXT=" Cancel" ID="ID_1597203729" CREATED="1624365679748" MODIFIED="1624365680602">
<node TEXT=" 把 Try 接口里扣除掉或冻结的 30 元还给账户" ID="ID_664171707" CREATED="1624365690027" MODIFIED="1625139872980"/>
</node>
</node>
<node TEXT="加钱接口" ID="ID_667540604" CREATED="1624363958348" MODIFIED="1624363961674">
<node TEXT="Try" ID="ID_1048288477" CREATED="1624442121216" MODIFIED="1624442219320">
<node TEXT="这里不能直接给账户加钱，否则try之后就能直接使用了，后面难以回滚" ID="ID_1933892009" CREATED="1624442146407" MODIFIED="1624442185484"/>
<node TEXT=" 这里不需要预留任何资源，可以设计为空操作" ID="ID_1216511618" CREATED="1624442202648" MODIFIED="1624442206908"/>
</node>
<node TEXT="Confirm" ID="ID_19452455" CREATED="1624442208520" MODIFIED="1624442215348">
<node TEXT=" 真正加钱的动作" ID="ID_42553789" CREATED="1624442236182" MODIFIED="1624442237194"/>
</node>
<node TEXT="Cancel" ID="ID_610210937" CREATED="1624442257431" MODIFIED="1624442262755">
<node TEXT=" 因为try没预留资源，所以也没有资源需要释放" ID="ID_416665224" CREATED="1624442262966" MODIFIED="1624442294122"/>
<node TEXT=" 也是一个空操作" ID="ID_1300947252" CREATED="1624442294343" MODIFIED="1624442295822"/>
</node>
</node>
</node>
</node>
</node>
<node TEXT=" 本地消息表" ID="ID_1549154189" CREATED="1619421400322" MODIFIED="1619421402069">
<node TEXT="" ID="ID_1853218081" CREATED="1619424622612" MODIFIED="1619424626197">
<hook URI="事务_files/png_1043576693803063969.png" SIZE="0.5" NAME="ExternalObject"/>
</node>
<node TEXT="概念" ID="ID_1808732310" CREATED="1619424905522" MODIFIED="1619424908454">
<node TEXT=" 本地消息队列是BASE理论，是最终一致模型，需要注意重试的幂等" ID="ID_1545081490" CREATED="1623747459237" MODIFIED="1623747469119"/>
<node TEXT=" 此方案的核心是将需要分布式处理的任务通过消息日志的方式来异步执行" ID="ID_575872767" CREATED="1619424920625" MODIFIED="1619424921931"/>
<node TEXT=" 消息日志可以存储到本地文本、数据库或消息队列，再通过业务规则自动或人工发起重试" ID="ID_1216841008" CREATED="1619424928986" MODIFIED="1619424930110"/>
<node TEXT=" 人工重试更多的是应用于支付场景，通过对账系统对事后问题的处理" ID="ID_42254373" CREATED="1619424939538" MODIFIED="1619424940582"/>
<node TEXT=" 本地消息队列来说核心是把大事务转变为小事务" ID="ID_606042917" CREATED="1623747720924" MODIFIED="1623747721898"/>
<node TEXT=" 该方案中会有消息生产者与消费者两个角色，假设系统 A 是消息生产者，系统 B 是消息消费者" ID="ID_606990765" CREATED="1619424659411" MODIFIED="1619424660529"/>
</node>
<node TEXT="步骤流程" ID="ID_828727036" CREATED="1619424721243" MODIFIED="1619424734292">
<node TEXT="步骤1" ID="ID_1259526058" CREATED="1619424734595" MODIFIED="1619424738237">
<node TEXT=" 当系统 A 被其他系统调用发生数据库表更操作" ID="ID_1146962250" CREATED="1619424760676" MODIFIED="1619424761990"/>
<node TEXT="一个大事务的先行小事务" ID="ID_1827519454" CREATED="1623760724260" MODIFIED="1623760888745">
<node TEXT=" 首先会更新数据库的 业务表（更改）" ID="ID_1903356197" CREATED="1619424766499" MODIFIED="1623760758530"/>
<node TEXT=" 其次会往相同数据库的 消息表 中插入一条数据(记log)" ID="ID_1977384050" CREATED="1619424773716" MODIFIED="1623760766344"/>
<node TEXT=" 两个操作发生在同一个事务中" ID="ID_1419530402" CREATED="1619424781147" MODIFIED="1619424782467"/>
</node>
</node>
<node TEXT="步骤2" ID="ID_1147815331" CREATED="1619424734595" MODIFIED="1619424744938">
<node TEXT="把操作log找出来，丢进mq，让B消费" ID="ID_1693672564" CREATED="1623760785884" MODIFIED="1623760846311"/>
<node TEXT=" 系统 A 的脚本定期轮询本地消息往 mq 中写入一条消息" ID="ID_1878149480" CREATED="1619424805749" MODIFIED="1619424806657"/>
<node TEXT=" 如果消息发送失败会进行重试" ID="ID_1811362875" CREATED="1619424812171" MODIFIED="1619424814270"/>
</node>
<node TEXT="步骤3" ID="ID_1355250621" CREATED="1619424734595" MODIFIED="1619424746509">
<node TEXT=" 系统 B 消费 mq 中的消息，并处理业务逻辑" ID="ID_952306037" CREATED="1619424821594" MODIFIED="1619424822571"/>
<node TEXT=" 如果本地事务处理失败，会在继续消费 mq 中的消息进行重试" ID="ID_644210340" CREATED="1619424829698" MODIFIED="1619424832437"/>
<node TEXT=" 如果业务上的失败，可以通知系统 A 进行回滚操作" ID="ID_483317195" CREATED="1619424837818" MODIFIED="1619424838807"/>
</node>
</node>
<node TEXT=" 本地消息表实现的条件" ID="ID_723167099" CREATED="1619424671955" MODIFIED="1619424673705">
<node TEXT=" 消费者与生成者的接口都要支持幂等" ID="ID_222879228" CREATED="1619424677707" MODIFIED="1619424679416"/>
<node TEXT=" 生产者需要额外的创建消息表" ID="ID_1582320684" CREATED="1619424684324" MODIFIED="1619424685204"/>
<node TEXT=" 需要提供补偿逻辑，如果消费者业务失败，需要生产者支持回滚操作" ID="ID_779587393" CREATED="1619424690845" MODIFIED="1619424691858"/>
</node>
<node TEXT=" 容错机制" ID="ID_959409314" CREATED="1619424705875" MODIFIED="1619424706811">
<node TEXT=" 步骤 1 失败时，事务直接回滚" ID="ID_112551531" CREATED="1619424711163" MODIFIED="1619424712086"/>
<node TEXT=" 步骤 2、3 写 mq 与消费 mq 失败会进行重试" ID="ID_1026800046" CREATED="1619424717747" MODIFIED="1619424719603"/>
<node TEXT=" 步骤 3 业务失败系统 B 向系统 A 发起事务回滚操作" ID="ID_580157385" CREATED="1619424851310" MODIFIED="1619424853009"/>
</node>
</node>
<node TEXT="MQ事务" ID="ID_1471139472" CREATED="1623760935307" MODIFIED="1623760972327" VGAP_QUANTITY="6.8999999999999995 pt">
<node TEXT=" 在RocketMQ中实现了分布式事务" ID="ID_625576986" CREATED="1623760958604" MODIFIED="1623760981217"/>
<node TEXT=" 实际上其实是对本地消息表的一个封装，将本地消息表移动到了MQ内部" ID="ID_1144628195" CREATED="1623760966020" MODIFIED="1623760975601"/>
</node>
<node TEXT=" 可靠消息最终一致性" ID="ID_1949648372" CREATED="1619424945978" MODIFIED="1619424952852">
<node TEXT="" ID="ID_506179584" CREATED="1619424969887" MODIFIED="1619424975504">
<hook URI="事务_files/png_393479020034973701.png" SIZE="0.31962907" NAME="ExternalObject"/>
</node>
<node TEXT=" 流程" ID="ID_743168506" CREATED="1619436965514" MODIFIED="1619436972498">
<node TEXT=" A 系统先向 mq 发送一条 prepare 消息，如果 prepare 消息发送失败，则直接取消操作" ID="ID_982826977" CREATED="1619436985690" MODIFIED="1619436986834"/>
<node TEXT=" 如果消息发送成功，则执行本地事务" ID="ID_1110891749" CREATED="1619436994090" MODIFIED="1619436995739"/>
<node TEXT=" 如果本地事务执行成功，则想 mq 发送一条 confirm 消息，如果发送失败，则发送回滚消息" ID="ID_1905460165" CREATED="1619437008513" MODIFIED="1619437010191"/>
<node TEXT="B 系统定期消费 mq 中的 confirm 消息，执行本地事务，并发送 ack 消息。如果 B 系统中的本地事务失败，会一直不断重试，如果是业务失败，会向 A 系统发起回滚请求" ID="ID_403033106" CREATED="1619437034387" MODIFIED="1619437043860"/>
<node TEXT=" mq 会定期轮询所有 prepared 消息调用系统 A 提供的接口查询消息的处理情况，如果该 prepare 消息本地事务处理成功，则重新发送 confirm 消息，否则直接回滚该消息" ID="ID_1561993236" CREATED="1619437126073" MODIFIED="1619437127390"/>
</node>
<node TEXT=" 该方案与本地消息最大的不同是去掉了本地消息表" ID="ID_1958821854" CREATED="1619437145026" MODIFIED="1619437146133"/>
<node TEXT=" 目前市面上支持该方案的 mq 只有阿里的 rocketmq" ID="ID_438945042" CREATED="1619437380464" MODIFIED="1619437381823"/>
</node>
<node TEXT=" 尽最大努力通知" ID="ID_169815442" CREATED="1619436961596" MODIFIED="1619437165737">
<node TEXT=" 最大努力通知是最简单的一种柔性事务" ID="ID_501710106" CREATED="1619437210033" MODIFIED="1619437211213">
<node TEXT=" 适用于一些最终一致性时间敏感度低的业务" ID="ID_452100920" CREATED="1619437215823" MODIFIED="1619437216770"/>
<node TEXT=" 且被动方处理结果 不影响主动方的处理结果" ID="ID_1552457614" CREATED="1619437227712" MODIFIED="1619437234561"/>
</node>
<node TEXT="流程" ID="ID_709143989" CREATED="1619437261983" MODIFIED="1619437265633">
<node TEXT=" 系统 A 本地事务执行完之后，发送个消息到 MQ" ID="ID_1977271036" CREATED="1619437270464" MODIFIED="1619437271370"/>
<node TEXT=" 这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口" ID="ID_747577303" CREATED="1619437277321" MODIFIED="1619437278428"/>
<node TEXT=" 要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次，最后还是不行就放弃" ID="ID_37793368" CREATED="1619437293567" MODIFIED="1619437294924"/>
</node>
</node>
<node TEXT=" Paxos" ID="ID_902731742" CREATED="1619678841005" MODIFIED="1619678842527">
<node TEXT=" 解决了如何在一个分布式系统中，对某个value达成一致的问题" ID="ID_512015101" CREATED="1627286262355" MODIFIED="1627286271491"/>
<node TEXT=" Paxos是一种共识机制，用于保证分布式节点的一致性" ID="ID_523235069" CREATED="1626859367659" MODIFIED="1626859368946"/>
<node TEXT=" 二阶段、三阶段commit阶段是有可能出错的，会需要人工介入。Paxos可以解决这个问题" ID="ID_1339966527" CREATED="1626859248463" MODIFIED="1626859282754"/>
</node>
<node TEXT=" Raft" ID="ID_678428872" CREATED="1627284988531" MODIFIED="1627284989514">
<node TEXT=" 概念" ID="ID_1724961995" CREATED="1627285317894" MODIFIED="1627285420636">
<node TEXT=" Raft算法从多副本状态机的角度提出，用于管理多副本状态机的日志复制" ID="ID_1452524088" CREATED="1627285430654" MODIFIED="1627285436809"/>
<node TEXT=" 将一致性分解为多个子问题：Leader选举（Leader election）、日志同步（Log replication）、安全性（Safety）、日志压缩（Log compaction）、成员变更（Membership change）等" ID="ID_1220148383" CREATED="1627285450782" MODIFIED="1627285451851"/>
</node>
<node TEXT="角色" ID="ID_1913259933" CREATED="1627285295822" MODIFIED="1627285300030">
<node TEXT="" ID="ID_1375914393" CREATED="1627285465664" MODIFIED="1627285469460">
<hook URI="事务_files/png_7383291550872328475.png" SIZE="1.0" NAME="ExternalObject"/>
</node>
<node ID="ID_1150030137" CREATED="1627285317485" MODIFIED="1627285317485"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      领导者（Leader）
    </p>
  </body>
</html>
</richcontent>
<node TEXT="在任意一个term最多一个leader" ID="ID_945866429" CREATED="1627285528926" MODIFIED="1627286169837"/>
<node TEXT=" Leader在宕机之前会一直保持Leader的状态" ID="ID_1069024280" CREATED="1627285746540" MODIFIED="1627285747633"/>
<node TEXT="工作内容" ID="ID_1677859748" CREATED="1627285648356" MODIFIED="1627285651379">
<node TEXT=" 接受客户端请求，并向Follower同步请求日志" ID="ID_356572743" CREATED="1627285375877" MODIFIED="1627285381539"/>
<node TEXT=" 当日志同步到大多数节点上后告诉Follower提交日志" ID="ID_283184579" CREATED="1627285381758" MODIFIED="1627285384150"/>
</node>
</node>
<node ID="ID_710641840" CREATED="1627285317486" MODIFIED="1627285317486"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      跟从者（Follower）
    </p>
  </body>
</html>
</richcontent>
<node TEXT="工作内容" ID="ID_955937792" CREATED="1627285655581" MODIFIED="1627285659521">
<node TEXT=" 接受并持久化Leader同步的日志" ID="ID_981068808" CREATED="1627285391981" MODIFIED="1627285392958"/>
<node TEXT=" 在Leader告之日志可以提交之后，提交日志" ID="ID_1787972652" CREATED="1627285397781" MODIFIED="1627285398309"/>
</node>
<node TEXT=" 如果Follower超时没有收到Leader的消息，它会成为一个Candidate并且开始一次Leader选举" ID="ID_638627170" CREATED="1627285687476" MODIFIED="1627285689722"/>
<node TEXT="" ID="ID_1927905001" CREATED="1627285709781" MODIFIED="1627285709781"/>
</node>
<node ID="ID_986886082" CREATED="1627285317488" MODIFIED="1627285317488"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      候选人（Candidate）
    </p>
  </body>
</html>
</richcontent>
<node TEXT="正常工作期间没有这种角色" ID="ID_799871828" CREATED="1627285501332" MODIFIED="1627285518095"/>
<node TEXT=" Leader选举过程中的临时角色" ID="ID_1826093121" CREATED="1627285404053" MODIFIED="1627285405782"/>
<node TEXT=" 收到大多数服务器投票的Candidate会成为新的Leader" ID="ID_1136761969" CREATED="1627285712180" MODIFIED="1627285713476"/>
</node>
</node>
<node TEXT=" 任期（term）" ID="ID_123831581" CREATED="1628318294892" MODIFIED="1628318295944">
<node TEXT="" ID="ID_1037205159" CREATED="1628318327834" MODIFIED="1628318330934">
<hook URI="事务_files/png_8175717078351480414.png" SIZE="0.55756634" NAME="ExternalObject"/>
</node>
<node TEXT=" Raft算法将时间分为一个个的任期（term）" ID="ID_523303351" CREATED="1628318303506" MODIFIED="1628318304742"/>
<node TEXT=" 每一个term的开始都是Leader选举" ID="ID_1660308033" CREATED="1628318304882" MODIFIED="1628318309537"/>
<node TEXT=" 在成功选举Leader之后，Leader会在整个term内管理整个集群" ID="ID_1226178367" CREATED="1628318316058" MODIFIED="1628318316793"/>
<node TEXT=" 如果Leader选举失败，该term就会因为没有Leader而结束" ID="ID_1909420243" CREATED="1628318321595" MODIFIED="1628318322501"/>
</node>
<node TEXT="Leader选举" ID="ID_954550585" CREATED="1628318217171" MODIFIED="1628318347373">
<node TEXT="前提" ID="ID_1889256773" CREATED="1628318631379" MODIFIED="1628318635950">
<node TEXT=" Raft 使用心跳（heartbeat）触发Leader选举" ID="ID_1404860384" CREATED="1628318588170" MODIFIED="1628318590071"/>
<node TEXT=" 当服务器启动时，初始化为Follower" ID="ID_622230585" CREATED="1628318221106" MODIFIED="1628318397627"/>
<node TEXT=" Leader向所有Followers周期性发送heartbeat" ID="ID_520323205" CREATED="1628318597154" MODIFIED="1628318598086"/>
<node TEXT=" 如果Follower在选举超时时间内没有收到Leader的heartbeat，则认为Leader可能已经挂了，就会等待一段随机的时间后发起一次Leader选举" ID="ID_634769680" CREATED="1628318577939" MODIFIED="1628318745891"/>
</node>
<node TEXT=" Follower将其当前term加一然后转换为Candidate" ID="ID_1974374150" CREATED="1628318610458" MODIFIED="1628318612062"/>
<node TEXT=" 它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC" ID="ID_1076046999" CREATED="1628318657194" MODIFIED="1628318658149"/>
<node TEXT="投票情况" ID="ID_592684444" CREATED="1628318658482" MODIFIED="1628318664526">
<node TEXT=" 赢得了多数的选票，成功选举为Leader" ID="ID_672445333" CREATED="1628318670410" MODIFIED="1628318671410"/>
<node TEXT=" 收到了Leader的消息，表示有其它服务器已经抢先当选了Leader" ID="ID_842536348" CREATED="1628318690178" MODIFIED="1628318691214"/>
<node TEXT=" 没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举" ID="ID_1304391595" CREATED="1628318697564" MODIFIED="1628318699528"/>
</node>
</node>
</node>
</node>
</node>
</map>
