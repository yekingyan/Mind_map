<map version="freeplane 1.9.0">
<!--To view this file, download free mind mapping software Freeplane from http://freeplane.sourceforge.net -->
<node TEXT="操作系统" LOCALIZED_STYLE_REF="AutomaticLayout.level.root" FOLDED="false" ID="ID_1723255651" CREATED="1283093380553" MODIFIED="1640683881440" STYLE="bubble">
<font NAME="Noto Sans S Chinese Light" SIZE="14"/>
<hook NAME="MapStyle" zoom="1.077">
    <properties show_icon_for_attributes="true" fit_to_viewport="false" show_note_icons="true" edgeColorConfiguration="#808080ff,#ff0000ff,#0000ffff,#00ff00ff,#ff00ffff,#00ffffff,#7c0000ff,#00007cff,#007c00ff,#7c007cff,#007c7cff,#7c7c00ff"/>

<map_styles>
<stylenode LOCALIZED_TEXT="styles.root_node" STYLE="oval" UNIFORM_SHAPE="true" VGAP_QUANTITY="24 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="24"/>
<stylenode LOCALIZED_TEXT="styles.predefined" POSITION="right" STYLE="bubble" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
<stylenode LOCALIZED_TEXT="default" ID="ID_1194754533" ICON_SIZE="12 pt" COLOR="#000000" STYLE="combined" BORDER_WIDTH="3 px" MAX_WIDTH="10.1 cm" MIN_WIDTH="0 cm" VGAP_QUANTITY="6.9 pt">
<arrowlink SHAPE="CUBIC_CURVE" COLOR="#000000" WIDTH="2" TRANSPARENCY="200" DASH="" FONT_SIZE="9" FONT_FAMILY="SansSerif" DESTINATION="ID_1194754533" STARTARROW="NONE" ENDARROW="DEFAULT"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="false" ITALIC="false"/>
<edge STYLE="sharp_bezier" WIDTH="7"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.details" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.attributes" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.note" COLOR="#000000" BACKGROUND_COLOR="#ffffff" TEXT_ALIGN="LEFT" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.floating" VGAP_QUANTITY="6.9 pt">
<edge STYLE="hide_edge"/>
<cloud COLOR="#f0f0f0" SHAPE="ROUND_RECT"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="defaultstyle.selection" BACKGROUND_COLOR="#4e85f8" STYLE="bubble" BORDER_COLOR_LIKE_EDGE="false" BORDER_COLOR="#4e85f8"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.user-defined" POSITION="right" STYLE="bubble" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
<stylenode LOCALIZED_TEXT="styles.ok" VGAP_QUANTITY="6.9 pt">
<icon BUILTIN="button_ok"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.needs_action" VGAP_QUANTITY="6.9 pt">
<icon BUILTIN="messagebox_warning"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.floating_node" VGAP_QUANTITY="6.9 pt">
<edge STYLE="hide_edge"/>
<cloud COLOR="#f0f0f0" SHAPE="ROUND_RECT"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.topic" COLOR="#18898b" STYLE="fork" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="true"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.subtopic" COLOR="#cc3300" STYLE="fork" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="true"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.subsubtopic" COLOR="#669900" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="true"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.connection" COLOR="#606060" STYLE="fork" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="false"/>
<cloud COLOR="#f0f0f0" SHAPE="ROUND_RECT"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.important" COLOR="#ff0000" VGAP_QUANTITY="6.9 pt">
<icon BUILTIN="yes"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.question" VGAP_QUANTITY="6.9 pt">
<icon BUILTIN="help"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.key" COLOR="#996600" VGAP_QUANTITY="6.9 pt">
<icon BUILTIN="password"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="false"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.idea" VGAP_QUANTITY="6.9 pt">
<icon BUILTIN="idea"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.note" COLOR="#990000" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.date" COLOR="#0033ff" VGAP_QUANTITY="6.9 pt">
<icon BUILTIN="calendar"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.website" COLOR="#006633" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.list" COLOR="#cc6600" VGAP_QUANTITY="6.9 pt">
<icon BUILTIN="list"/>
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="true"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.quotation" COLOR="#338800" STYLE="fork" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="false" ITALIC="false"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.definition" COLOR="#666600" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="false"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.description" COLOR="#996600" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12" BOLD="false"/>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.pending" COLOR="#b3b95c" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode TEXT="代码" COLOR="#c0fdce" BACKGROUND_COLOR="#000000" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
</stylenode>
<stylenode LOCALIZED_TEXT="styles.AutomaticLayout" POSITION="right" STYLE="bubble" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level.root" COLOR="#000000" STYLE="oval" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
<edge COLOR="#003333"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,1" COLOR="#0033ff" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
<edge COLOR="#808080"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,2" COLOR="#003366" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
<edge COLOR="#808080"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,3" COLOR="#990000" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,4" COLOR="#111111" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,5" COLOR="#006666" VGAP_QUANTITY="6.9 pt">
<font NAME="Noto Sans S Chinese Light" SIZE="12"/>
</stylenode>
<stylenode LOCALIZED_TEXT="AutomaticLayout.level,6" VGAP_QUANTITY="6.9 pt">
<font SIZE="12"/>
</stylenode>
</stylenode>
</stylenode>
</map_styles>
</hook>
<hook NAME="AutomaticEdgeColor" COUNTER="109" RULE="ON_BRANCH_CREATION"/>
<hook NAME="accessories/plugins/AutomaticLayout.properties" VALUE="ALL"/>
<node TEXT=" 什么是 IO" FOLDED="true" POSITION="right" ID="ID_543134752" CREATED="1640683892853" MODIFIED="1640683893757">
<edge COLOR="#7c007c"/>
<node TEXT="在计算机操作系统中，所谓的I/O就是 输入（Input）和输出（Output），也可以理解为读（Read）和写（Write)" ID="ID_1576620118" CREATED="1640683907285" MODIFIED="1640683917011"/>
<node TEXT=" I/O模式可以划分为磁盘IO模型和网络IO模型" ID="ID_1953536355" CREATED="1640684077907" MODIFIED="1640684078904"/>
</node>
<node TEXT=" IO操作涉及到用户空间和内核空间转换的规则" FOLDED="true" POSITION="right" ID="ID_1299650973" CREATED="1640684098300" MODIFIED="1640684123271">
<edge COLOR="#007c7c"/>
<node TEXT="概念" ID="ID_1249658627" CREATED="1643101280995" MODIFIED="1643101285356">
<node TEXT=" 内存空间分为用户空间和内核空间，也称为用户缓冲区和内核缓冲区" ID="ID_1693855898" CREATED="1640684132444" MODIFIED="1640684133362"/>
<node TEXT=" 用户的应用程序不能直接操作内核空间，需要将数据从内核空间拷贝到用户空间才能使用" ID="ID_24967386" CREATED="1640684412761" MODIFIED="1640684413910"/>
<node TEXT=" 无论是read操作，还是write操作，都只能在内核空间里执行" ID="ID_1276042026" CREATED="1640744507448" MODIFIED="1640744508931"/>
<node TEXT=" 磁盘IO和网络IO请求加载到内存的数据都是先放在内核空间的" ID="ID_166394614" CREATED="1640744514325" MODIFIED="1640744516529"/>
</node>
<node TEXT=" 读操作（Read）" ID="ID_315183416" CREATED="1640744560461" MODIFIED="1640745490277">
<node TEXT="把内核空间的数据copy到用户空间，供用户的应用程序使用" ID="ID_1466691000" CREATED="1640744600861" MODIFIED="1640745249241"/>
<node TEXT="操作系统检查内核缓冲区没有需要的数据时" ID="ID_539389918" CREATED="1640744607828" MODIFIED="1640745278169">
<node TEXT=" 对于磁盘IO" ID="ID_1718216494" CREATED="1640744711379" MODIFIED="1640744729417">
<node ID="ID_755678005" CREATED="1640744720787" MODIFIED="1640744720787"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      直接从磁盘中读取到内核缓冲区
    </p>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1628474231" CREATED="1640744724823" MODIFIED="1640744724823"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <p>
      这个过程可以不需要cpu参与
    </p>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT=" 网络IO" ID="ID_1881342513" CREATED="1640744734723" MODIFIED="1640744735605">
<node TEXT=" 应用程序阻塞等待，直到收到客户端发送的数据" ID="ID_1739779207" CREATED="1640744898730" MODIFIED="1640744966090"/>
<node TEXT=" 从Socket协议找中读取客户端发送的数据到内核空间" ID="ID_1802204679" CREATED="1640744987865" MODIFIED="1640744989005"/>
</node>
</node>
</node>
<node TEXT=" 写操作（Write)" ID="ID_510426451" CREATED="1640744565012" MODIFIED="1640745488507">
<node TEXT=" 用户的应用程序将数据从用户空间copy到内核空间的缓冲区中" ID="ID_1915300894" CREATED="1640745224656" MODIFIED="1640745225940"/>
<node TEXT=" 如果用户空间没有相应的数据，则需要从磁盘—&gt;内核缓冲区—&gt;用户缓冲区依次读取" ID="ID_1158410285" CREATED="1640745405630" MODIFIED="1640745407882"/>
<node TEXT=" 这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘或通过网络发送出去，由操作系统决定" ID="ID_1701491256" CREATED="1640745422027" MODIFIED="1640745423248"/>
<node TEXT=" 除非应用程序显示地调用了sync 命令，立即把数据写入磁盘，或执行flush()方法，通过网络把数据发送出去" ID="ID_910724727" CREATED="1640745430879" MODIFIED="1640745431880"/>
</node>
</node>
<node TEXT=" 虚拟内存" FOLDED="true" POSITION="right" ID="ID_1238034870" CREATED="1640745593764" MODIFIED="1640745595658">
<edge COLOR="#ff00ff"/>
<node TEXT="概念" ID="ID_1185432077" CREATED="1640745839211" MODIFIED="1640745843053">
<node TEXT=" 虚拟内存是操作系统物理内存和进程之间的中间层" ID="ID_1433507413" CREATED="1640745856083" MODIFIED="1640745857272"/>
<node TEXT=" 映射物理内存碎片、外部磁盘存储器" ID="ID_1783870527" CREATED="1640747030509" MODIFIED="1640747038576"/>
<node TEXT=" 虚拟内存为进程隐藏了物理内存这一概念，为进程提供了更加简洁和易用的接口以及更加复杂的功能" ID="ID_157634849" CREATED="1640745865547" MODIFIED="1640745871709"/>
<node TEXT=" 虚拟内存使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间）" ID="ID_1558471565" CREATED="1640746488352" MODIFIED="1640747019111"/>
<node TEXT=" 进程持有的虚拟地址（Virtual Address）会经过内存管理单元（Memory Mangament Unit）的转换变成物理地址，然后再通过物理地址访问内存" ID="ID_1491358333" CREATED="1640745905202" MODIFIED="1640745914542"/>
</node>
<node TEXT=" 作用" ID="ID_880427839" CREATED="1640745970994" MODIFIED="1640746033256">
<node TEXT=" 利用内存起到缓存的作用" ID="ID_75536859" CREATED="1640746002714" MODIFIED="1640746353580">
<node TEXT=" 提高进程访问磁盘的速度" ID="ID_1621018002" CREATED="1640746353880" MODIFIED="1640746356527"/>
</node>
<node TEXT=" 为进程提供独立的内存空间" ID="ID_1162999483" CREATED="1640746012634" MODIFIED="1640746605785">
<node TEXT=" 简化程序的链接、加载过程并通过动态库共享内存" ID="ID_1270215751" CREATED="1640746606134" MODIFIED="1640746607949"/>
<node TEXT=" 使用这种技术使得大型程序的编写变得更容易" ID="ID_200935395" CREATED="1640746613912" MODIFIED="1640746614699"/>
<node TEXT=" 对真正的物理内存（例如RAM）的使用也更有效率" ID="ID_887709393" CREATED="1640746619279" MODIFIED="1640746620398"/>
</node>
<node TEXT=" 控制进程对物理内存的访问" ID="ID_1856021650" CREATED="1640746027994" MODIFIED="1640746635066">
<node TEXT=" 隔离不同进程的访问权限，提高系统的安全性" ID="ID_409170807" CREATED="1640746635430" MODIFIED="1640746636417"/>
<node TEXT=" 一个进程的崩溃不会影响其他的进程" ID="ID_901615857" CREATED="1640762494393" MODIFIED="1640762496121"/>
<node TEXT=" 恶意进程不能直接读取和修改其他进程运行时的代码和数据" ID="ID_234180880" CREATED="1640762525105" MODIFIED="1640762527882"/>
</node>
</node>
<node TEXT="" ID="ID_237622996" CREATED="1640746740999" MODIFIED="1640746740999"/>
</node>
<node TEXT=" 用户空间&amp;内核空间" FOLDED="true" POSITION="right" ID="ID_1035281072" CREATED="1640745503838" MODIFIED="1640745504792">
<edge COLOR="#00ff00"/>
<node TEXT="虚拟内存下的划分" ID="ID_786506201" CREATED="1640747769505" MODIFIED="1640747857611">
<node TEXT=" 虚拟内存被操作系统划分成两块：User Space（用户空间 和 Kernel Space（内核空间）" ID="ID_518438215" CREATED="1640745533085" MODIFIED="1640747290081"/>
<node TEXT=" 本质上电脑的物理内存是不划分这些的，只是操作系统开机启动后在逻辑上虚拟划分了地址和空间范围" ID="ID_957546597" CREATED="1640745552166" MODIFIED="1640745553869"/>
<node TEXT=" 操作系统会给每个进程分配一个独立的、连续的虚拟内存地址空间，32位为一般为4G" ID="ID_1599110427" CREATED="1640747403914" MODIFIED="1640747428349"/>
<node TEXT=" 其中将高地址值的内存空间分配给系统内核占用，Linux下占1G，Windows下占2G，其余的内存地址空间分配给用户进程使用" ID="ID_371163436" CREATED="1640747453251" MODIFIED="1640747469469"/>
</node>
<node TEXT="代码执行下的划分" ID="ID_634869530" CREATED="1640747784912" MODIFIED="1640747892410">
<node TEXT=" 内核空间 是操作系统 内核代码运行的地方，用户空间 是 用户程序代码运行的地方" ID="ID_862219217" CREATED="1640747889313" MODIFIED="1640747918675"/>
<node TEXT=" 当应用进程执行系统调用陷入内核代码中执行时就处于内核态" ID="ID_653743759" CREATED="1640747904642" MODIFIED="1640747905661"/>
<node TEXT=" 当应用进程在运行用户代码时就处于用户态" ID="ID_1845583657" CREATED="1640747910120" MODIFIED="1640747911634"/>
<node TEXT="内核空间可以执行任意的命令，" ID="ID_1238512904" CREATED="1640747939144" MODIFIED="1640747982440"/>
<node TEXT=" 用户空间只能执行简单的运算，不能直接调用系统资源和数据" ID="ID_1957763097" CREATED="1640747948633" MODIFIED="1640747967916"/>
</node>
</node>
<node TEXT="进程切换" FOLDED="true" POSITION="right" ID="ID_430099726" CREATED="1640762563074" MODIFIED="1640762568557">
<edge COLOR="#7c0000"/>
<node TEXT=" 重要的步骤" ID="ID_104510202" CREATED="1640762597592" MODIFIED="1640762598752">
<node TEXT="当一程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得 CPU 的控制权会从当前进程i转移到操作系统内核" ID="ID_863638062" CREATED="1640762632352" MODIFIED="1640762704866"/>
<node TEXT=" 操作系统内核负责保存进程 i 在 CPU 中的上下文（程序计数器， 寄存器）到 PCBi 中" ID="ID_992462291" CREATED="1640762673176" MODIFIED="1640762764092"/>
<node TEXT=" 从 PCBj 取出进程 j 的CPU 上下文， 将 CPU 控制权转移给进程 j ， 开始执行进程 j 的指令" ID="ID_1807024850" CREATED="1640762718136" MODIFIED="1640762719031"/>
</node>
<node TEXT="PCBi" ID="ID_344306731" CREATED="1640762727527" MODIFIED="1640762745987">
<node TEXT=" 操作系统分配给进程i的一个内存块" ID="ID_1200680093" CREATED="1640762752488" MODIFIED="1640762756663"/>
</node>
<node TEXT=" 中断（interrupt）" ID="ID_1559841546" CREATED="1640762774472" MODIFIED="1640762775398">
<node TEXT=" CPU 微处理器有一个中断信号位，决定是否去执行处理中断的指令" ID="ID_871456587" CREATED="1640762818335" MODIFIED="1640762842249"/>
<node TEXT=" 在每个CPU时钟周期的末尾, CPU会去检测那个中断信号位是否有中断信号到达" ID="ID_802188473" CREATED="1640762853686" MODIFIED="1640762855001"/>
</node>
<node TEXT=" 时钟中断( Clock Interrupt )" ID="ID_1896072158" CREATED="1640762865966" MODIFIED="1640762866791">
<node TEXT=" 一个硬件时钟会每隔一段（很短）的时间就产生一个中断信号发送给 CPU" ID="ID_1814034442" CREATED="1640762875095" MODIFIED="1640762876331"/>
<node TEXT=" CPU 在响应这个中断时， 就会去执行操作系统内核的指令，继而将 CPU 的控制权转移给了操作系统内核" ID="ID_1598423415" CREATED="1640762885695" MODIFIED="1640762903104"/>
<node TEXT=" 由操作系统内核决定下一个要被执行的指令" ID="ID_77495637" CREATED="1640762893285" MODIFIED="1640762912075"/>
</node>
<node TEXT=" 系统调用（system call）" ID="ID_321315611" CREATED="1640762919325" MODIFIED="1640762920088">
<node TEXT=" system call 是操作系统提供给应用程序的接口" ID="ID_1185439617" CREATED="1640762928341" MODIFIED="1640762929191"/>
<node TEXT="  用户通过调用 systemcall 来完成那些需要操作系统内核进行的操作" ID="ID_1395597316" CREATED="1640762939966" MODIFIED="1640762941428"/>
<node TEXT="例如硬盘， 网络接口设备向用户暴露的的读写接口等" ID="ID_480876928" CREATED="1640762958350" MODIFIED="1640762996407"/>
</node>
</node>
<node TEXT="IO模型" FOLDED="true" POSITION="right" ID="ID_153873116" CREATED="1640759565313" MODIFIED="1640759571563">
<edge COLOR="#00ffff"/>
<node TEXT="概念" ID="ID_1851004229" CREATED="1640759801684" MODIFIED="1640759804956">
<node TEXT=" 同步和异步的概念描述的是用户线程与内核的交互方式" ID="ID_1600039695" CREATED="1640759798348" MODIFIED="1640759799506"/>
<node TEXT=" 阻塞和非阻塞的概念描述的是用户线程调用内核IO操作的方式" ID="ID_369908075" CREATED="1640759814995" MODIFIED="1640759816289"/>
</node>
<node TEXT=" 进程间通信" ID="ID_1422870833" CREATED="1640762006199" MODIFIED="1640762007391">
<node TEXT="概念" ID="ID_1388878994" CREATED="1640762042388" MODIFIED="1640762045174">
<node TEXT=" 进程间的通信是通过 send() 和 receive() 两种基本操作完成的" ID="ID_421266503" CREATED="1640762022797" MODIFIED="1640762026320"/>
<node TEXT=" 消息的传递有可能是阻塞的或非阻塞的 – 也被称为同步或异步的" ID="ID_1878818868" CREATED="1640762040485" MODIFIED="1640762041465"/>
<node TEXT=" 从进程级通信的维度讨论时， 阻塞和同步（非阻塞和异步）就是一对同义词， 且需要针对发送方和接收方作区分对待" ID="ID_1433991330" CREATED="1640762187131" MODIFIED="1640762188918"/>
</node>
<node TEXT="通信传递类型" ID="ID_508876775" CREATED="1640766338213" MODIFIED="1640766367407">
<node TEXT=" 阻塞式发送（blocking send）" ID="ID_1353003994" CREATED="1640762048597" MODIFIED="1640762055716">
<node TEXT=" 发送方进程会被一直阻塞， 直到消息被接受方进程收到" ID="ID_1012154456" CREATED="1640762063501" MODIFIED="1640762065350"/>
</node>
<node TEXT=" 非阻塞式发送（nonblocking send）" ID="ID_1648563906" CREATED="1640762077308" MODIFIED="1640762078165">
<node TEXT="  发送方进程调用 send() 后， 立即就可以其他操作" ID="ID_758535559" CREATED="1640762083348" MODIFIED="1640762084841"/>
</node>
<node TEXT=" 阻塞式接收（blocking receive）" ID="ID_1605040989" CREATED="1640762091684" MODIFIED="1640762092550">
<node TEXT=" 接收方调用 receive() 后一直阻塞， 直到消息到达可用" ID="ID_952657991" CREATED="1640762098757" MODIFIED="1640762100246"/>
</node>
<node TEXT=" 非阻塞式接受（nonblocking receive）" ID="ID_529320820" CREATED="1640762141229" MODIFIED="1640762142110">
<node TEXT=" 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞" ID="ID_66143950" CREATED="1640762169356" MODIFIED="1640762170420"/>
</node>
</node>
</node>
<node TEXT="阻塞、非阻塞" ID="ID_226400244" CREATED="1641973219766" MODIFIED="1641973227983">
<node TEXT=" 阻塞" ID="ID_156591093" CREATED="1641971852317" MODIFIED="1641971856415">
<node TEXT="概念" ID="ID_600994780" CREATED="1641971905858" MODIFIED="1641971915432">
<node TEXT=" 程序未得到所需计算资源时被挂起的状态" ID="ID_845901294" CREATED="1641971863213" MODIFIED="1641971864172"/>
<node TEXT=" 当前线程会被挂起，CPU 执行权是交出去的" ID="ID_609723227" CREATED="1643177777747" MODIFIED="1643177781093"/>
<node TEXT=" 程序在等待某个操作完成期间，自身无法继续干别的事情，则称该程序在该操作上是阻塞的" ID="ID_1817351427" CREATED="1641971924909" MODIFIED="1641971925909"/>
</node>
<node TEXT=" 阻塞形式" ID="ID_1665741911" CREATED="1641971902741" MODIFIED="1641971903772">
<node TEXT=" 网络I/O阻塞、磁盘I/O阻塞、用户输入阻塞等" ID="ID_1180311113" CREATED="1641971933598" MODIFIED="1641971936803"/>
<node TEXT=" CPU切换上下文，当前核所有的进程都被阻塞" ID="ID_946482087" CREATED="1641971971228" MODIFIED="1641972192158"/>
</node>
</node>
<node TEXT=" 非阻塞" ID="ID_597112720" CREATED="1641972212459" MODIFIED="1641972213505">
<node TEXT="概念" ID="ID_1118168106" CREATED="1641972303379" MODIFIED="1643177841665" VGAP_QUANTITY="6.9 pt">
<node TEXT=" 该调用不会阻塞当前线程，线程不挂起作等待" ID="ID_1444949702" CREATED="1643177843929" MODIFIED="1643177880310"/>
<node TEXT=" 程序在等待某操作过程中，自身不被阻塞，可以继续运行干别的事情，则称该程序在该操作上是非阻塞的" ID="ID_815763261" CREATED="1641972305762" MODIFIED="1641972307225"/>
<node TEXT=" 非阻塞并不是在任何程序级别、任何情况下都可以存在的" ID="ID_977096304" CREATED="1641972323234" MODIFIED="1643177841662"/>
<node TEXT=" 非阻塞是为了提高程序整体执行效率" ID="ID_819565386" CREATED="1641974228970" MODIFIED="1641974231055"/>
</node>
<node TEXT="解决某些操作阻塞导致的耗时与效率低下" ID="ID_322928199" CREATED="1641973695725" MODIFIED="1641973707502"/>
</node>
</node>
<node TEXT="同步、异步" ID="ID_1224280780" CREATED="1641972819506" MODIFIED="1641972825857">
<node TEXT="通信方式" ID="ID_701432333" CREATED="1641972829848" MODIFIED="1641972834738">
<node TEXT="单线程下程序的执行是顺序的，本身就是同步的，无需同步信号" ID="ID_1647142376" CREATED="1641972907287" MODIFIED="1641972960195"/>
<node TEXT=" 通信方式指异步和并发编程提供的同步原语，如信号量、锁、同步队列等等" ID="ID_631052884" CREATED="1641972852984" MODIFIED="1641973146729"/>
</node>
<node TEXT="同步" ID="ID_1959175847" CREATED="1641972358171" MODIFIED="1641972360333">
<node TEXT="概念" ID="ID_196917101" CREATED="1641972430379" MODIFIED="1641972435243">
<node TEXT=" 同步意味着有序，连续的执行" ID="ID_290718618" CREATED="1641972536921" MODIFIED="1643178087749"/>
<node TEXT=" 不同程序单元执行过程中需靠某种通信方式以协调一致" ID="ID_825408077" CREATED="1641972435428" MODIFIED="1641972452974"/>
<node TEXT=" 如果在某程序的运行时，能根据已经执行的指令准确判断它接下来要进行哪个具体操作，那它是同步程序，反之则为异步程序。（无序与有序的区别）" ID="ID_143665638" CREATED="1641974415250" MODIFIED="1641974416600"/>
</node>
<node TEXT="例" ID="ID_1706494136" CREATED="1641972496234" MODIFIED="1641972499460">
<node TEXT=" 购物系统中更新商品库存。需要用“行锁”作为通信信号，让不同的更新请求强制排队顺序执行，那更新库存的操作是同步的" ID="ID_757961565" CREATED="1641972512026" MODIFIED="1641972527678"/>
</node>
</node>
<node TEXT="异步" ID="ID_1580466198" CREATED="1641972360699" MODIFIED="1641972363733">
<node TEXT="概念" ID="ID_1511703836" CREATED="1641972555522" MODIFIED="1641972558923">
<node TEXT=" 异步意味着无序，程序单元间执行顺序不可预料" ID="ID_979767785" CREATED="1641972803432" MODIFIED="1641974461949"/>
<node TEXT=" 异步是高效地组织非阻塞任务的方式" ID="ID_1899334709" CREATED="1641974240569" MODIFIED="1641974242048"/>
<node TEXT=" 不同程序单元之间过程中无需通信协调，也能完成任务的方式" ID="ID_16881100" CREATED="1641972559065" MODIFIED="1641972561005"/>
<node TEXT=" 不相关的程序单元之间可以是异步的" ID="ID_377540671" CREATED="1641972573137" MODIFIED="1641972574178"/>
</node>
<node TEXT="例" ID="ID_1361159958" CREATED="1641972593561" MODIFIED="1641972596852">
<node TEXT=" 爬虫下载网页。不同网页的下载、保存等操作都是无关的，也无需相互通知协调" ID="ID_1078275582" CREATED="1641972755378" MODIFIED="1641972778558"/>
</node>
</node>
<node TEXT="" ID="ID_1303947358" CREATED="1643177986952" MODIFIED="1643177986952">
<node TEXT="采用异步的问题" ID="ID_1842724717" CREATED="1641974668846" MODIFIED="1641974679485">
<node TEXT="如何拆分异步任务，每个异步任务耗时不能太长" ID="ID_926976573" CREATED="1641974722495" MODIFIED="1641974832489"/>
<node TEXT="用异步导致Callback，如何摆脱回调地狱" ID="ID_1721542242" CREATED="1641974760711" MODIFIED="1641974865957"/>
<node TEXT=" 同步代码改为异步代码，必然破坏代码结构" ID="ID_1905070313" CREATED="1641974888208" MODIFIED="1641974889360"/>
</node>
<node TEXT="多进程异步IO" ID="ID_1920680928" CREATED="1641975547797" MODIFIED="1641975945561">
<node TEXT="多进程模式有进程切换的开销" ID="ID_13390442" CREATED="1641975601931" MODIFIED="1641975612238">
<node TEXT=" CPU从一个进程切换到另一个进程，需要把旧进程运行时的寄存器状态、内存状态全部保存好，再将另一个进程之前保存的数据恢复" ID="ID_1919744584" CREATED="1641975650099" MODIFIED="1641975651059"/>
<node TEXT="当进程数量大于CPU核心数量时，进程切换是必然需要的" ID="ID_858674575" CREATED="1641975639291" MODIFIED="1641975654357"/>
</node>
<node TEXT=" 多进程模式占用较多内存资源，导致可支持的任务规模小" ID="ID_1877770971" CREATED="1641975696732" MODIFIED="1641975778639"/>
<node TEXT=" 多进程有难以状态共享的问题" ID="ID_1246767295" CREATED="1641975787708" MODIFIED="1641975813756"/>
</node>
<node TEXT="多线程异步IO" ID="ID_239259445" CREATED="1641975822763" MODIFIED="1641975953259">
<node TEXT=" 线程的数据结构比进程更轻量级" ID="ID_997974566" CREATED="1641975978466" MODIFIED="1641975979883"/>
<node TEXT=" Python因为GIL，多线程不能利用CPU多核优势" ID="ID_1713606146" CREATED="1641976008633" MODIFIED="1641976038059"/>
<node TEXT=" 多线程最主要的问题是竞态条件" ID="ID_1128127009" CREATED="1641976204704" MODIFIED="1641976211891">
<node TEXT="产生" ID="ID_1194945906" CREATED="1641976235545" MODIFIED="1641976264764">
<node TEXT=" 多线程是被OS调度，调度策略是抢占式的" ID="ID_1841522014" CREATED="1641976075067" MODIFIED="1641976112145"/>
<node TEXT=" 以保证同等优先级的线程都有均等的执行机会" ID="ID_990650864" CREATED="1641976112466" MODIFIED="1641976113740"/>
<node TEXT=" 并不知道下一时刻是哪个线程被运行，存在竞态条件" ID="ID_440020868" CREATED="1641976135744" MODIFIED="1641976152309"/>
</node>
<node TEXT="解决" ID="ID_619094460" CREATED="1641976266217" MODIFIED="1641976268475">
<node TEXT=" 需要用到“锁”或“同步队列”来处理竞态条件" ID="ID_501675114" CREATED="1641976172024" MODIFIED="1641976187508"/>
</node>
</node>
</node>
</node>
</node>
<node TEXT=" 进程阻塞" ID="ID_201279490" CREATED="1640766321109" MODIFIED="1640766327638">
<node TEXT=" 阻塞和非阻塞描述的是进程的一个操作是否会使得进程转变为“等待”的状态" ID="ID_443259156" CREATED="1640767447175" MODIFIED="1640767448666"/>
<node TEXT=" 进程在发起了一个系统调用（System Call），进程需要等待内核一段时间" ID="ID_746016220" CREATED="1640767081634" MODIFIED="1640767143323"/>
<node TEXT=" 内核将进程挂起为等待 （waiting）状态， 以确保它不会被调度执行， 占用 CPU 资源" ID="ID_797618759" CREATED="1640767159681" MODIFIED="1640767160878"/>
<node TEXT=" 在任意时刻， 一个 CPU 核心上（processor）只可能运行一个进程" ID="ID_797713246" CREATED="1640767174025" MODIFIED="1640767175168"/>
</node>
<node TEXT="同步阻塞IO（Blocking IO）" ID="ID_4945716" CREATED="1640759572105" MODIFIED="1640759595453">
<node TEXT=" 传统的IO模型" ID="ID_1578119101" CREATED="1640759599393" MODIFIED="1640759602082"/>
<node TEXT="用户线程通过系统调用read发起IO读操作，由用户空间转到内核空间" ID="ID_770478278" CREATED="1640759851131" MODIFIED="1640759953552"/>
<node TEXT=" 内核在等待数据的时候将用户线程挂起造成阻塞" ID="ID_248025866" CREATED="1640759964856" MODIFIED="1640759965789"/>
<node TEXT=" 内核等到数据包到达后，然后将接收的数据拷贝到用户空间，完成read操作" ID="ID_1929110910" CREATED="1640759984895" MODIFIED="1640759986419"/>
<node TEXT="" ID="ID_1043077452" CREATED="1640759860883" MODIFIED="1640759864650">
<hook URI="操作系统_files/png_8063638567024305769.png" SIZE="0.5789858" NAME="ExternalObject"/>
</node>
</node>
<node TEXT=" 同步非阻塞IO（Non-blocking IO）" ID="ID_1379918972" CREATED="1640759607791" MODIFIED="1640759608577">
<node TEXT=" 同步非阻塞IO是在同步阻塞IO的基础上，将原本阻塞的线程改成轮循内核获取结果" ID="ID_810702517" CREATED="1640760036319" MODIFIED="1643179204196"/>
<node TEXT="" ID="ID_18486028" CREATED="1640760047793" MODIFIED="1640760050645">
<hook URI="操作系统_files/png_6474831845753550503.png" SIZE="0.708314" NAME="ExternalObject"/>
</node>
<node TEXT="流程" ID="ID_975017560" CREATED="1640760286938" MODIFIED="1640760710501">
<node TEXT="用户线程发起IO请求时立即返回，返回的是可能是一个code码代表数据正在处理中" ID="ID_1472961711" CREATED="1643178930765" MODIFIED="1643178940599"/>
<node TEXT="此时线程一直循环轮询发送IO请求，直到数据在内核准备完毕才真正获取数据" ID="ID_1308696448" CREATED="1640760100510" MODIFIED="1640760194751"/>
<node TEXT=" 非阻塞表示，线程轮询一直请求内核占用内核时间片而不被挂起的状态" ID="ID_43253876" CREATED="1640760216508" MODIFIED="1640760249200"/>
</node>
<node TEXT="优缺点" ID="ID_894379110" CREATED="1640760293746" MODIFIED="1640760296971">
<node TEXT=" 效率上节省了取消用户线程挂起的资源消耗，但也伴随着大量CPU运算" ID="ID_1529436220" CREATED="1640760263098" MODIFIED="1640760264297"/>
<node TEXT=" 对用户来讲可能比较快的接收到请求的数据" ID="ID_1724327286" CREATED="1640760269907" MODIFIED="1640760270978"/>
<node TEXT=" 对同步阻塞由内核通知结果过来改成自己不断轮循获取结果，没想到应用场景，感觉有点蠢" ID="ID_1572801389" CREATED="1643178976506" MODIFIED="1643179146189"/>
</node>
</node>
<node TEXT=" 异步阻塞IO" ID="ID_865358672" CREATED="1640759665430" MODIFIED="1640759668232">
<node TEXT="概念" ID="ID_1653264736" CREATED="1643179390710" MODIFIED="1643179392970">
<node TEXT=" IO多路复用（IO Multiplexing），Linux中的epoll都是这种模型" ID="ID_895321564" CREATED="1640759678007" MODIFIED="1640760369066"/>
<node TEXT=" 建立在内核提供的多路分离函数select基础之上的" ID="ID_1603029898" CREATED="1640759687478" MODIFIED="1640760392147"/>
<node TEXT=" 避免同步非阻塞IO模型中轮询等待的问题" ID="ID_639327851" CREATED="1640760392440" MODIFIED="1640760393863"/>
<node TEXT=" 事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据" ID="ID_345262352" CREATED="1640761260630" MODIFIED="1640761261847"/>
</node>
<node TEXT="" ID="ID_1811492237" CREATED="1640760404357" MODIFIED="1640760408098">
<hook URI="操作系统_files/png_549591563675901483.png" SIZE="0.8270165" NAME="ExternalObject"/>
</node>
<node TEXT=" 流程" ID="ID_710608647" CREATED="1640760690388" MODIFIED="1640760714958">
<node TEXT=" 用户首先将需要进行IO操作的socket添加到select中，然后阻塞等待select系统调用返回" ID="ID_1265845571" CREATED="1640760727917" MODIFIED="1640760728993"/>
<node TEXT=" 当数据到达时，socket被激活，select函数返回" ID="ID_1116335610" CREATED="1640760750795" MODIFIED="1640760751933"/>
<node TEXT=" 用户线程正式发起read请求，读取数据并继续执行" ID="ID_83953898" CREATED="1640760771539" MODIFIED="1640760772489"/>
</node>
<node TEXT="对比同步阻塞模型" ID="ID_1027086127" CREATED="1640760787972" MODIFIED="1640760801980">
<node TEXT="流程上与同步阻塞模型没有太大的区别" ID="ID_770467744" CREATED="1640760837602" MODIFIED="1640760844193"/>
<node TEXT=" 多了添加监视socket，以及调用select函数的额外操作，平均时间更长，但提升了cpu利用率" ID="ID_1547071491" CREATED="1640760819282" MODIFIED="1640761177767"/>
<node TEXT=" 使用select以后最大的优势是用户可以在一个线程内同时处理多个socket的IO请求" ID="ID_1832854019" CREATED="1640760855330" MODIFIED="1640760856491"/>
<node TEXT=" 在同步阻塞模型中，必须通过多线程的方式才能处理多个socket的IO请求" ID="ID_1390699181" CREATED="1640761031232" MODIFIED="1640761042991"/>
</node>
<node TEXT="对比线程池" ID="ID_1587361346" CREATED="1640833067495" MODIFIED="1640833075096">
<node TEXT=" 多线程+池模型指的是每个线程处理一个IO流" ID="ID_379527498" CREATED="1640833075273" MODIFIED="1640833086454"/>
<node TEXT="多线程适用于计算多于IO的情况。可以充分利用CPU或者显卡的核心多干活" ID="ID_798228508" CREATED="1640833857901" MODIFIED="1640833922585"/>
<node TEXT="IO多路复用指的是同一个进(线)程可以处理多个IO流" ID="ID_1611988532" CREATED="1640833088073" MODIFIED="1640833118788"/>
<node TEXT=" IO多路复用的优势在于，当处理的消耗对比IO几乎可以忽略不计时，可以处理大量的并发IO，而不用消耗太多CPU/内存" ID="ID_1337380518" CREATED="1640833823999" MODIFIED="1640833825361"/>
</node>
</node>
<node TEXT=" 异步非阻塞IO" ID="ID_1870573489" CREATED="1640759704614" MODIFIED="1640759705423">
<node TEXT="概念" ID="ID_1954553256" CREATED="1643179562660" MODIFIED="1643179567627">
<node TEXT=" 异步IO（Asynchronous IO），经典的Proactor设计模式" ID="ID_743229479" CREATED="1640759694966" MODIFIED="1640761195926"/>
<node TEXT=" 相比于IO多路复用模型，异步IO并不十分常用" ID="ID_434576831" CREATED="1640759714189" MODIFIED="1640761231029"/>
<node TEXT=" 不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求" ID="ID_1847879277" CREATED="1640761238828" MODIFIED="1640761239631"/>
</node>
<node TEXT="" ID="ID_874214066" CREATED="1640761324218" MODIFIED="1640761326710">
<hook URI="操作系统_files/png_3281825029582980908.png" SIZE="0.5984048" NAME="ExternalObject"/>
</node>
</node>
</node>
<node TEXT="epoll" POSITION="right" ID="ID_31141099" CREATED="1641976520776" MODIFIED="1641976525523">
<edge COLOR="#00007c"/>
<node TEXT=" OS将I/O状态的变化都封装成了事件，如可读事件、可写事件" ID="ID_1159671992" CREATED="1641976567782" MODIFIED="1641976568943"/>
<node TEXT="通过系统模块让应用程序可以接收事件通知，如select、poll、kqueue、epoll" ID="ID_1756913871" CREATED="1641976585895" MODIFIED="1641976811281"/>
<node TEXT=" 当文件描述符的状态发生变化时，就调用事先注册的回调函数" ID="ID_1324982341" CREATED="1641976613903" MODIFIED="1641976646812"/>
</node>
<node TEXT=" 异步处理的回调函数问题" FOLDED="true" POSITION="right" ID="ID_1328649263" CREATED="1642768610677" MODIFIED="1642829771346">
<edge COLOR="#7c007c"/>
<node TEXT=" py 单线程内同时并发执行多个网络I/O阻塞型任务" FOLDED="true" ID="ID_345187983" CREATED="1641976679896" MODIFIED="1642830486844">
<node TEXT=" 异步编程，就是“事件循环+回调”的模式" ID="ID_1324497380" CREATED="1642768468960" MODIFIED="1642768481686"/>
<node TEXT="selectors实现非阻塞socket" ID="ID_652788126" CREATED="1642768437663" MODIFIED="1642768556504"/>
<node ID="ID_907629840" CREATED="1642766603795" MODIFIED="1642766671858"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <div style="color: rgb(212, 212, 212); background-color: rgb(30, 30, 30); font-family: Consolas, Courier New, monospace; font-size: 14px; line-height: 19px; white-space: pre">
      <div>
        <font color="#c586c0">import</font>&nbsp;socket
      </div>
      <div>
        <font color="#c586c0">from</font>&nbsp;selectors <font color="#c586c0">import</font>&nbsp;EVENT_READ, EVENT_WRITE, DefaultSelector
      </div>
      <div>
        Selector = DefaultSelector()
      </div>
      <div>
        <font color="#569cd6">class</font>&nbsp;<font color="#4ec9b0">AsyncRequest</font>(<font color="#4ec9b0">object</font>):
      </div>
      <div>
        &nbsp;&nbsp;&nbsp; <font color="#569cd6">def</font>&nbsp;<font color="#dcdcaa">__init__</font>(<font color="#9cdcfe">self</font>, <font color="#9cdcfe">szUrl</font>, <font color="#9cdcfe">callback</font>):
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#569cd6">self</font>.szUrl = szUrl
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#569cd6">self</font>.callback = callback
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#569cd6">self</font>.Sock = <font color="#569cd6">None</font>
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#569cd6">self</font>.response = b<font color="#ce9178">&quot;&quot;</font>
      </div>
      <br/>
      

      <div>
        &nbsp;&nbsp;&nbsp; <font color="#569cd6">def</font>&nbsp;<font color="#dcdcaa">Fetch</font>(<font color="#9cdcfe">self</font>):
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#569cd6">self</font>.Sock = socket.socket()
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#569cd6">self</font>.Sock.setblocking(<font color="#569cd6">False</font>)
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#c586c0">try</font>:
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#569cd6">self</font>.Sock.connect((<font color="#ce9178">&quot;localhost&quot;</font>, <font color="#b5cea8">5000</font>))
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#c586c0">except</font>&nbsp;<font color="#4ec9b0">BlockingIOError</font>:
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#c586c0">pass</font>
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selector.register(<font color="#569cd6">self</font>.Sock.fileno(), EVENT_WRITE, <font color="#569cd6">self</font>.OnConnected)
      </div>
      <br/>
      

      <div>
        &nbsp;&nbsp;&nbsp; <font color="#569cd6">def</font>&nbsp;<font color="#dcdcaa">OnConnected</font>(<font color="#9cdcfe">self</font>, <font color="#9cdcfe">Key</font>, <font color="#9cdcfe">Mask</font>):
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selector.unregister(Key)
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#569cd6">self</font>.Sock.send(f<font color="#ce9178">&quot;GET </font><font color="#9cdcfe">{self.szUrl}</font><font color="#ce9178">&nbsp;&nbsp;HTTP/1.0</font><font color="#d7ba7d">\r\n\r\n</font><font color="#ce9178">&quot;</font>.encode(<font color="#ce9178">&quot;utf-8&quot;</font>))
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selector.register(Key, EVENT_READ, <font color="#569cd6">self</font>.OnReadResponse)
      </div>
      <br/>
      

      <div>
        &nbsp;&nbsp;&nbsp; <font color="#569cd6">def</font>&nbsp;<font color="#dcdcaa">OnReadResponse</font>(<font color="#9cdcfe">self</font>, <font color="#9cdcfe">Key</font>, <font color="#9cdcfe">Mask</font>):
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;chunk = <font color="#569cd6">self</font>.Sock.recv(<font color="#b5cea8">4096</font>)
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#c586c0">if</font>&nbsp;chunk:
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#569cd6">self</font>.response += chunk
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#c586c0">else</font>:
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selector.unregister(Key)
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#569cd6">self</font>.callback(<font color="#569cd6">self</font>.response)
      </div>
      <br/>
    </div>
  </body>
</html>
</richcontent>
</node>
<node ID="ID_1662866083" CREATED="1642766903786" MODIFIED="1642766926231"><richcontent TYPE="NODE">

<html>
  <head>
    
  </head>
  <body>
    <div style="color: rgb(212, 212, 212); background-color: rgb(30, 30, 30); font-family: Consolas, Courier New, monospace; font-size: 14px; line-height: 19px; white-space: pre">
      <div>
        <font color="#569cd6">def</font>&nbsp;<font color="#dcdcaa">main</font>():
      </div>
      <div>
        &nbsp;&nbsp;&nbsp; <font color="#9cdcfe">listRes</font>&nbsp;= []
      </div>
      <div>
        &nbsp;&nbsp;&nbsp; <font color="#569cd6">def</font>&nbsp;<font color="#dcdcaa">req</font>(<font color="#9cdcfe">url</font>):
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#569cd6">def</font>&nbsp;<font color="#dcdcaa">response</font>(<font color="#9cdcfe">res</font>):
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;log.info(f<font color="#ce9178">&quot;ulr: </font><font color="#9cdcfe">{url}</font><font color="#ce9178">&nbsp;res:</font><font color="#9cdcfe">{res}</font><font color="#ce9178">&quot;</font>)
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#9cdcfe">listRes</font>.<font color="#dcdcaa">append</font>((<font color="#9cdcfe">url</font>, <font color="#9cdcfe">res</font>))
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#dcdcaa">print</font>(<font color="#ce9178">&quot;req&quot;</font>, <font color="#9cdcfe">url</font>)
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#4ec9b0">AsyncRequest</font>(<font color="#9cdcfe">url</font>, <font color="#dcdcaa">response</font>).<font color="#dcdcaa">Fetch</font>()
      </div>
      <br/>
      

      <div>
        &nbsp;&nbsp;&nbsp; <font color="#9cdcfe">n</font>&nbsp;= <font color="#b5cea8">10</font>
      </div>
      <div>
        &nbsp;&nbsp;&nbsp; <font color="#c586c0">for</font>&nbsp;<font color="#9cdcfe">i</font>&nbsp;<font color="#569cd6">in</font>&nbsp;<font color="#4ec9b0">range</font>(<font color="#b5cea8">1</font>, <font color="#9cdcfe">n</font>+<font color="#b5cea8">1</font>):
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#dcdcaa">req</font>(f<font color="#ce9178">&quot;/t/</font><font color="#9cdcfe">{i}</font><font color="#ce9178">&quot;</font>)
      </div>
      <br/>
      

      <div>
        &nbsp;&nbsp;&nbsp; <font color="#c586c0">while</font>&nbsp;<font color="#dcdcaa">len</font>(<font color="#9cdcfe">listRes</font>) &lt; <font color="#9cdcfe">n</font>:
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#9cdcfe">events</font>&nbsp;= <font color="#9cdcfe">Selector</font>.<font color="#dcdcaa">select</font>()
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#c586c0">for</font>&nbsp;<font color="#9cdcfe">key</font>, <font color="#9cdcfe">mask</font>&nbsp; <font color="#569cd6">in</font>&nbsp;<font color="#9cdcfe">events</font>:
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#9cdcfe">cb</font>&nbsp;&nbsp;= <font color="#9cdcfe">key</font>.<font color="#9cdcfe">data</font>
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#9cdcfe">cb</font>(<font color="#9cdcfe">key</font>.<font color="#9cdcfe">fileobj</font>, <font color="#9cdcfe">mask</font>)
      </div>
      <br/>
      

      <div>
        &nbsp;&nbsp;&nbsp; <font color="#c586c0">for</font>&nbsp;<font color="#9cdcfe">j</font>&nbsp;<font color="#569cd6">in</font>&nbsp;<font color="#9cdcfe">listRes</font>:
      </div>
      <div>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <font color="#dcdcaa">print</font>(<font color="#9cdcfe">j</font>)
      </div>
    </div>
  </body>
</html>
</richcontent>
</node>
</node>
<node TEXT="问题" ID="ID_587014875" CREATED="1642830258835" MODIFIED="1642830265534">
<node TEXT="风格问题" ID="ID_922861728" CREATED="1642830291626" MODIFIED="1642830298670">
<node TEXT=" callback hell" ID="ID_295986514" CREATED="1642829774979" MODIFIED="1642829780179">
<node TEXT=" 回调层次过多时代码可读性差，流程不清晰" ID="ID_304910469" CREATED="1642829793519" MODIFIED="1642829963129"/>
<node TEXT=" 破坏代码结构，自上而下的执行顺序因为异步需要以callback的方式传递" ID="ID_565827390" CREATED="1642829852304" MODIFIED="1642829932338"/>
</node>
</node>
<node TEXT="主要问题" ID="ID_310783153" CREATED="1642830269098" MODIFIED="1642830304941">
<node TEXT=" 共享状态管理困难" ID="ID_966196710" CREATED="1642829972782" MODIFIED="1642829973763">
<node TEXT=" 如果不是采用OOP的编程风格，那需要把要共享的状态接力似的传递给每一个回调" ID="ID_1901783008" CREATED="1642829994581" MODIFIED="1642829995709"/>
<node TEXT=" 多个异步调用之间，到底要共享哪些状态，事先就得考虑清楚，精心设计" ID="ID_1730247904" CREATED="1642830005294" MODIFIED="1642830006492"/>
</node>
<node TEXT=" 错误处理困难" ID="ID_373685812" CREATED="1642830023317" MODIFIED="1642830024163">
<node TEXT=" 调用栈撕裂" ID="ID_500184606" CREATED="1642830053973" MODIFIED="1642830054791">
<node TEXT=" 一连串的回调构成一个完整的调用链" ID="ID_386688845" CREATED="1642830038014" MODIFIED="1642830039014"/>
<node TEXT="调用链中间抛出异常，导致调用链中断，接力传递的状态也会丢失，从而使后面的调用函数都出现异常" ID="ID_662094941" CREATED="1642830057660" MODIFIED="1642830183809"/>
</node>
<node TEXT=" 防止栈撕裂" ID="ID_288658947" CREATED="1642830192755" MODIFIED="1642830193513">
<node TEXT=" 异常必须以数据的形式返回，而不是直接抛出异常" ID="ID_807380383" CREATED="1642830208388" MODIFIED="1642830209587"/>
<node TEXT=" 然后每个回调中需要检查上次调用的返回值，以防错误吞没" ID="ID_1670854313" CREATED="1642830218315" MODIFIED="1642830219542"/>
</node>
</node>
</node>
</node>
<node TEXT="解决方案" ID="ID_1311638237" CREATED="1642830241524" MODIFIED="1642830318853">
<node TEXT="问题" ID="ID_482043941" CREATED="1642830962013" MODIFIED="1642830984729">
<node TEXT=" 栈撕裂和状态管理困难这两个缺点会让基于回调的异步编程很艰难" ID="ID_1700318906" CREATED="1642830335507" MODIFIED="1642830336522"/>
<node TEXT=" 程序得知道当前所处的状态，而且要将这个状态在不同的回调之间延续下去" ID="ID_1345630083" CREATED="1642830957013" MODIFIED="1642830959896"/>
</node>
<node TEXT="链式调用会有栈撕裂的困难，让回调之间不再链式调用" ID="ID_621110555" CREATED="1642831030853" MODIFIED="1642831043619"/>
<node TEXT=" 协程，协作式多任务在单线程内做调度" ID="ID_640871081" CREATED="1642831079613" MODIFIED="1642831097628"/>
<node TEXT=" 在事件循环+回调的基础上衍生出了基于协程的解决方案，代表作有 Tornado、Twisted、asyncio 等" ID="ID_314102640" CREATED="1642830361748" MODIFIED="1642830363162"/>
<node TEXT=" Promise、协程Co-routine" ID="ID_1082513293" CREATED="1642830325652" MODIFIED="1642831118428"/>
</node>
</node>
</node>
</map>
